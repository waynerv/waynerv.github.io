<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-CN"><title type="text">Shall We Code?</title><subtitle type="html">谈谈天，写写码</subtitle><updated>2021-07-20T09:08:38+00:00</updated><id>https://www.waynerv.com/</id><link rel="alternate" type="text/html" href="https://www.waynerv.com/"/><link rel="self" type="application/atom+xml" href="https://www.waynerv.com/atom.xml"/><author><name>Waynerv</name><uri>https://www.waynerv.com/</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><generator uri="https://gohugo.io/" version="0.79.1">Hugo</generator><entry><title type="text">容器技术原理：认识容器镜像</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/learn-image-and-container-with-oci-spec/"/><id>https://www.waynerv.com/posts/learn-image-and-container-with-oci-spec/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2021-07-20T13:24:03+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">OCI 规范 OCI （Open Container Initiative）规范是事实上的容器标准，已经被大部分容器实现以及容器编排系统所采用，包括 Docker 和 Kuber……</summary><content type="html">&lt;h2 id="oci-规范">OCI 规范&lt;/h2>
&lt;p>OCI （Open Container Initiative）规范是事实上的容器标准，已经被大部分容器实现以及容器编排系统所采用，包括 Docker 和 Kubernetes。它的出现是一段关于开源商业化的有趣历史：它由 Dokcer 公司作为领头者在 2015 年推出，但如今 Docker 公司在容器行业中已经成了打工仔。&lt;/p>
&lt;p>从 OCI 规范开始了解容器镜像，可以让我们对容器技术建立更全面清晰的认知，而不是囿于实现细节。OCI 规范分为 &lt;code>Image spec&lt;/code> 和 &lt;code>Runtime spec&lt;/code> 两部分，它们分别覆盖了容器生命周期的不同阶段：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2021-07-20-oci-spec.png" alt="">&lt;/p>
&lt;h2 id="镜像规范">镜像规范&lt;/h2>
&lt;p>镜像规范定义了如何创建一个符合 OCI 规范的镜像，它规定了镜像的构建系统需要输出的内容和格式，输出的容器镜像可以被解包成一个 &lt;code>runtime bundle&lt;/code> ，&lt;code>runtime bundle&lt;/code> 是由特定文件和目录结构组成的一个文件夹，从中可以根据运行时标准运行容器。&lt;/p>
&lt;h3 id="镜像内容">镜像内容&lt;/h3>
&lt;p>规范要求镜像内容必须包括以下 3 部分：&lt;/p>
&lt;ul>
&lt;li>&lt;strong>Image Manifest&lt;/strong>：提供了镜像的配置和文件系统层定位信息，可以看作是镜像的目录，文件格式为 &lt;code>json&lt;/code> 。&lt;/li>
&lt;li>&lt;strong>Image Layer Filesystem Changeset&lt;/strong>：序列化之后的文件系统和文件系统变更，它们可按顺序一层层应用为一个容器的 rootfs，因此通常也被称为一个 &lt;code>layer&lt;/code>，文件格式可以是 &lt;code>tar&lt;/code> ，&lt;code>gzip&lt;/code> 等存档或压缩格式。&lt;/li>
&lt;li>&lt;strong>Image Configuration&lt;/strong>：包含了镜像在运行时所使用的执行参数以及有序的 rootfs 变更信息，文件类型为 &lt;code>json&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>&lt;em>rootfs (root file system)即 &lt;code>/&lt;/code> 根挂载点所挂载的文件系统，是一个操作系统所包含的文件、配置和目录，但并不包括操作系统内核，同一台机器上的所有容器都共享宿主机操作系统的内核。&lt;/em>&lt;/p>
&lt;p>接下来我们以 &lt;code>Docker&lt;/code> 和 &lt;code>nginx&lt;/code> 为例探索一个镜像的实际内容。拉取一个最新版本的 &lt;code>nginx&lt;/code> 镜像将其 &lt;code>save&lt;/code> 为 tar 包后解压：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker pull nginx
$ docker save nginx -o nginx-img.tar
$ mkdir nginx-img
$ tar -xf nginx-img.tar --directory&lt;span class="o">=&lt;/span>nginx-img
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>得到 &lt;code>nginx-img&lt;/code> 目录中的内容如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">.
├── 013a6edf61f54428da349193e7a2077a714697991d802a1c5298b07dbe0519c9
│   ├── json
│   ├── layer.tar
│   └── VERSION
├── 2bf70c858e6c8243c4713064cf43dea840866afefe52089a3b339f06576b930e
│   ├── json
│   ├── layer.tar
│   └── VERSION
├── 490a3e67a61048564048a15d501b8e075d951d0dbba8098d5788bb8453f2371f
│   ├── json
│   ├── layer.tar
│   └── VERSION
├── 4cdc5dd7eaadff5080649e8d0014f2f8d36d4ddf2eff2fdf577dd13da85c5d2f.json
├── 761c908ee54e7ccd769e815f38e3040f7b3ff51f1c04f55aac12b9ea3d544cfe
│   ├── json
│   ├── layer.tar
│   └── VERSION
├── 96bfd5bf4ab4c2513fb43534d51e816c4876620767858377d14dcc5a7de5f1fd
│   ├── json
│   ├── layer.tar
│   └── VERSION
├── d18832ef411b346c36b7ba42a6c2e3f77097026fb80651c2d870f19c6fd9ccef
│   ├── json
│   ├── layer.tar
│   └── VERSION
├── manifest.json
└── repositories
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先查看 &lt;code>manifest.json&lt;/code> 文件的内容，即该镜像的 Image Manifest：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ python -m json.tool manifest.json
&lt;span class="o">[&lt;/span>
&lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;Config&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;4cdc5dd7eaadff5080649e8d0014f2f8d36d4ddf2eff2fdf577dd13da85c5d2f.json&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;Layers&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="s2">&amp;#34;490a3e67a61048564048a15d501b8e075d951d0dbba8098d5788bb8453f2371f/layer.tar&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;2bf70c858e6c8243c4713064cf43dea840866afefe52089a3b339f06576b930e/layer.tar&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;013a6edf61f54428da349193e7a2077a714697991d802a1c5298b07dbe0519c9/layer.tar&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;761c908ee54e7ccd769e815f38e3040f7b3ff51f1c04f55aac12b9ea3d544cfe/layer.tar&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;d18832ef411b346c36b7ba42a6c2e3f77097026fb80651c2d870f19c6fd9ccef/layer.tar&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;96bfd5bf4ab4c2513fb43534d51e816c4876620767858377d14dcc5a7de5f1fd/layer.tar&amp;#34;&lt;/span>
&lt;span class="o">]&lt;/span>,
&lt;span class="s2">&amp;#34;RepoTags&amp;#34;&lt;/span>: &lt;span class="o">[&lt;/span>
&lt;span class="s2">&amp;#34;nginx:latest&amp;#34;&lt;/span>
&lt;span class="o">]&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中记载了 &lt;code>Config&lt;/code> 和 &lt;code>Layers&lt;/code> 的文件定位信息，也就是标准中所规定的 Image Layer Filesystem Changeset 和 Image Configuration。&lt;/p>
&lt;p>&lt;code>Config&lt;/code> 存放在另一个 json 文件中，内容较多我们不做展示，具体包含了以下信息：&lt;/p>
&lt;ul>
&lt;li>镜像的配置，在镜像解压成 &lt;code>runtime bundle&lt;/code> 后将写入运行时配置文件。&lt;/li>
&lt;li>镜像的 &lt;code>layers&lt;/code> 之间的 Diff ID。&lt;/li>
&lt;li>镜像的构建历史等元信息。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>Layers&lt;/code> 列表中的 tar 包共同组成了生成容器的 rootfs，容器的镜像是分层构建的， &lt;code>Layers&lt;/code> 中的元素顺序还代表了镜像层叠加的顺序，所有 &lt;code>layer&lt;/code> 组成一个由下往上叠加的栈式的结构。首先看一下基础层即第一条记录中的内容：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ mkdir base
$ tar -xf 490a3e67a61048564048a15d501b8e075d951d0dbba8098d5788bb8453f2371f/layer.tar --directory&lt;span class="o">=&lt;/span>base
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>base&lt;/code> 目录中解压得到的文件内容如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">4096&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 bin
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">13&lt;/span> 18:30 boot
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 dev
drwxr-xr-x &lt;span class="m">28&lt;/span> root root &lt;span class="m">4096&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 etc
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">13&lt;/span> 18:30 home
drwxr-xr-x &lt;span class="m">7&lt;/span> root root &lt;span class="m">85&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 lib
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">34&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 lib64
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 media
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 mnt
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 opt
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">13&lt;/span> 18:30 proc
drwx------ &lt;span class="m">2&lt;/span> root root &lt;span class="m">37&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 root
drwxr-xr-x &lt;span class="m">3&lt;/span> root root &lt;span class="m">30&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 run
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">4096&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 sbin
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 srv
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">13&lt;/span> 18:30 sys
drwxrwxrwt &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 tmp
drwxr-xr-x &lt;span class="m">10&lt;/span> root root &lt;span class="m">105&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 usr
drwxr-xr-x &lt;span class="m">11&lt;/span> root root &lt;span class="m">139&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 var
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这已经是一个完整的 rootfs，再观察最上面一层 &lt;code>layer&lt;/code> 所得到的文件内容：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">96bfd5bf4ab4c2513fb43534d51e816c4876620767858377d14dcc5a7de5f1fd/
└── docker-entrypoint.d
└── 30-tune-worker-processes.sh
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中只有一个 shell 脚本文件，这说明镜像的构建过程是增量的，每一层都只包含了和更低一层相比所变更的文件内容，这也是容器镜像得以保持较小体积的原因。&lt;/p>
&lt;h3 id="如何在变更集中体现文件的删除">如何在变更集中体现文件的删除&lt;/h3>
&lt;p>&lt;code>Layers&lt;/code> 中的每一层都是文件系统的变更集（ChangeSet），变更集包含新增、修改和删除三种变更，新增或修改（替换）文件的情况较好处理，但如何在应用变更集时删除一个文件呢，答案是用 Whiteouts 表示要删除的文件或文件夹。&lt;/p>
&lt;p>Whiteouts 文件是一个具有特殊文件名的空文件，文件名中通过在要删除的路径基本名称添加前缀 &lt;code>.wh.&lt;/code> 标志一个（更低一层中的）路径应该被删除。假如在某个 &lt;code>layer&lt;/code> 有以下文件：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">./etc/my-app.d/
./etc/my-app.d/default.cfg
./bin/my-app-tools
./etc/my-app-config
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如果在应用的更高层 &lt;code>layer&lt;/code> 中含有 &lt;code>./etc/.wh.my-app-config&lt;/code> ，应用该层变更时原有的 &lt;code>./etc/my-app-config&lt;/code> 路径将被删除。&lt;/p>
&lt;h3 id="如何将变更集应用成一个文件系统">如何将变更集应用成一个文件系统&lt;/h3>
&lt;p>标准中对于如何将变更集应用成一个文件系统只有原理性的描述，假如我们要在 &lt;code>layer A&lt;/code> 的基础上应用 &lt;code>Layer B&lt;/code> ：&lt;/p>
&lt;ul>
&lt;li>首先将 &lt;code>Layer A&lt;/code> 中的文件系统目录以保留文件属性的方式复制到另一个快照目录 &lt;code>A.snapshot&lt;/code>&lt;/li>
&lt;li>然后在快照目录中执行 &lt;code>Layer B&lt;/code> 所包含的文件变更，所有的更改不会影响原有的变更集。&lt;/li>
&lt;/ul>
&lt;h4 id="联合文件系统">联合文件系统&lt;/h4>
&lt;p>在实践中会采用联合文件系统等更为高效的实现。联合文件系统（Union File System）也叫 UnionFS，主要的功能是将多个不同位置的目录联合挂载（union mount）到同一个目录下。&lt;/p>
&lt;p>下面以 Ubuntu 发行版以及 &lt;code>unionfs-fuse&lt;/code> 实现为例演示联合挂载的效果：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先使用包管理器安装 &lt;code>unionfs-fuse&lt;/code>，这是 UnionFS 的一个实现：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">apt install unionfs-fuse
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>然后创建如下目录结构：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">A
├── a
└── x
B
├── b
└── x
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>创建目录 C 并将 A、B 目录联合挂载到 C 下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">unionfs ./B:./A ./C
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>挂载后 C 目录内容如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">C
├── a
├── b
└── x
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>如果我们分别编辑 A、B 目录中的 x 文件，会发现访问目录 C 中 x 文件得到的是 B/x 的内容（因为 B 在挂载时位于更上层）。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="docker-中的-overlayfs-实现">Docker 中的 OverlayFS 实现&lt;/h3>
&lt;p>Docker 目前在大部分发行版本中使用的联合文件系统实现是 &lt;code>overlay2&lt;/code> ，相比其他实现它更加的轻量和高效，下面以实例来简单了解其工作方式。&lt;/p>
&lt;p>接着上面 &lt;code>nginx&lt;/code> 镜像的例子，拉取镜像后相应的 &lt;code>layer&lt;/code> 解压在 &lt;code>/var/lib/docker/overlay2&lt;/code> 目录中：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ ll /var/lib/docker/overlay2/
drwx-----x &lt;span class="m">4&lt;/span> root root &lt;span class="m">72&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:01 51f6ad92703c995947429abb5c1cf829a70f19328ce2d49e24f5601bcb0cbf9e
drwx-----x &lt;span class="m">4&lt;/span> root root &lt;span class="m">72&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:01 7277919d3c55b8b021ef6f6239e03932af169a0b067ef0bce26417735d1e21a6
drwx-----x &lt;span class="m">4&lt;/span> root root &lt;span class="m">55&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:01 9ab14a4e4820e69dc6532f8fc081cb9e97207de39f7c53b90e54ef1b3012a7ff
drwx-----x &lt;span class="m">4&lt;/span> root root &lt;span class="m">72&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:01 a98e19b3221eafb2968cd6df03de93dc293e495a95acb1d103eb16ab371c9dee
brw------- &lt;span class="m">1&lt;/span> root root 253, &lt;span class="m">1&lt;/span> 7月 &lt;span class="m">15&lt;/span> 16:29 backingFsBlockDev
drwx-----x &lt;span class="m">4&lt;/span> root root &lt;span class="m">72&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:01 efc6879b6560442f4e3960cb99844d2909480c16228a53ce526f294a16cac7ee
drwx-----x &lt;span class="m">3&lt;/span> root root &lt;span class="m">47&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:00 fd047008f9fbbe5c15fe854b6fe73c71c19cd432fa580f2e8c7ef83f987abe57
drwx-----x &lt;span class="m">2&lt;/span> root root &lt;span class="m">210&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:00 l
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中 6 个名称特别长的目录中存放了镜像的 6 个 &lt;code>layer&lt;/code> ， &lt;code>l&lt;/code> 目录中包含了指向 &lt;code>layers&lt;/code> 文件夹的软链接，主要目的是在执行 &lt;code>mount&lt;/code> 命令时缩短目录标识符的长度以避免超出页大小限制。&lt;/p>
&lt;p>每个 &lt;code>layer&lt;/code> 文件夹包含的内容如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ ll 7277919d3c55b8b021ef6f6239e03932af169a0b067ef0bce26417735d1e21a6
-rw------- &lt;span class="m">1&lt;/span> root root &lt;span class="m">0&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:00 committed
drwxr-xr-x &lt;span class="m">3&lt;/span> root root &lt;span class="m">33&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:00 diff
-rw-r--r-- &lt;span class="m">1&lt;/span> root root &lt;span class="m">26&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:00 link
-rw-r--r-- &lt;span class="m">1&lt;/span> root root &lt;span class="m">86&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:00 lower
drwx------ &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:00 work
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>link&lt;/code> 记录了 &lt;code>l&lt;/code> 目录中的短链接， &lt;code>lower&lt;/code> 中记录该 &lt;code>layer&lt;/code> 的更低一层（如果没有该文件说明当前 &lt;code>layer&lt;/code> 已经是最底下一层即基础层）， &lt;code>work&lt;/code> 目录被 &lt;code>overlay2&lt;/code> 内部所使用， &lt;code>diff&lt;/code> 目录中存放了该 &lt;code>layer&lt;/code> 所包含的文件系统内容：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ ll 7277919d3c55b8b021ef6f6239e03932af169a0b067ef0bce26417735d1e21a6/diff/
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 7月 &lt;span class="m">7&lt;/span> 03:39 docker-entrypoint.d
drwxr-xr-x &lt;span class="m">20&lt;/span> root root &lt;span class="m">4096&lt;/span> 7月 &lt;span class="m">7&lt;/span> 03:39 etc
drwxr-xr-x &lt;span class="m">5&lt;/span> root root &lt;span class="m">56&lt;/span> 7月 &lt;span class="m">7&lt;/span> 03:39 lib
drwxrwxrwt &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 7月 &lt;span class="m">7&lt;/span> 03:39 tmp
drwxr-xr-x &lt;span class="m">7&lt;/span> root root &lt;span class="m">66&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 usr
drwxr-xr-x &lt;span class="m">5&lt;/span> root root &lt;span class="m">41&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 var
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在我们尝试基于该镜像运行一个容器，看看在容器阶段的联合挂载效果：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker run -d --name nginx_container nginx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>执行 &lt;code>mount&lt;/code> 命令可确认新增了一个可读写的 &lt;code>overlay&lt;/code> 挂载点：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ mount &lt;span class="p">|&lt;/span> grep overlayoverlay on /var/lib/docker/overlay2/ef9b3783509704ae1316b6c4f7e47f892c9837cdcc7efe7722bf2115eaf853ec/merged &lt;span class="nb">type&lt;/span> overlay &lt;span class="o">(&lt;/span>rw,relatime,lowerdir&lt;span class="o">=&lt;/span>/var/lib/docker/overlay2/l/PIREOHYGVNE5GDM3D7BEKAO2OH:/var/lib/docker/overlay2/l/UHXO744ZPEAMPLJ7K6W6RW4SXR:/var/lib/docker/overlay2/l/QGUGHGWQ7IP2IP7C55CVCDXBE5:/var/lib/docker/overlay2/l/QW4ZYOFSWBAAB56ZRJOPPRKSPW:/var/lib/docker/overlay2/l/FTMDNPXIB6O2QKVRXKGKF5JZN5:/var/lib/docker/overlay2/l/2W4O2Y6KH2PPR2SUIP442IXZ5C:/var/lib/docker/overlay2/l/TAQRD5PFF3DF5HV2YAW3IH6T6S,upperdir&lt;span class="o">=&lt;/span>/var/lib/docker/overlay2/ef9b3783509704ae1316b6c4f7e47f892c9837cdcc7efe7722bf2115eaf853ec/diff,workdir&lt;span class="o">=&lt;/span>/var/lib/docker/overlay2/ef9b3783509704ae1316b6c4f7e47f892c9837cdcc7efe7722bf2115eaf853ec/work&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>该挂载点中即包含了所有镜像层 &lt;code>layer&lt;/code> 组合而成的一个 rootfs：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ ll /var/lib/docker/overlay2/ef9b3783509704ae1316b6c4f7e47f892c9837cdcc7efe7722bf2115eaf853ec/merged
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">4096&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 bin
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">13&lt;/span> 18:30 boot
drwxr-xr-x &lt;span class="m">1&lt;/span> root root &lt;span class="m">43&lt;/span> 7月 &lt;span class="m">16&lt;/span> 16:52 dev
drwxr-xr-x &lt;span class="m">1&lt;/span> root root &lt;span class="m">41&lt;/span> 7月 &lt;span class="m">7&lt;/span> 03:39 docker-entrypoint.d
-rwxrwxr-x &lt;span class="m">1&lt;/span> root root &lt;span class="m">1202&lt;/span> 7月 &lt;span class="m">7&lt;/span> 03:39 docker-entrypoint.sh
drwxr-xr-x &lt;span class="m">1&lt;/span> root root &lt;span class="m">19&lt;/span> 7月 &lt;span class="m">16&lt;/span> 16:52 etc
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">13&lt;/span> 18:30 home
drwxr-xr-x &lt;span class="m">1&lt;/span> root root &lt;span class="m">56&lt;/span> 7月 &lt;span class="m">7&lt;/span> 03:39 lib
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">34&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 lib64
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 media
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 mnt
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 opt
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">13&lt;/span> 18:30 proc
drwx------ &lt;span class="m">2&lt;/span> root root &lt;span class="m">37&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 root
drwxr-xr-x &lt;span class="m">1&lt;/span> root root &lt;span class="m">23&lt;/span> 7月 &lt;span class="m">16&lt;/span> 16:52 run
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">4096&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 sbin
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 srv
drwxr-xr-x &lt;span class="m">2&lt;/span> root root &lt;span class="m">6&lt;/span> 6月 &lt;span class="m">13&lt;/span> 18:30 sys
drwxrwxrwt &lt;span class="m">1&lt;/span> root root &lt;span class="m">6&lt;/span> 7月 &lt;span class="m">7&lt;/span> 03:39 tmp
drwxr-xr-x &lt;span class="m">1&lt;/span> root root &lt;span class="m">66&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 usr
drwxr-xr-x &lt;span class="m">1&lt;/span> root root &lt;span class="m">19&lt;/span> 6月 &lt;span class="m">21&lt;/span> 08:00 var
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>除了将原来的镜像层联合挂载到如上所示的 &lt;code>merged&lt;/code> 目录，容器运行成功后 &lt;code>/var/lib/docker/overlay2&lt;/code> 还会新增两个 &lt;code>layer&lt;/code> 目录，&lt;code>merged&lt;/code> 也位于其中一个目录下:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ ll /var/lib/docker/overlay2
drwx-----x &lt;span class="m">4&lt;/span> root root &lt;span class="m">72&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:01 51f6ad92703c995947429abb5c1cf829a70f19328ce2d49e24f5601bcb0cbf9e
drwx-----x &lt;span class="m">4&lt;/span> root root &lt;span class="m">72&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:01 7277919d3c55b8b021ef6f6239e03932af169a0b067ef0bce26417735d1e21a6
drwx-----x &lt;span class="m">4&lt;/span> root root &lt;span class="m">72&lt;/span> 7月 &lt;span class="m">16&lt;/span> 16:52 9ab14a4e4820e69dc6532f8fc081cb9e97207de39f7c53b90e54ef1b3012a7ff
drwx-----x &lt;span class="m">4&lt;/span> root root &lt;span class="m">72&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:01 a98e19b3221eafb2968cd6df03de93dc293e495a95acb1d103eb16ab371c9dee
brw------- &lt;span class="m">1&lt;/span> root root 253, &lt;span class="m">1&lt;/span> 7月 &lt;span class="m">15&lt;/span> 16:29 backingFsBlockDev
drwx-----x &lt;span class="m">5&lt;/span> root root &lt;span class="m">69&lt;/span> 7月 &lt;span class="m">16&lt;/span> 16:52 ef9b3783509704ae1316b6c4f7e47f892c9837cdcc7efe7722bf2115eaf853ec
drwx-----x &lt;span class="m">4&lt;/span> root root &lt;span class="m">72&lt;/span> 7月 &lt;span class="m">16&lt;/span> 16:52 ef9b3783509704ae1316b6c4f7e47f892c9837cdcc7efe7722bf2115eaf853ec-init
drwx-----x &lt;span class="m">4&lt;/span> root root &lt;span class="m">72&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:01 efc6879b6560442f4e3960cb99844d2909480c16228a53ce526f294a16cac7ee
drwx-----x &lt;span class="m">3&lt;/span> root root &lt;span class="m">47&lt;/span> 7月 &lt;span class="m">15&lt;/span> 17:00 fd047008f9fbbe5c15fe854b6fe73c71c19cd432fa580f2e8c7ef83f987abe57
drwx-----x &lt;span class="m">2&lt;/span> root root &lt;span class="m">278&lt;/span> 7月 &lt;span class="m">16&lt;/span> 16:52 l
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过 &lt;code>inspect&lt;/code> 命令探查已运行容器的 &lt;code>GraphDriver&lt;/code>，可以更清晰地看到与镜像相比容器的 &lt;code>layers&lt;/code> 所发生的变化 :&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ docker inspect nginx_container
....
&lt;span class="s2">&amp;#34;GraphDriver&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;Data&amp;#34;&lt;/span>: &lt;span class="o">{&lt;/span>
&lt;span class="s2">&amp;#34;LowerDir&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;/var/lib/docker/overlay2/bab121ecb1d54b787b7b1834810baf212b035e28ca8d7875a09b1af837116011-init/diff:/var/lib/docker/overlay2/97aaf293fef495f0f06922d422a6187a952ec6ab29c0aa94cd87024c40e1a7e8/diff:/var/lib/docker/overlay2/fa29ec8cfe5a6c0b2cd1486f27a20a02867126edf654faad7f3520a220f3705f/diff:/var/lib/docker/overlay2/769a9f5d698522d6e55bd9882520647bd84375a751a67a8ccad1f7bb1ca066dd/diff:/var/lib/docker/overlay2/a91fb6955249dadfb34a3f5f06d083c192f2774fbec5fbb1db42a04e918432c0/diff:/var/lib/docker/overlay2/335aaf02cbde069ddf7aa0077fecac172d4b2f0240975ab0ebecc3f94f1420cc/diff:/var/lib/docker/overlay2/560df35d349e6a750f1139db22d4cb52cba2a1f106616dc1c0c68b3cf11e3df6/diff&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;MergedDir&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;/var/lib/docker/overlay2/bab121ecb1d54b787b7b1834810baf212b035e28ca8d7875a09b1af837116011/merged&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;UpperDir&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;/var/lib/docker/overlay2/bab121ecb1d54b787b7b1834810baf212b035e28ca8d7875a09b1af837116011/diff&amp;#34;&lt;/span>,
&lt;span class="s2">&amp;#34;WorkDir&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;/var/lib/docker/overlay2/bab121ecb1d54b787b7b1834810baf212b035e28ca8d7875a09b1af837116011/work&amp;#34;&lt;/span>
&lt;span class="o">}&lt;/span>,
&lt;span class="s2">&amp;#34;Name&amp;#34;&lt;/span>: &lt;span class="s2">&amp;#34;overlay2&amp;#34;&lt;/span>
&lt;span class="o">}&lt;/span>
....
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>LowerDir&lt;/code> 中记录了原有的镜像层文件系统，另外在最上层还新增了一个 &lt;code>init&lt;/code> 层，它们在容器运行阶段都是只读的；&lt;code>MergedDir&lt;/code> 中记录了将 &lt;code>LowerDir&lt;/code> 的所有目录进行联合挂载的挂载点；&lt;code>UpperDir&lt;/code> 也是新增的一个 &lt;code>layer&lt;/code> ，此时位于以上所有 &lt;code>layers&lt;/code> 的最上层，与其他镜像层相比它是可读写的。容器阶段的 &lt;code>layers&lt;/code> 示意图如下：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2021-07-20-image-layers.png" alt="">&lt;/p>
&lt;p>创建容器时所新增的可读写 &lt;code>layer&lt;/code> 我们称为 &lt;code>container layer&lt;/code>，容器运行阶段对文件系统的变更都会写入到该 &lt;code>layer&lt;/code> 中，包括对文件的新增、修改和删除，而不会改变更低层的原有镜像内容，这极大提升了镜像的分发效率。另外还会新增一个 &lt;code>init&lt;/code> 层，&lt;code>init&lt;/code> 层记录了容器在启动时写入的一些配置文件，这一过程发生在新增读写层之前，我们不希望把这些数据写入到原始镜像中。这两个新增的层在容器删除后也会被删除。&lt;/p>
&lt;h4 id="写时复制策略">写时复制策略&lt;/h4>
&lt;p>为了最小化 I/O 以及缩减镜像体积，容器的联合文件系统在读写文件时会采取写时复制策略（copy-on-write），如果一个文件或目录存在于镜像中的较低层，而另一个层（包括可写层）需要对其进行读取访问时会直接访问较低层的文件。当另一个层第一次需要写入该文件时（在构建镜像或运行容器时），该文件会被复制到该层并被修改。这一举措大大减少了容器的启动时间（启动时新建的可写层只有很少的文件写入），但容器运行后每次第一次修改某个文件都需要先将整个文件复制到 &lt;code>container layer&lt;/code> 中。&lt;/p>
&lt;p>以上原因导致容器运行时的读写效率不如原生文件系统（尤其是写入效率），在 &lt;code>container layer&lt;/code> 中不适合进行大量的文件读写，通常建议将频繁写入的数据库、日志目录等单独挂载出去，如使用 Docker 提供的 &lt;code>Volume&lt;/code>，此时目录将通过绑定挂载（Bind Mount）直接挂载在可读写层中，绕过了写时复制带来的性能损耗。&lt;/p>
&lt;h2 id="运行时规范">运行时规范&lt;/h2>
&lt;p>运行时规范描述了容器的配置、执行环境和生命周期。它详细描述了不同容器运行时架构的 &lt;code>config.json&lt;/code> 的配置字段，如何在执行环境中应用、注入这些配置，以确保容器内运行的程序在不同运行时之间环境一致，并通过容器的生命周期定义了一套统一的操作行为。&lt;/p>
&lt;p>规范所定义的容器的生命周期如下：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2021-07-20-runtime-lifecycle.png" alt="">&lt;/p>
&lt;p>规范中只定义了4种容器状态，运行时实现可以在规范的基础上添加其他状态，同时标准还规定了运行时必须支持的操作：&lt;/p>
&lt;ul>
&lt;li>Query State，查询容器的当前状态&lt;/li>
&lt;li>Create，根据镜像及配置创建一个新的容器，但是不运行用户自定义的程序&lt;/li>
&lt;li>Start，在一个已创建的容器中运行用户自定义的程序&lt;/li>
&lt;li>Kill，发送特定信号终止容器内的进程&lt;/li>
&lt;li>Delete，删除已停止容器所创建的资源&lt;/li>
&lt;/ul>
&lt;p>每个操作之前或之后还会触发不同的 hooks。&lt;/p>
&lt;h3 id="image-container-和-processes">Image, Container 和 Processes&lt;/h3>
&lt;p>容器从镜像中创建，同一个镜像可以创建多个不同的容器，还可以将运行后更改过的容器，重新打包为一个新的镜像（将可读写层添加到新镜像的只读层中即可）。&lt;/p>
&lt;p>创建容器后，就可以在不依赖宿主机依赖库的情况下从容器中运行进程。&lt;/p>
&lt;h2 id="实现和生态">实现和生态&lt;/h2>
&lt;p>Docker 向 OCI 规范捐献了其容器运行时 &lt;code>runC&lt;/code> 项目，作为该规范的标准实现。目前已有的大部分容器项目都直接将 &lt;code>runC&lt;/code> 作为运行时实现。&lt;/p>
&lt;p>下图可以概括容器生态内众多组织及项目之间的关系：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2021-07-20-runc.png" alt="">&lt;/p>
&lt;p>Kubernetes 定义了 CRI（Container Runtime Interface）以实现可替换的容器运行时，目前有 &lt;code>cri-containerd&lt;/code> 、&lt;code>cri-o&lt;/code> 和 &lt;code>docker&lt;/code> 等几种实现，但它们实际上也都基于 &lt;code>runC&lt;/code>：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2021-07-20-k8s-cri.png" alt="">&lt;/p>
&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://pierrchen.blogspot.com/2018/04/oci-open-container-spec-that-rules-all.html">Understand Container: OCI Specification&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/opencontainers/image-spec/blob/main/spec.md">Open Container Initiative Image Format Specification&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://github.com/opencontainers/runtime-spec/blob/master/spec.md">Open Container Initiative Runtime Specification&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://docs.docker.com/storage/storagedriver/">About storage drivers&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://docs.docker.com/storage/storagedriver/overlayfs-driver/">Use the OverlayFS storage driver&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.kawabangga.com/posts/4224">Docker (容器) 的原理&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>深入剖析Kubernetes-张磊&lt;/p>
&lt;/li>
&lt;/ul></content><category scheme="https://www.waynerv.com/categories/%E5%AE%B9%E5%99%A8/" term="容器" label="容器"/><category scheme="https://www.waynerv.com/tags/%E4%BA%91%E5%8E%9F%E7%94%9F/" term="云原生" label="云原生"/><category scheme="https://www.waynerv.com/tags/kubernetes/" term="Kubernetes" label="Kubernetes"/></entry><entry><title type="text">究极的 Python 开源项目模板</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/ultimate-python-open-source-project-template/"/><id>https://www.waynerv.com/posts/ultimate-python-open-source-project-template/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2021-06-25T18:08:49+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">我的 Notion 里面躺着很多关于开源项目的 idea，有些 GitHub 仓库都建好了，但真正开始的寥寥无几。除了没有时间或者需要掌握新的技术栈，还有一个……</summary><content type="html">&lt;p>我的 Notion 里面躺着很多关于开源项目的 idea，有些 GitHub 仓库都建好了，但真正开始的寥寥无几。除了没有时间或者需要掌握新的技术栈，还有一个重大阻碍是我觉得开始一个新的项目非常繁琐，尤其对于 Python 项目来说。&lt;/p>
&lt;p>制作一个项目启动模板，也是开始一个新开源项目的好 idea。两年前我曾经接触过 cookiecutter （一个项目生成工具）；在发布了几个项目后，对于 Python 打包发布到 PyPI 的流程也比较熟悉了；何况在 GitHub 上还看过许多类似的项目模板，可以 fork 后在其基础上进行自定义。一切都水到渠成，这应该不是个很难的事。&lt;/p>
&lt;p>不过我还是经过一段时间的测试和反复打磨，才终于完成一份 Python 开源项目模板：&lt;a href="https://github.com/waynerv/cookiecutter-pypackage">Cookiecutter PyPackage&lt;/a>，标题中的「究极」有夸大之嫌，但内容的确是相当全面。模板的使用方法在项目文档中有详细介绍，这篇文章主要分享我在模板中所选择的工具以及选择它们的理由。&lt;/p>
&lt;h2 id="包管理工具">包管理工具&lt;/h2>
&lt;p>Python 的包管理工具太多了，而且并没有所谓的主流，这是 Python 语言高度社区化的一个历史弊端，很难想象一门发展了近 30 年的语言，还在不断出现新的 PEP 和开源工具来改善其基础的包管理流程，用户需要为此付出相当大的学习成本。最近出现的新语言如 Go 和 Rust，基本都内置了一套完整的工具链。&lt;/p>
&lt;p>那就从一众工具中挑一个简单省事的吧。我们需要它来做下面这些事情：&lt;/p>
&lt;ul>
&lt;li>管理包的依赖&lt;/li>
&lt;li>将项目打包成能够分发的格式&lt;/li>
&lt;li>将打好的包上传到 PyPI&lt;/li>
&lt;li>顺便再管理虚拟环境啥的&lt;/li>
&lt;/ul>
&lt;p>用传统的 &lt;code>pip&lt;/code> + &lt;code>requirements.txt&lt;/code> + &lt;code>Setuptools&lt;/code> + &lt;code>twine&lt;/code> + &lt;code>venv&lt;/code> 做完这一套是没有任何问题的，但是用到的工具太多了，如果能用一个工具来做这些也许会更好。 &lt;code>Poetry&lt;/code> 就是这样的一个工具，经过一段时间的体验我觉得还不错，最喜欢的特性是可以一次性在命令行中指定依赖版本，不用再手动编辑 &lt;code>requirements.txt&lt;/code> 和 &lt;code>setup.py&lt;/code> 中的 &lt;code>install_requires&lt;/code> 了。&lt;/p>
&lt;p>另外 &lt;code>Poetry&lt;/code> 还使用了 &lt;code>pyproject.toml&lt;/code> 作为包的元信息文件，用来替换了 &lt;code>setup.py&lt;/code> + &lt;code>requirements.txt&lt;/code>，如果你对 &lt;code>pyproject.toml&lt;/code> 这种格式不太熟悉，推荐阅读：&lt;a href="https://snarky.ca/what-the-heck-is-pyproject-toml/">What the heck is pyproject.toml?&lt;/a>&lt;/p>
&lt;h2 id="检查工具">检查工具&lt;/h2>
&lt;p>对 Python 开源项目来说 flake8，pylint， isort 这类 linter/formatter 工具应该是必备了，如果你发现哪个流行的项目中没有，这可是一个贡献开源的好机会，赶紧去提 PR 吧。在之前的一篇博客&lt;a href="https://www.waynerv.com/posts/build-automatic-code-quality-workflow/">构建保障代码质量的自动化工作流&lt;/a>中，我曾经详细介绍过了这些工具的安装和使用方法。&lt;/p>
&lt;p>在模板中一共配置了如下检查工具：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>规范风格检查：&lt;/p>
&lt;ul>
&lt;li>flake8&lt;/li>
&lt;li>flake8-docstrings&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>代码自动格式化：&lt;/p>
&lt;ul>
&lt;li>black&lt;/li>
&lt;li>isort&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>静态类型检查：&lt;/p>
&lt;ul>
&lt;li>mypy&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>相应的配置项都保存在 &lt;code>setup.cfg&lt;/code> 和 &lt;code>pyproject.yaml&lt;/code> ，预设的规则不算特别严格，如果想更宽松一点可以把 &lt;code>mypy&lt;/code> 和 &lt;code>flake8-docstrings&lt;/code> 去掉，并自行修改检查项。&lt;/p>
&lt;h2 id="pre-commit">Pre-commit&lt;/h2>
&lt;p>为了自动化地对代码运行上面介绍的检查工具，我们可以将其集成到 pre-commit hooks 中，这样它们就会在每次通过 &lt;code>git&lt;/code> 提交代码时对更改过的文件运行。使用 pre-commit 时需要注意两点：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>hooks 仅对更改过的文件运行，换句话说在运行时已经通过命令行传入了目标文件参数，通常我们还会在工具的配置文件中通过 &lt;code>include&lt;/code> 类似的字段设置作用范围，因此要确认两者是否能够同时生效，比如 &lt;code>isort&lt;/code> 就需要在 hooks 配置文件 &lt;code>.pre-commit-config.yaml&lt;/code> 中添加 &lt;code>args: [ &amp;quot;--filter-files&amp;quot; ]&lt;/code> 选项：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">- repo: https://github.com/pycqa/isort
rev: 5.7.0
hooks:
- id: isort
args: &lt;span class="o">[&lt;/span> &lt;span class="s2">&amp;#34;--filter-files&amp;#34;&lt;/span> &lt;span class="o">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>每一个 hooks 会在由 pre-commit 管理的单独虚拟环境中运行，由此会引发一个常见的问题：在项目的开发虚拟环境中运行 mypy 和通过 pre-commit 运行 mypy 可能会得到不同的结果，其原因是 pre-commit 运行的 mypy 所处环境无法检测到其他第三方的包。这时可通过添加 &lt;code>additional_dependencies&lt;/code> 参数尝试解决：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">- repo: https://gitlab.woqutech.com/Quality/python-code-check/mirrors-mypy.git
rev: &lt;span class="s2">&amp;#34;v0.812&amp;#34;&lt;/span>
hooks:
- id: mypy
additional_dependencies:
- &lt;span class="s1">&amp;#39;pydantic&amp;#39;&lt;/span>
- &lt;span class="s1">&amp;#39;click&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h2 id="运行测试">运行测试&lt;/h2>
&lt;h3 id="pytest">Pytest&lt;/h3>
&lt;p>单元测试用 &lt;code>unittest&lt;/code> 或者 &lt;code>pytest&lt;/code> 都可以，选择后者的原因是之前用的比较多，而且可以通过 &lt;code>pytest-cov&lt;/code> 很方便地集成计算测试覆盖率功能，后续还可以在 CI 中集成 &lt;code>Codecov&lt;/code>。&lt;/p>
&lt;h3 id="makefile">Makefile&lt;/h3>
&lt;p>手动运行一系列检查或者构建工具是非常繁琐的，因此我加入了一个 &lt;code>Makefile&lt;/code> 可以将批量的命令和选项通过快捷命令来执行。&lt;/p>
&lt;h3 id="tox">Tox&lt;/h3>
&lt;p>我们的项目通常不止支持一个 Python （major 或 minor）版本，不同的语言版本下对程序运行上述检查可能得到不同的结果，但手动切换版本以检查程序行为的成本非常高昂，这时我们就需要用到 &lt;code>tox&lt;/code> 了，它可以自动以不同的 Python 版本创建虚拟环境，在不同环境中分别安装当前项目以及依赖，最后运行一系列预定义的测试流程，对流行的 Python 开源项目来说基本是标配。&lt;/p>
&lt;p>除了单元测试， &lt;code>tox&lt;/code> 中还加入了风格检查，格式化，文档及包的构建任务。最后配合 &lt;code>tox-gh-actions&lt;/code> 这一插件在 GitHub Actions 中运行 tox，可以确保所有的测试任务都将在 CI 中自动运行。&lt;/p>
&lt;h2 id="文档生成">文档生成&lt;/h2>
&lt;p>对于 Python 项目来说文档生成工具通常有两个选择：Sphinx 或者 Mkdocs，我曾经写过一篇关于使用 Sphinx 的博客：&lt;a href="https://www.waynerv.com/posts/use-sphinx-auto-generate-api-reference/">使用 Sphinx 为项目自动生成 API 文档&lt;/a>。在模板中我选择后者的理由如下：&lt;/p>
&lt;ul>
&lt;li>Mkdocs 以 markdown 作为默认格式，而不需要写任何 &lt;code>.rst&lt;/code> 文档。&lt;/li>
&lt;li>Mkdocs 的配置更为简单，所有的配置都在 &lt;code>mkdocs.yml&lt;/code> 文件中&lt;/li>
&lt;li>&lt;code>mkdocs-material&lt;/code> 主题非常赞。&lt;/li>
&lt;li>Mkdocs 可以通过 &lt;code>mkdocs serve&lt;/code> 命令实时预览文档效果。&lt;/li>
&lt;li>Mkdocs 拥有众多插件和扩展，大部分 Sphinx 具有的特性都有替代实现，比如通过 &lt;code>mkdocstrings&lt;/code> 实现 &lt;code>autodoc&lt;/code> 的自动生成代码文档功能。&lt;/li>
&lt;/ul>
&lt;h2 id="ci-自动化">CI 自动化&lt;/h2>
&lt;p>我们将使用免费的 GitHub Actions 作为 CI，自动执行一系列的测试、构建和发布任务。&lt;/p>
&lt;h3 id="自动运行测试">自动运行测试&lt;/h3>
&lt;p>集成了 &lt;code>tox&lt;/code> 的另一大好处，是可以轻松地通过 &lt;code>tox-gh-actions&lt;/code> 与 Actions 集成，分别以不同的 Python 版本以及不同的架构平台创建多个运行机器，并行地执行测试任务。运行的效果如下：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2021-06-25-github-workflow.png" alt="">&lt;/p>
&lt;p>每一次 &lt;code>push&lt;/code> 或者 &lt;code>pull_request&lt;/code> 都将以不同的平台和 Python 版本运行完整的测试流程。&lt;/p>
&lt;h3 id="自动发布到-pypi">自动发布到 PyPI&lt;/h3>
&lt;p>参考 PyPa 发布的 &lt;a href="https://packaging.python.org/guides/publishing-package-distribution-releases-using-github-actions-ci-cd-workflows/">Publishing package distribution releases using GitHub Actions CI/CD workflows&lt;/a>，我们将项目配置为：当向远程仓库推送标签时，自动将项目打包后分别发布到 TestPyPI 和 PyPI。&lt;/p>
&lt;h3 id="自动创建-github-release">自动创建 GitHub Release&lt;/h3>
&lt;p>GitHub 的 Release 功能可以让关注项目的用户快捷地获取最新版本和历史记录，但手动发布是不可能地，一定要做成自动的。这套自动化的工作流如下：&lt;/p>
&lt;ul>
&lt;li>参照 &lt;a href="https://keepachangelog.com/en/1.1.0/">keep a changelog&lt;/a> 为项目维护一个符合其标准的 &lt;code>CHANGELOG.md&lt;/code> 版本历史文件。&lt;/li>
&lt;li>向远程仓库推送标签以发布新版本并触发下面的流程。&lt;/li>
&lt;li>通过 &lt;code>changelog-reader-action&lt;/code> 这一 action 从 &lt;code>CHANGELOG.md&lt;/code> 文件中按规则解析出最新版本的版本信息。&lt;/li>
&lt;li>执行项目的构建得到最新版本的包。&lt;/li>
&lt;li>通过 &lt;code>action-gh-release&lt;/code> 这一 action 根据上面解析得到的版本历史信息自动创建新的 Realease，并以构建好的包作为附件。&lt;/li>
&lt;/ul></content><category scheme="https://www.waynerv.com/categories/python/" term="Python" label="Python"/><category scheme="https://www.waynerv.com/tags/ci/" term="CI" label="CI"/><category scheme="https://www.waynerv.com/tags/%E5%BC%80%E6%BA%90/" term="开源" label="开源"/></entry><entry><title type="text">使用 Sphinx 为项目自动生成 API 文档</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/use-sphinx-auto-generate-api-reference/"/><id>https://www.waynerv.com/posts/use-sphinx-auto-generate-api-reference/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2021-06-07T21:15:32+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">对于一个优秀的开源项目，高质量的文档与代码同样重要，糟糕的文档会将大部分潜在用户拒之门外。 从流行的开源项目中，我们可以总结出一些……</summary><content type="html">&lt;p>对于一个优秀的开源项目，高质量的文档与代码同样重要，糟糕的文档会将大部分潜在用户拒之门外。&lt;/p>
&lt;p>从流行的开源项目中，我们可以总结出一些关于文档的最佳实践：&lt;/p>
&lt;ul>
&lt;li>文档和代码库在一个仓库中维护以做到同步更新（个别体量超大的项目例外）&lt;/li>
&lt;li>使用纯文本格式编写文档，如 &lt;code>markdown&lt;/code> 或 &lt;code>reStructText&lt;/code>，然后通过生成工具将其转换成易于阅读且样式丰富的静态网页，进一步可通过 CI 将静态网页托管到可公开访问的站点&lt;/li>
&lt;li>在文档中直接引用实际的代码，并提供 API 文档&lt;/li>
&lt;/ul>
&lt;p>API 文档通常位于文档中的 &lt;code>API Reference&lt;/code> 或 &lt;code>References&lt;/code> 章节，它能节省用户查阅源码的时间，帮助用户快速理解项目的内部组成。对于作为库（而非应用）的项目而言，提供组织良好的 API 文档尤为重要，如 &lt;a href="https://flask.palletsprojects.com/en/2.0.x/#api-reference">Flask&lt;/a>、&lt;a href="https://click.palletsprojects.com/en/8.0.x/api/#module-click">Click&lt;/a> 等，本文就将介绍如何使用 &lt;a href="https://www.sphinx-doc.org/en/master/index.html">Sphinx&lt;/a> 为项目自动生成 API 文档。&lt;/p>
&lt;p>示例项目所使用的的完整源码已推送到 GitHub 的 &lt;a href="https://github.com/waynerv/sphinx-apidoc-demo">demo&lt;/a> 仓库中。&lt;/p>
&lt;h2 id="为什么是-sphinx">为什么是 Sphinx&lt;/h2>
&lt;p>有许多开源工具可以用来将纯文本转换为静态网页，选择 Sphinx 的理由有以下几点：&lt;/p>
&lt;ul>
&lt;li>经典老牌，使用相当广泛，Python 的官方文档也是用它所生成&lt;/li>
&lt;li>功能全面，支持各种主题和插件，和 Python 具有语言上的亲和性&lt;/li>
&lt;li>能够很方便地根据代码的文档字符串自动生成 API 文档&lt;/li>
&lt;/ul>
&lt;p>Sphinx 的默认文本格式是 &lt;a href="https://docutils.sourceforge.io/rst.html">reStructuredText&lt;/a>（简称 rst），它是一种极其强大的标记语言，配合 Sphinx 可以实现很多 markdown 所不具备的解析、引用特性，缺点是规则和指令较为复杂。这原本并不算缺点，但随着 markdown 的流行，人们似乎无法再接受任何比 markdown 更复杂一点的标记语言了。&lt;/p>
&lt;p>不过这并不是问题，我们也可以借助 &lt;a href="https://myst-parser.readthedocs.io/en/latest/">&lt;code>MyST&lt;/code>&lt;/a> 解析器实现 Sphinx 和 markdown 的完全兼容，接下来的示例中我们将混合使用 &lt;code>md&lt;/code> 和 &lt;code>rst&lt;/code> 两种格式，当然你也可以只使用任意一种格式。&lt;/p>
&lt;h2 id="新建文档项目">新建文档项目&lt;/h2>
&lt;h3 id="安装-sphinx">安装 Sphinx&lt;/h3>
&lt;p>示例将是一个 Python 语言项目，因此最直接的方式当然是通过 pip 安装：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">pip install sphinx
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对于其他语言及平台， Sphinx 也提供了丰富的安装途径，详见 &lt;a href="https://www.sphinx-doc.org/en/master/usage/installation.html#installing-sphinx">Installing Sphinx&lt;/a>。&lt;/p>
&lt;h3 id="设置文档源目录">设置文档源目录&lt;/h3>
&lt;p>我们将在同一个项目中维护代码和文档，因此首先需要在项目根目录新建一个 &lt;code>docs&lt;/code> 文件夹（也可以使用其他名称），用来存放所有和文档有关的文件，我们将使用该文件夹作为 Sphinx 工作的源目录（&lt;a href="https://www.sphinx-doc.org/en/master/glossary.html#term-source-directory">source directory&lt;/a>）。&lt;/p>
&lt;h3 id="初始化项目">初始化项目&lt;/h3>
&lt;p>切换到 &lt;code>docs&lt;/code> 目录，执行以下命令在该目录初始化一个新的 Sphinx 文档项目：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">sphinx-quickstart
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来根据命令行提示完成初始化项目的各项配置，如填写项目名称和作者，对于不理解的选项回车使用默认选项即可。&lt;/p>
&lt;p>初始化后的 &lt;code>docs&lt;/code> 目录内容如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">docs
├── Makefile
├── _build
├── _static
├── _templates
├── conf.py
├── index.rst
└── make.bat
&lt;span class="m">3&lt;/span> directories, &lt;span class="m">4&lt;/span> files
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其中最重要的是 &lt;code>conf.py&lt;/code> 文件，它是一个 Sphinx 将会运行的 Python 模块，保存着刚刚通过命令行输入的配置，还可以编辑文件来修改配置或添加插件，并通过该文件运行需要的 Python 代码。&lt;/p>
&lt;p>&lt;code>Makefile&lt;/code> 和 &lt;code>make.bat&lt;/code> 提供了一些快捷命令，在 &lt;code>docs&lt;/code> 目录执行 &lt;code>make html&lt;/code> 即可通过源文件生成静态网页。&lt;/p>
&lt;p>&lt;code>index.rst&lt;/code> 是文档源文件的首页，文档里有一些默认的样板内容，通常我们将其作为访问其他页面的入口目录。&lt;/p>
&lt;p>此时已经可以运行 &lt;code>make html&lt;/code> 生成静态网页用于预览，生成的 HTML 页面保存在 &lt;code>_build/html&lt;/code> 目录。使用浏览器打开后效果如下：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2021-06-07-sphinx-index.png" alt="">&lt;/p>
&lt;p>如果对默认的样式不满意，还可以在 &lt;a href="https://sphinx-themes.org/">Sphinx Themes Gallery&lt;/a> 找到大量可以轻松替换的文档主题。&lt;/p>
&lt;h2 id="基本使用">基本使用&lt;/h2>
&lt;h3 id="初识-restructuredtext">初识 reStructuredText&lt;/h3>
&lt;p>接下来我们借助 &lt;code>index.rst&lt;/code> 简单认识一下 reStructuredText 格式。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>标题&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="n">Welcome&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="n">sphinx&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">demo&lt;/span>&lt;span class="s1">&amp;#39;s documentation!&lt;/span>
&lt;span class="o">=======================================&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在文本的下一行连续输入同一标点符号，即可将文本标记为标题，另外还有很违反直觉的两点要求：&lt;/p>
&lt;ul>
&lt;li>符号的长度需要超出文本&lt;/li>
&lt;li>无法显式地指定标题级别，如果解析到另一种符号标记的标题，将根据出现顺序指定为新的标题级别，如&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="n">Secondary&lt;/span> &lt;span class="n">Title&lt;/span>
&lt;span class="o">----------------&lt;/span>
&lt;span class="n">Third&lt;/span> &lt;span class="n">Title&lt;/span>
&lt;span class="o">~~~~~~~~~~~~&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相比 markdown 直接使用符号的个数指示标题级别，这种规则并不算直观。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>目录树&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">..&lt;/span> &lt;span class="n">toctree&lt;/span>&lt;span class="p">::&lt;/span>
&lt;span class="p">:&lt;/span>&lt;span class="n">maxdepth&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;span class="p">:&lt;/span>&lt;span class="n">caption&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Contents&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">install&lt;/span>
&lt;span class="n">reference&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>形如 &lt;code>.. {directive}::&lt;/code> 这样的文本在 &lt;code>rst&lt;/code> 中被称为指令，可以实现各种特殊效果，比如 &lt;code>.. toctree::&lt;/code> 将在当前位置插入一颗目录树。在指令的下一行可以通过 &lt;code>:{option}: value&lt;/code> 指定选项，如上示例中指定了该目录树的最大深度和标题。&lt;/p>
&lt;p>再往下就是目录树的条目了，Sphinx 将根据条目名称如 &lt;code>install&lt;/code> 作为相对路径在源目录即 &lt;code>docs&lt;/code> 中寻找名为 &lt;code>install.rst&lt;/code> 或 &lt;code>install.md&lt;/code> 的文件，并生成指向该文件的链接。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>引用&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="n">Indices&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">tables&lt;/span>
&lt;span class="o">==================&lt;/span>
&lt;span class="o">*&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="n">ref&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="sb">`genindex`&lt;/span>
&lt;span class="o">*&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="n">ref&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="sb">`modindex`&lt;/span>
&lt;span class="o">*&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="n">ref&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="sb">`search`&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这部分内容包含了 3 种格式：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>首先是我们上面介绍过的标题。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>然后是和 markdown 类似地通过 &lt;code>*&lt;/code> 渲染列表项。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后是 &lt;code>:ref:`label_name` &lt;/code>，生成一条指向 &lt;code>label_name&lt;/code> 标签的交叉引用，这时需要通过 &lt;code>.. _label_name:&lt;/code> 指令提前创建一个全局唯一的标签，如为一个标题创建标签：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">..&lt;/span> &lt;span class="n">_label_name&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">Section&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="n">cross&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">reference&lt;/span>
&lt;span class="o">--------------------------&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>我们仅简单介绍几种在 &lt;code>index.rst&lt;/code> 中出现过的格式，实际上 reStructuredText 能实现的功能远不限于此。&lt;/p>
&lt;h3 id="添加-markdown-支持">添加 markdown 支持&lt;/h3>
&lt;p>为 Sphinx 添加 markdown 支持非常简单。&lt;/p>
&lt;p>首先安装 &lt;code>MyST&lt;/code> 插件：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">pip install myst-parser
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接着修改 &lt;code>conf.py&lt;/code> 文件，找到 &lt;code>extensions = []&lt;/code> 所在的一行，向该列表中添加 &lt;code>&amp;quot;myst_parser&amp;quot;&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="n">extensions&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;myst_parser&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>之后源目录中所有的 &lt;code>.md&lt;/code> 文件就会像 &lt;code>.rst&lt;/code> 一样被 Sphinx 正常解析。&lt;/p>
&lt;h3 id="添加新的文档内容">添加新的文档内容&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>向首页添加新的文本段落&lt;/p>
&lt;p>在已有的标题和指令之外直接插入文本即可，如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="n">Welcome&lt;/span> &lt;span class="n">to&lt;/span> &lt;span class="n">sphinx&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">demo&lt;/span>&lt;span class="s1">&amp;#39;s documentation!&lt;/span>
&lt;span class="o">=======================================&lt;/span>
&lt;span class="o">..&lt;/span> &lt;span class="n">toctree&lt;/span>&lt;span class="p">::&lt;/span>
&lt;span class="p">:&lt;/span>&lt;span class="n">maxdepth&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;span class="p">:&lt;/span>&lt;span class="n">caption&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Contents&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">Indices&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">tables&lt;/span>
&lt;span class="o">==================&lt;/span>
&lt;span class="o">*&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="n">ref&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="sb">`genindex`&lt;/span>
&lt;span class="o">*&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="n">ref&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="sb">`modindex`&lt;/span>
&lt;span class="o">*&lt;/span> &lt;span class="p">:&lt;/span>&lt;span class="n">ref&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="sb">`search`&lt;/span>
&lt;span class="err">新内容&lt;/span>
&lt;span class="o">======&lt;/span>
&lt;span class="err">这是一个新的段落&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>生成 HTML 页面如下：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2021-06-07-sphinx-new-content.png" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加新的 &lt;code>.rst&lt;/code> 文件&lt;/p>
&lt;p>在 &lt;code>docs&lt;/code> 目录中创建一个新的 &lt;code>install.rst&lt;/code> ，在文件中写入标题，然后在首页文件中添加相应的目录条目或者引用，本例中我们添加到目录树：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">..&lt;/span> &lt;span class="n">toctree&lt;/span>&lt;span class="p">::&lt;/span>
&lt;span class="p">:&lt;/span>&lt;span class="n">maxdepth&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;span class="p">:&lt;/span>&lt;span class="n">caption&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Contents&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">install&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>添加新文件时需要注意两点：&lt;/p>
&lt;ul>
&lt;li>新文件中需要至少有一个标题，否则不会生成相应的链接，且链接默认会使用该标题作为展示文本。&lt;/li>
&lt;li>在引用中添加子目录前缀即可在源目录中通过子目录管理文件。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>添加新的 &lt;code>.md&lt;/code> 文件&lt;/p>
&lt;p>我们尝试在 &lt;code>docs&lt;/code> 中创建一个子目录 &lt;code>references&lt;/code> ，然后在该目录中添加 &lt;code>api_reference.md&lt;/code> 文件，接着在 &lt;code>index.rst&lt;/code> 文件中添加以下内容引用新添加的文件：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="n">Appendix&lt;/span>
&lt;span class="o">=========&lt;/span>
&lt;span class="p">:&lt;/span>&lt;span class="n">doc&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="sb">`references/api_reference`&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>实质上与添加 &lt;code>.rst&lt;/code> 文件完全相同，因此新的文档中也需要包含标题才能生成链接。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>最终通过 &lt;code>make html&lt;/code> 生成的 HTML 页面效果如下：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2021-06-07-sphinx-new-file.png" alt="">&lt;/p>
&lt;h2 id="生成-api-文档">生成 API 文档&lt;/h2>
&lt;p>以上介绍的内容，已经足够为项目编写一般的文本内容文档，最后来看如何通过代码自动生成 API 文档。&lt;/p>
&lt;p>以单文件模块作为示例，结果同样适用于多文件的包和模块，假设我们的代码位于根目录下的 &lt;code>main.py&lt;/code> 文件（即 &lt;code>main&lt;/code> 模块）中，内容如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">Human&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;Foo class&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">gender&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;Make a virtual human.
&lt;/span>&lt;span class="s2">
&lt;/span>&lt;span class="s2"> :param sex: gender of human.
&lt;/span>&lt;span class="s2"> :param name: name of human.
&lt;/span>&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">gender&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">gender&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">name&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">name&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">speak&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">words&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;speak some words.
&lt;/span>&lt;span class="s2">
&lt;/span>&lt;span class="s2"> :param words: words to speak.
&lt;/span>&lt;span class="s2"> :return: None
&lt;/span>&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">words&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">get_intro&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;get man&amp;#39;s introduction.
&lt;/span>&lt;span class="s2">
&lt;/span>&lt;span class="s2"> :return: self introduction string.
&lt;/span>&lt;span class="s2"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="s1">&amp;#39;Name: {self.name};Gender: {self.gender}&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="启用扩展">启用扩展&lt;/h3>
&lt;p>Sphinx 通过 &lt;code>autodoc&lt;/code> 扩展导入源代码并解析其文档字符串转换成文档。此外还可通过 &lt;code>viewcode&lt;/code> 扩展直接从文档访问 API 对应的源代码页面。&lt;/p>
&lt;p>首先编辑 &lt;code>conf.py&lt;/code> 文件以启用扩展，在 extensions 配置项中加入两个扩展项：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-c" data-lang="c">&lt;span class="n">extensions&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="n">sphinx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ext&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">autodoc&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="err">&amp;#39;&lt;/span>&lt;span class="n">sphinx&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">ext&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="n">viewcode&lt;/span>&lt;span class="err">&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>为了获取文档字符串，Sphinx 需要能够导入文档所在的代码模块。也就是说，我们的源码模块必须位于 Sphinx 的导入层级结构中，这有许多种实现途径，本例选择在 &lt;code>conf.py&lt;/code> 中将代码模块所在的目录（即 &lt;code>conf.py&lt;/code> 文件所在的上一级目录）加入到 &lt;code>sys.path&lt;/code> 中，在 &lt;code>conf.py&lt;/code> 中加入以下代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="kn">import&lt;/span> &lt;span class="nn">os&lt;/span>
&lt;span class="kn">import&lt;/span> &lt;span class="nn">sys&lt;/span>
&lt;span class="n">sys&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">insert&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">path&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">abspath&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;..&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>需要注意被 Sphinx 导入时模块中的代码会被执行一次，因此我们应该隔离模块中的执行逻辑以避免产生副作用，如将其包裹在 &lt;code>if __name__ == '__main__'&lt;/code> 代码块中。&lt;/p>
&lt;h3 id="导入文档">导入文档&lt;/h3>
&lt;p>最后，在 &lt;code>references/api_reference.md&lt;/code> 文档中通过 &lt;code>automodule&lt;/code> 指令导入 &lt;code>main&lt;/code> 模块的文档：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-markdown" data-lang="markdown">&lt;span class="gh"># API Reference
&lt;/span>&lt;span class="gh">&lt;/span>
​```{eval-rst}
.. automodule:: main
:members:
​```
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>注意：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>除了 &lt;code>automodule&lt;/code> ，还可使用 &lt;code>autoclass&lt;/code> 、 &lt;code>autofunction&lt;/code> 等指令为其他类型的 Python 对象自动生成文档。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>为了在 markdown 格式中使用 &lt;code>autodoc&lt;/code> ，需要使用 &lt;code>eval-rst&lt;/code> 指令对导入文档的指令做一层封装，详见 &lt;a href="https://myst-parser.readthedocs.io/en/latest/using/howto.html#use-sphinx-ext-autodoc-in-markdown-files">Use sphinx.ext.autodoc in Markdown files&lt;/a>，它等价于 &lt;code>.rst&lt;/code> 文件的如下写法：&lt;/p>
&lt;pre>&lt;code>.. automodule:: main
:members:
&lt;/code>&lt;/pre>&lt;/li>
&lt;/ul>
&lt;p>&lt;code>references/api_reference.md&lt;/code> 生成的页面效果如下：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2021-06-07-sphinx-autodoc.png" alt="">&lt;/p>
&lt;p>通过页面右侧的 &lt;code>[source]&lt;/code> 链接还能够直接从文档页面跳转到相应的源代码：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2021-06-07-sphinx-viewcode.png" alt="">&lt;/p>
&lt;h3 id="文档字符串风格">文档字符串风格&lt;/h3>
&lt;p>上面的示例代码中，我们使用 reStructuredText 风格编写文档字符串，如果你更喜欢 &lt;a href="https://numpydoc.readthedocs.io/en/latest/format.html#docstring-standard">NumPy&lt;/a> 或 &lt;a href="https://github.com/google/styleguide/blob/gh-pages/pyguide.md#38-comments-and-docstrings">Google &lt;/a>风格的文档字符串，可以启用 &lt;code>napoleon&lt;/code> 扩展与之兼容。&lt;code>napoleon&lt;/code> 是一个预处理器，在 &lt;code>autodoc&lt;/code> 处理文档字符串之前将其转换为正确的 reStructuredText 文本。&lt;/p>
&lt;p>启用方法同样是修改 &lt;code>conf.py&lt;/code> 文件的 extensions 配置项：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="c1"># conf.py&lt;/span>
&lt;span class="c1"># Add napoleon to the extensions list&lt;/span>
&lt;span class="n">extensions&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;sphinx.ext.napoleon&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>启用后 &lt;code>autodoc&lt;/code> 将能够同时支持 reStructuredText、NumPy 及 Google 三种不同风格的文档字符串。&lt;/p>
&lt;h2 id="其他途径">其他途径&lt;/h2>
&lt;p>除了 Sphinx ，使用 &lt;a href="https://www.mkdocs.org/">MkDocs&lt;/a> 配合 &lt;a href="https://github.com/mkdocstrings/mkdocstrings">&lt;code>mkdocstrings&lt;/code>&lt;/a> 扩展包也能实现自动从源码生成文档。相比之下 MkDocs 配置更加简单，原生支持 markdown 且可以运行预览用的开发服务器，目前在 Python 项目中也非常流行。&lt;/p>
&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://www.sphinx-doc.org/en/master/usage/quickstart.html#autodoc">Getting Started - Sphinx documentation&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://myst-parser.readthedocs.io/en/latest/using/howto.html#use-sphinx-ext-autodoc-in-markdown-files">How-To Guides&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></content><category scheme="https://www.waynerv.com/categories/%E5%B7%A5%E5%85%B7/" term="工具" label="工具"/></entry><entry><title type="text">Python 中 time 和 datetime 模块的区别</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/differences-bettween-time-and-datetime-in-python/"/><id>https://www.waynerv.com/posts/differences-bettween-time-and-datetime-in-python/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2021-04-29T17:07:23+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">Python 中内置了许多和操作时间有关的 API，它们分布在 &lt;code>time&lt;/code> ， &lt;code>datetime&lt;/code> 等标准库中，即使熟悉 Python 也可能记混它们的用法，本文将力求清晰地阐述它们之间的区别。</summary><content type="html">&lt;p>Python 中内置了许多和操作时间有关的 API，它们分布在 &lt;code>time&lt;/code> ， &lt;code>datetime&lt;/code> 等标准库中，用法繁多且容易混淆，本文将力求清晰地阐述这些 API 的关键部分和区别，帮助你了解并掌握其用法。&lt;/p>
&lt;p>下文将分别介绍每个模块的主要目的、核心对象、常用方法以及用途，并在最后做分析对比，如果已经了解这些细节可以直接跳转到结尾的总结对比部分。&lt;/p>
&lt;p>另外本文将避免涉及字符串格式化、时区、冬夏令时等更复杂深入的话题。&lt;/p>
&lt;h2 id="time-模块">time 模块&lt;/h2>
&lt;p>概括来说，&lt;code>time&lt;/code> 模块通过系统底层的计时器获取自 &lt;code>epoch&lt;/code> 以来经过的总秒数（可能为浮点数），即我们常说的 POSIX 时间戳（timestamp）。它的用法较为低阶，适合用做精确计时。对 Unix 系统来说， &lt;code>epoch&lt;/code> 为 &lt;code>1970年1月1日 00:00:00（UTC）&lt;/code>，因此该模块也可以将时间戳转换为具体的日期时间，但表示日期时间的对象结构非常简单，不适合进行复杂的操作和表示。&lt;/p>
&lt;h3 id="核心对象">核心对象&lt;/h3>
&lt;p>&lt;code>time&lt;/code> 模块的 API 中只有一个类： &lt;code>time.struct_time&lt;/code>。&lt;/p>
&lt;p>&lt;code>struct_time&lt;/code> 是一个转换 &lt;code>epoch&lt;/code> 以来经过秒数得到的结构化的时间对象，它提供了类似 &lt;code>namedtuple&lt;/code> 的 API，可以通过下标或属性名称获取对象的年月日时分秒等属性。调用 &lt;code>gmtime()&lt;/code> ，&lt;code>localtime()&lt;/code>，&lt;code>strptime()&lt;/code> 等方法可得到 &lt;code>struct_time&lt;/code> 实例。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">st&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">localtime&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">st&lt;/span>
&lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">struct_time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tm_year&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_mon&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_mday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">29&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_hour&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_min&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">39&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_sec&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">14&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_wday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_yday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">119&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_isdst&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">st&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">tm_mon&lt;/span>
&lt;span class="mi">4&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">st&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="mi">4&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>从示例中可以看到，&lt;code>struct_time&lt;/code> 实例实质是一个数字组成的类元祖序列，该模块中接收 &lt;code>struct_time&lt;/code> 实例作为参数的函数都可以直接接收一个同样长度的元祖。它只能简单的记录通过换算时间戳得到的年月日时分等属性，没有提供支持额外操作的其他方法，因此实践中的用途非常有限。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">st1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">localtime&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">st2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">localtime&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">st2&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">st1&lt;/span>
&lt;span class="n">Traceback&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="n">most&lt;/span> &lt;span class="n">recent&lt;/span> &lt;span class="n">call&lt;/span> &lt;span class="n">last&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">File&lt;/span> &lt;span class="s2">&amp;#34;&amp;lt;input&amp;gt;&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">line&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">module&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="n">st2&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">st1&lt;/span>
&lt;span class="ne">TypeError&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">unsupported&lt;/span> &lt;span class="n">operand&lt;/span> &lt;span class="nb">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">s&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s1">&amp;#39;time.struct_time&amp;#39;&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="s1">&amp;#39;time.struct_time&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="常见用途与函数">常见用途与函数&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>计时&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>time.time()&lt;/code> 以浮点数的形式返回自 &lt;code>epoch&lt;/code> 以来经过的时间秒数。常见用法是通过计算两次调用之间的间隔来得出程序执行时间。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="mf">1619665423.683973&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>time.sleep(seconds)&lt;/code> 暂停调用线程的执行，暂停时间为给定的秒数。经常用于测试模拟，实际的暂停时间可能超出给定秒数。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>time.perf_counter()&lt;/code> 是计算较短时间间隔的更好方法，结果更为精确，在计算执行时间时可替代上述的 &lt;code>time.time()&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">start&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">perf_counter&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">end&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">perf_counter&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">end&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">start&lt;/span>
&lt;span class="mf">2.731515233999744&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>在 &lt;code>struct_time&lt;/code> 和时间戳之间进行转换&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>time.gmtime([secs])&lt;/code> 将给定秒数转换为一个 UTC 时区 &lt;code>struct_time&lt;/code> 对象，若未提供秒数将使用 &lt;code>time.time()&lt;/code> 得到的返回值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">now&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">gmtime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">struct_time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tm_year&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_mon&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_mday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">29&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_hour&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_min&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">51&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_sec&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">54&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_wday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_yday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">119&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_isdst&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">gmtime&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">struct_time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tm_year&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_mon&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_mday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">29&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_hour&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_min&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">51&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_sec&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">56&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_wday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_yday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">119&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_isdst&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>time.localtime([secs])&lt;/code> 将给定秒数转换为一个本地时区的 &lt;code>struct_time&lt;/code> 对象，若未提供秒数将使用 &lt;code>time.time()&lt;/code> 得到的返回值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">localtime&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">struct_time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tm_year&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_mon&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_mday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">29&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_hour&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_min&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">53&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_sec&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">38&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_wday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_yday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">119&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_isdst&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>time.mktime(t)&lt;/code> 将一个 &lt;code>struct_time&lt;/code> 对象转换为秒数，该对象将被当做本地时区处理，效果刚好与 &lt;code>time.localtime([secs])&lt;/code> 相反。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">mktime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">localtime&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="mf">1619672313.0&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>在 &lt;code>struct_time&lt;/code> 和字符串之间进行转换&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>time.strftime(format[, t])&lt;/code> 将一个 &lt;code>struct_time&lt;/code> 对象按指定的 &lt;code>format&lt;/code> 编码格式化为字符串，&lt;code>t&lt;/code> 的默认值是 &lt;code>time.localtime()&lt;/code> 的返回值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">strftime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;%H:%M:%S&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="s1">&amp;#39;13:10:37&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>time.strptime(string[, format])&lt;/code> 将一个字符串按指定的 &lt;code>format&lt;/code> 编码解析为 &lt;code>struct_time&lt;/code> 对象，&lt;code>format&lt;/code> 的默认值为 &lt;code>&amp;quot;%a %b %d %H:%M:%S %Y&amp;quot;&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">strptime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;30 Nov 00&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="si">%d&lt;/span>&lt;span class="s2"> %b %y&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">struct_time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tm_year&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2000&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_mon&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">11&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_mday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">30&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_hour&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_min&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">tm_sec&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_wday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_yday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">335&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_isdst&lt;/span>&lt;span class="o">=-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>如上示例，解析时未提供的时间单位将使用默认值填充。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;h2 id="datetime-模块">datetime 模块&lt;/h2>
&lt;p>&lt;code>datetime&lt;/code> 模块支持日期和时间的运算，但实现的重点是为输出格式化和操作提供高效的属性提取。&lt;/p>
&lt;p>&lt;code>datetime&lt;/code> 模块提供了一些用于操作日期和时间的类。该模块的绝大部分功能都围绕着以下 4 个类（以及另外两个关于时区的类）的方法和属性来实现。一个容易让人混淆的点是，虽然它们全都是 Python 类，但在命名中并未遵循首字母大写的惯例，在导入时看上去就像是 &lt;code>datetime&lt;/code> 下的子包或者子模块。&lt;/p>
&lt;p>我们将简要介绍每一个类&lt;strong>常用的&lt;/strong>实例构造方式、支持的操作符、实例方法以及实例属性。&lt;/p>
&lt;h3 id="date">&lt;code>date&lt;/code>&lt;/h3>
&lt;p>表示日期类型。&lt;/p>
&lt;h4 id="实例构造方式">实例构造方式&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>实例化 &lt;code>date&lt;/code> 类，需要传入日期对应的年月日参数。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">date&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">29&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">date&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">29&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>date.fromtimestamp(timestamp)&lt;/code> 类方法，需要传入的参数为通过 &lt;code>time&lt;/code> 模块获取的 &lt;code>epoch&lt;/code> 以来秒数（即时间戳）。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">date&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fromtimestamp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">date&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">29&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>date.today()&lt;/code> 类方法，实质是以当前时间戳作为参数调用 &lt;code>date.fromtimestamp()&lt;/code> 类方法。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>date.fromisoformat(date_string)&lt;/code> 类方法，这是一种较为直观的创建方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">date&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fromisoformat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;2021-04-29&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">date&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">29&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="支持的操作符">支持的操作符&lt;/h4>
&lt;ul>
&lt;li>支持与另一 &lt;code>date&lt;/code> 对象进行 &lt;code>==&lt;/code>，&lt;code>≤&lt;/code>，&lt;code>&amp;lt;&lt;/code>，&lt;code>≥&lt;/code>，&lt;code>&amp;gt;&lt;/code> 等比较操作。&lt;/li>
&lt;li>支持与 &lt;code>timedelta&lt;/code> 对象进行加减操作，结果依然为 &lt;code>date&lt;/code> 对象。&lt;/li>
&lt;li>支持与另一 &lt;code>date&lt;/code> 对象进行相减操作，得到 &lt;code>timedelta&lt;/code> 对象。&lt;/li>
&lt;li>支持哈希。&lt;/li>
&lt;/ul>
&lt;h4 id="实例方法">实例方法&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>&lt;code>strftime(self, fmt)&lt;/code> 按指定的 &lt;code>fmt&lt;/code> 格式化编码返回当前 &lt;code>date&lt;/code> 对象的字符串表示。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">date&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">today&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">strftime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;%Y-%m-&lt;/span>&lt;span class="si">%d&lt;/span>&lt;span class="s1">&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="s1">&amp;#39;2021-04-29&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>isoformat(self)&lt;/code> 返回当前 &lt;code>date&lt;/code> 对象的 &lt;code>iso&lt;/code> 字符串表示。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isoformat&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="s1">&amp;#39;2021-04-29&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>timetuple(self)&lt;/code> 将当前 &lt;code>date&lt;/code> 对象转换成 &lt;code>time&lt;/code> 模块的 &lt;code>struct_time&lt;/code> 对象并返回，时分秒等属性使用默认值填充。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timetuple&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">struct_time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">tm_year&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_mon&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_mday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">29&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_hour&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_min&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_sec&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_wday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_yday&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">119&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">tm_isdst&lt;/span>&lt;span class="o">=-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>replace(self, year=None, month=None, day=None)&lt;/code> 返回替换当前 &lt;code>date&lt;/code> 对象的某一属性后的副本。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">replace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">day&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">30&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">date&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">30&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>weekday(self)&lt;/code> 返回当前 &lt;code>date&lt;/code> 对象所属的星期，从 0 开始。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">weekday&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="mi">3&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="实例属性">实例属性&lt;/h4>
&lt;ul>
&lt;li>&lt;code>year&lt;/code>&lt;/li>
&lt;li>&lt;code>month&lt;/code>&lt;/li>
&lt;li>&lt;code>day&lt;/code>&lt;/li>
&lt;/ul>
&lt;h3 id="time">&lt;code>time&lt;/code>&lt;/h3>
&lt;p>表示时间（时分秒）类型。&lt;/p>
&lt;h4 id="实例构造方式-1">实例构造方式&lt;/h4>
&lt;p>&lt;code>time&lt;/code> 不支持通过时间戳构造实例。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>实例化 &lt;code>time&lt;/code> 类并传入对应参数。需要传入时间对应的时分秒微秒等参数，参数均有取值范围且默认值为 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">date&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">29&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">date&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">29&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>通过调用&lt;code>fromisoformat(cls, time_string)&lt;/code> 类方法，从 &lt;code>iso&lt;/code> 字符串中创建一个实例：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fromisoformat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;17:32:10&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">17&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">32&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">10&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="支持的操作符-1">支持的操作符&lt;/h4>
&lt;ul>
&lt;li>支持与另一 &lt;code>time&lt;/code> 对象进行 &lt;code>==&lt;/code>，&lt;code>≤&lt;/code>，&lt;code>&amp;lt;&lt;/code>，&lt;code>≥&lt;/code>，&lt;code>&amp;gt;&lt;/code> 等比较操作。&lt;/li>
&lt;li>支持哈希。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>time&lt;/code> 对象不支持与 &lt;code>time&lt;/code> 或 &lt;code>timedelta&lt;/code> 进行加减操作，如果我们想计算两个 &lt;code>time&lt;/code> 对象之间的时间间隔，可以使用 &lt;code>datetime.combine()&lt;/code> 将它们处理为日期相同的 &lt;code>datetime&lt;/code> 对象再进行计算:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">combine&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">date&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">today&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">combine&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">date&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">today&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">t1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timedelta&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">seconds&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">4440&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="实例方法-1">实例方法&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>&lt;code>strftime(self, fmt)&lt;/code> 按指定的 &lt;code>fmt&lt;/code> 格式化编码返回当前 &lt;code>time&lt;/code> 对象的字符串表示。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fromisoformat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;17:32:10&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">strftime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;%Hh %Mm %Ss&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="s1">&amp;#39;17h 32m 10s&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>isoformat(self)&lt;/code> 返回当前 &lt;code>time&lt;/code> 对象的 &lt;code>iso&lt;/code> 字符串表示。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hour&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">17&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">minute&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">27&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">second&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">55&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">isoformat&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="s1">&amp;#39;17:27:55&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>replace(self,hour=None,minute=None,second=None,microsecond=None, tzinfo=True, *,fold=None)&lt;/code> 返回替换当前 &lt;code>time&lt;/code> 对象的某一属性后的副本。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">replace&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">hour&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">27&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">55&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="实例属性-1">实例属性&lt;/h4>
&lt;ul>
&lt;li>&lt;code>hour&lt;/code>&lt;/li>
&lt;li>&lt;code>minute&lt;/code>&lt;/li>
&lt;li>&lt;code>second&lt;/code>&lt;/li>
&lt;li>以及 &lt;code>micorsecond&lt;/code> ，&lt;code>tzinfo&lt;/code>，&lt;code>fold&lt;/code> 等属性&lt;/li>
&lt;/ul>
&lt;h3 id="datetime">&lt;code>datetime&lt;/code>&lt;/h3>
&lt;p>表示包含日期时分的时间类型，是 &lt;code>date&lt;/code> 的子类，因此也继承了 &lt;code>date&lt;/code> 的所有属性和方法。它的实例还可以视作 &lt;code>date&lt;/code> 和 &lt;code>time&lt;/code> 实例的组合体，因此同时具备了两种对象的大部分方法和属性。&lt;/p>
&lt;p>下文的介绍中不包含从 &lt;code>date&lt;/code> 继承的方法和属性。&lt;/p>
&lt;h4 id="实例构造方式-2">实例构造方式&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>实例化 &lt;code>datetime&lt;/code> 类并传入对应参数，接收参数为 &lt;code>date&lt;/code> 和 &lt;code>time&lt;/code> 实例化参数的组合，其中日期参数为必填参数，其他参数有默认值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">year&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">month&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">day&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">29&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">datetime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">29&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>datetime.now()&lt;/code> 或 &lt;code>datetime.utcnow()&lt;/code> 类方法，区别为实例的对应时区不同。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">datetime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">29&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">53&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">648203&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">utcnow&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">datetime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">29&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">5&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">671572&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>调用 &lt;code>datetime.fromtimestamp(timestamp)&lt;/code> 或 &lt;code>datetime.utcfromtimestamp(timestamp)&lt;/code> 类方法并传入时间戳，区别为实例的对应时区不同。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="kn">import&lt;/span> &lt;span class="nn">time&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">utcfromtimestamp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">datetime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">29&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">8&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">798136&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fromtimestamp&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">())&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">datetime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">29&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">6&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">26&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">251251&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>通过调用 &lt;code>datetime.fromisoformat(time_string)&lt;/code> 类方法，从 &lt;code>iso&lt;/code> 字符串中创建一个实例：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fromisoformat&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;2021-04-29 16:09:32&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">datetime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">29&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">32&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>通过调用 &lt;code>datetime.combine(date, time)&lt;/code> 类方法，从 &lt;code>date&lt;/code> 实例和 &lt;code>time&lt;/code> 实例中创建一个新的 &lt;code>datetime&lt;/code> 实例。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">combine&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">date&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">today&lt;/span>&lt;span class="p">(),&lt;/span> &lt;span class="n">time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">12&lt;/span>&lt;span class="p">))&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">datetime&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">29&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">16&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">12&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>通过调用 &lt;code>datetime.strptime(date_string, format)&lt;/code> 类方法，解析格式化字符串并创建一个新的实例。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h4 id="支持的操作符-2">支持的操作符&lt;/h4>
&lt;ul>
&lt;li>&lt;code>datetime&lt;/code> 支持与 &lt;code>date&lt;/code> 进行相等比较，但结果一定为 &lt;code>False&lt;/code> ，除此之外只支持与另一 &lt;code>datetime&lt;/code> 对象执行 &lt;code>==&lt;/code>，&lt;code>≤&lt;/code>，&lt;code>&amp;lt;&lt;/code>，&lt;code>≥&lt;/code>，&lt;code>&amp;gt;&lt;/code> 等比较操作。&lt;/li>
&lt;li>支持与 &lt;code>timedelta&lt;/code> 相加，结果为 &lt;code>datetime&lt;/code>；支持与 &lt;code>timedelta&lt;/code> 对象进行加减，结果依然为 &lt;code>datetime&lt;/code> 对象，与另一 &lt;code>datetime&lt;/code> 对象进行相减，得到 &lt;code>timedelta&lt;/code> 对象。&lt;/li>
&lt;li>同样支持哈希。&lt;/li>
&lt;/ul>
&lt;h4 id="实例方法-2">实例方法&lt;/h4>
&lt;p>除了从 &lt;code>date&lt;/code> 继承的 &lt;code>strftime()&lt;/code>、&lt;code>timetuple()&lt;/code>、&lt;code>isoformat()&lt;/code> 和 &lt;code>replace()&lt;/code>等方法外，还拥有以下方法：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>timestamp(self)&lt;/code> 返回一个浮点数格式的 POSIX 时间戳。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">dt&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">dt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timestamp&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="mf">1619685580.762657&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>date(self)&lt;/code> 返回一个代表日期部分的 &lt;code>date&lt;/code> 对象。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">dt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">date&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">date&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2021&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">29&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>&lt;code>time(self)&lt;/code> 返回一个代表时分部分的 &lt;code>time&lt;/code> 对象。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">dt&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">time&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">39&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">40&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">762657&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="实例属性-2">实例属性&lt;/h4>
&lt;p>同时具有&lt;code>date&lt;/code> 和 &lt;code>time&lt;/code> 实例的所有属性。&lt;/p>
&lt;h3 id="timedelta">&lt;code>timedelta&lt;/code>&lt;/h3>
&lt;p>表示两个 &lt;code>datetime&lt;/code> 对象之间的差异。&lt;/p>
&lt;h4 id="实例构造方式-3">实例构造方式&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>实例化 &lt;code>timedelta&lt;/code> 类并传入对应参数，接收参数与 &lt;code>datetime&lt;/code> 类基本相同但不包括年，默认值均为 0。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">timedelta&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">days&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timedelta&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">days&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>对两个 &lt;code>datetime&lt;/code> 执行相减：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">dt1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">dt2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">dt2&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">dt1&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timedelta&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">seconds&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">microseconds&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">476390&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="支持的操作符-3">支持的操作符&lt;/h4>
&lt;ul>
&lt;li>
&lt;p>只支持与另一 &lt;code>timedelta&lt;/code> 进行比较，进行 &lt;code>==&lt;/code>，&lt;code>≤&lt;/code>，&lt;code>&amp;lt;&lt;/code>，&lt;code>≥&lt;/code>，&lt;code>&amp;gt;&lt;/code> 等比较操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>timedelta&lt;/code> 对象支持支持加减操作，&lt;code>datetime&lt;/code> 与 &lt;code>timedelta&lt;/code> 相加或相减仍然返回 &lt;code>datetime&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>timedelta&lt;/code> 还支持乘除模除等操作符。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>支持哈希。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>timedelta&lt;/code> 是有符号的，支持 &lt;code>abs()&lt;/code> 函数，可返回两个 &lt;code>datetime&lt;/code> 之间的绝对间隔。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">dt1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">dt2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">now&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">td&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dt1&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">dt2&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">td&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timedelta&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">days&lt;/span>&lt;span class="o">=-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">seconds&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">86395&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">microseconds&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">573188&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">td&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">total_seconds&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">-&lt;/span>&lt;span class="mf">4.426812&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="nb">abs&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">td&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timedelta&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">seconds&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">4&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">microseconds&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">426812&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;h4 id="实例方法-3">实例方法&lt;/h4>
&lt;ul>
&lt;li>&lt;code>total_seconds(self)&lt;/code> 返回该时间间隔的所有秒数。&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">timedelta&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">minutes&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">seconds&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">35&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">total_seconds&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="mf">215.0&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="实例属性-3">实例属性&lt;/h4>
&lt;p>&lt;code>timedelta&lt;/code> 只通过 &lt;code>days&lt;/code> 、&lt;code>seconds&lt;/code>，&lt;code>microseconds&lt;/code> 这 3 种单位进行组合来保存时间间隔，可通过对应属性获取数值。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d1&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">timedelta&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">minutes&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">seconds&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">35&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d1&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timedelta&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">days&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">seconds&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">215&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">microseconds&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d2&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">timedelta&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">days&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d2&lt;/span>
&lt;span class="n">datetime&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">timedelta&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">days&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">seconds&lt;/span>
&lt;span class="mi">0&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="总结对比">总结对比&lt;/h2>
&lt;h3 id="time-与-datetime-模块的区别">&lt;code>time&lt;/code> 与 &lt;code>datetime&lt;/code> 模块的区别：&lt;/h3>
&lt;ul>
&lt;li>&lt;code>time&lt;/code> 模块，获取系统时间戳，主要用于计时或表示某一时间点，可以通过数值元祖表示结构化的日期时间，但不支持进一步的转换或操作。&lt;/li>
&lt;li>&lt;code>datetime&lt;/code> 模块，基于时间戳构建高阶的日期、时间、间隔等对象，支持丰富的转换方式和操作。&lt;/li>
&lt;/ul>
&lt;h3 id="datetime-模块中不同对象的区别">&lt;code>datetime&lt;/code> 模块中不同对象的区别：&lt;/h3>
&lt;ul>
&lt;li>&lt;code>date&lt;/code> 只表示日期。支持与 &lt;code>date&lt;/code> 或 &lt;code>timedelta&lt;/code> 进行加减操作.&lt;/li>
&lt;li>&lt;code>time&lt;/code> 只表示时分。不支持与 &lt;code>time&lt;/code> 或 &lt;code>timedelta&lt;/code> 进行加减操作，计算间隔需要先转换成 &lt;code>datetime&lt;/code> 对象。&lt;/li>
&lt;li>&lt;code>datetime&lt;/code> 同时表示日期和时分的时间对象。同时具备 &lt;code>date&lt;/code> 和 &lt;code>time&lt;/code> 对象的行为和属性，可以从中解析出单独的 &lt;code>date&lt;/code> 和 &lt;code>time&lt;/code> 对象。&lt;/li>
&lt;li>&lt;code>timedelta&lt;/code> 表示两个时间之间的间隔。只通过 &lt;code>days&lt;/code> 、&lt;code>seconds&lt;/code>，&lt;code>microseconds&lt;/code> 这 3 种单位来表示。&lt;/li>
&lt;/ul>
&lt;h3 id="字符串格式化与解析">字符串格式化与解析&lt;/h3>
&lt;p>字符串格式化与解析：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>time.struct_time&lt;/code>、&lt;code>datetime.date&lt;/code>、&lt;code>datetime.time&lt;/code>、&lt;code>datetime.datetime&lt;/code> 等对象都可以通过 &lt;code>strftime()&lt;/code> （string format）实例方法或函数转换为指定格式的字符串。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>特定格式的字符串仅可以通过 &lt;code>strptime()&lt;/code>（string parse）类方法或函数直接转换为&lt;code>time.struct_time&lt;/code>、&lt;code>datetime.datetime&lt;/code> 对象。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>ISO 格式字符串格式化与解析：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>datetime.date&lt;/code>、&lt;code>datetime.time&lt;/code>、&lt;code>datetime.datetime&lt;/code> 等对象都可以通过 &lt;code>isoformat()&lt;/code> 实例方法转换为 ISO 8601 格式的字符串。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>ISO 8601 格式的字符串可以通过 &lt;code>fromisoformat()&lt;/code> 类方法直接转换为&lt;code>datetime.date&lt;/code>、&lt;code>datetime.time&lt;/code>、&lt;code>datetime.datetime&lt;/code> 对象。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="图表">图表&lt;/h3>
&lt;p>用一张&lt;a href="http://www.plantuml.com/plantuml/png/hLHDhzCm4BpxLrYFIoALSgzKzCI52pUELVNan4uRYEF8NYFuzzYhr67fAlZ0RJzcnfl9sgy1b8Te9t4VjP63Sz2vds99nR4V5pM3XD6QXBAB4AabNt8khTDnCY_o2NaCu6CFRpaMPjOoSLQYLc08-TsNyNQ7pzwOcUWyWCSSy1sKPpjhiCFJPWBrrsnVmO_pxJ7IfobIVW1FyZ6umNchu2rtYjJb_SVDhfCi9pQj4EVprfAzctyO3_9y5biHoTJ1LMDolPfGw0BXsbPnRfOI24OoWzhlI0ZG2d80jVP4q-FWdIte1aAxmyNfdakC1i4m0xlkst5Zj0SiHEYt6ZgUowQ7F-ocognzHHpYCfc66QQ6HcOgKbIhsg3UsMwSJPCB1pow5MIb_uyI1fmQVXn6pR_Wn0lsavdBU98XTk1L3rBD3kx68sZzVUAPm4oejFvGLBfVKl4IQr0_I25K3uC1Fn2HmWqDu2K-9Vb4BHVbWqbxojxOb9xAuWtexs3XSaYDA_ql1PwF8cYwE5Ku3FQn8gNihIYL1S4fIECcohL5IkNQ4W7au_Mcpp1duxCf6wLyIYarZ3crU0pgE8BqcLKk3-l6Ii1sXqTzmxHUW3UVux-QMKSx_GO0">时序图&lt;/a>总结上文内容：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/datetime-sequence.png" alt="datetime-sequence">&lt;/p>
&lt;ul>
&lt;li>&lt;code>[ts]&lt;/code> 表示该参数具有默认值是可选的。&lt;/li>
&lt;li>请注意区分图中的实例方法、类方法以及模块函数：
&lt;ul>
&lt;li>名称中以 &lt;code>time.&lt;/code> 开头的均为 &lt;code>time&lt;/code> 模块的函数&lt;/li>
&lt;li>名称中以 &lt;code>obj.&lt;/code> 开头的均为 &lt;code>date&lt;/code>、&lt;code>time&lt;/code> 或 &lt;code>datetime&lt;/code> 对象的实例方法&lt;/li>
&lt;li>其余名称的函数均为类方法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul></content><category scheme="https://www.waynerv.com/categories/python/" term="Python" label="Python"/></entry><entry><title type="text">理解 Python 中的描述符</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/python-descriptor-in-detail/"/><id>https://www.waynerv.com/posts/python-descriptor-in-detail/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2021-04-15T21:32:47+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">描述符是 Python 中的一个进阶概念，也是许多 Python 内部机制的实现基础，本文将对其做适当深入的介绍。</summary><content type="html">&lt;p>描述符是 Python 中的一个进阶概念，也是许多 Python 内部机制的实现基础，本文将对其做适当深入的介绍。&lt;/p>
&lt;h2 id="描述符的定义">描述符的定义&lt;/h2>
&lt;p>描述符的定义很简单，实现了下列&lt;em>任意一个方法&lt;/em>的 Python 对象就是一个描述符（descriptor）：&lt;/p>
&lt;ul>
&lt;li>&lt;code>__get__(self, obj, type=None)&lt;/code>&lt;/li>
&lt;li>&lt;code>__set__(self, obj, value)&lt;/code>&lt;/li>
&lt;li>&lt;code>__delete__(self, obj)&lt;/code>&lt;/li>
&lt;/ul>
&lt;p>这些方法的参数含义如下：&lt;/p>
&lt;ul>
&lt;li>&lt;code>self&lt;/code> 是当前定义的描述符对象实例。&lt;/li>
&lt;li>&lt;code>obj&lt;/code> 是该描述符将作用的对象实例。&lt;/li>
&lt;li>&lt;code>type&lt;/code> 是该描述符作用的对象的类型（即所属的类）。&lt;/li>
&lt;/ul>
&lt;p>上述方法也被称为&lt;em>描述符协议&lt;/em>，Python 会在特定的时机按协议传入参数调用某一方法，如果我们未按协议约定的参数定义方法，调用可能会出错。&lt;/p>
&lt;h2 id="描述符的作用">描述符的作用&lt;/h2>
&lt;p>&lt;strong>描述符可以用来控制对属性的访问行为，实现计算属性、懒加载属性、属性访问控制等功能&lt;/strong>，我们先来举个简单的例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">Descriptor&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__get__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">instance&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">owner&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">instance&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="bp">None&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;__get__(): Accessing x from the class&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">owner&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>
&lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;__get__(): Accessing x from the object&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">instance&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s1">&amp;#39;X from descriptor&amp;#39;&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__set__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">instance&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;__set__(): Setting x on the object&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">instance&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">instance&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__dict__&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;_x&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>
&lt;span class="k">class&lt;/span> &lt;span class="nc">Foo&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Descriptor&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在示例中我们创建了一个描述符实例，并将其赋值给 &lt;code>Foo&lt;/code> 类的 &lt;code>x&lt;/code> 属性变量。现在访问 &lt;code>Foo.x&lt;/code> ，会发现 Python 自动调用了该属性所绑定的描述符实例的 &lt;code>__get__()&lt;/code> 方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Foo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="fm">__get__&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">Accessing&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="kn">from&lt;/span> &lt;span class="nn">the&lt;/span> &lt;span class="nn">class&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="err">&amp;#39;&lt;/span>&lt;span class="nc">__main__&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Foo&lt;/span>&lt;span class="s1">&amp;#39;&amp;gt;&lt;/span>
&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">__main__&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Descriptor&lt;/span> &lt;span class="nb">object&lt;/span> &lt;span class="n">at&lt;/span> &lt;span class="mh">0x106e138e0&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来实例化一个对象 &lt;code>foo&lt;/code>，并通过 &lt;code>foo&lt;/code> 对象访问 &lt;code>x&lt;/code> 属性：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">foo&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Foo&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">foo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="fm">__get__&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">Accessing&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="kn">from&lt;/span> &lt;span class="nn">the&lt;/span> &lt;span class="nn">object&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">__main__&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Foo&lt;/span> &lt;span class="nb">object&lt;/span> &lt;span class="n">at&lt;/span> &lt;span class="mh">0x105dc9340&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="n">X&lt;/span> &lt;span class="kn">from&lt;/span> &lt;span class="nn">descriptor&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>同样执行了描述符所定义的相应方法。&lt;/p>
&lt;p>如果我们尝试对 &lt;code>foo&lt;/code> 对象的 &lt;code>x&lt;/code> 进行赋值，也会调用描述符的 &lt;code>__set__()&lt;/code> 方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">foo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="fm">__set__&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">Setting&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="n">on&lt;/span> &lt;span class="n">the&lt;/span> &lt;span class="nb">object&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">__main__&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Foo&lt;/span> &lt;span class="nb">object&lt;/span> &lt;span class="n">at&lt;/span> &lt;span class="mh">0x105dc9340&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">foo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="fm">__get__&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">Accessing&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="kn">from&lt;/span> &lt;span class="nn">the&lt;/span> &lt;span class="nn">object&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">__main__&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Foo&lt;/span> &lt;span class="nb">object&lt;/span> &lt;span class="n">at&lt;/span> &lt;span class="mh">0x105dc9340&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;span class="n">X&lt;/span> &lt;span class="kn">from&lt;/span> &lt;span class="nn">descriptor&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">foo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__dict__&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="s1">&amp;#39;_x&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>同理，如果我们在描述符中定义了 &lt;code>__delete__()&lt;/code> 方法，该方法将在执行 &lt;code>del foo.x&lt;/code> 时被调用。&lt;/p>
&lt;p>描述符在属性查找过程中会被 &lt;code>.&lt;/code> 点操作符调用，且只有在作为类变量使用时才有效。&lt;/p>
&lt;p>如果直接赋值给实例属性，描述符不会生效。&lt;/p>
&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; foo.__dict__['y'] = Descriptor()
&amp;gt;&amp;gt;&amp;gt; print(foo.y)
&amp;lt;__main__.Descriptor object at 0x100f0d130&amp;gt;
&lt;/code>&lt;/pre>&lt;p>如果用 &lt;code>some_class.__dict__[descriptor_name]&lt;/code> 的方式间接访问描述符，也不会调用描述符的协议方法，而是返回描述符实例本身。&lt;/p>
&lt;pre>&lt;code>print(Foo.__dict__['x'])
&amp;lt;__main__.Descriptor object at 0x10b66d8e0&amp;gt;
&lt;/code>&lt;/pre>&lt;h2 id="描述符的类型">描述符的类型&lt;/h2>
&lt;p>根据所实现的协议方法不同，描述符又可分为两类：&lt;/p>
&lt;ul>
&lt;li>若实现了 &lt;code>__set__()&lt;/code> 或 &lt;code>__delete__()&lt;/code> 任一方法，该描述符是一个数据描述符（&lt;code>data descriptor&lt;/code>）。&lt;/li>
&lt;li>若仅实现 &lt;code>__get__()&lt;/code> 方法，该描述符是一个非数据描述符（&lt;code>non-data descriptor&lt;/code>）。&lt;/li>
&lt;/ul>
&lt;p>两者的在表现行为上存在差异：&lt;/p>
&lt;ul>
&lt;li>数据描述符总是会覆盖实例字典 &lt;code>__dict__&lt;/code> 中的属性。&lt;/li>
&lt;li>而非数据描述可能会被实例字典 &lt;code>__dict__&lt;/code> 中定义的属性所覆盖。&lt;/li>
&lt;/ul>
&lt;p>在上面的示例中我们已经展示数据描述符的效果，接下来去掉 &lt;code>__set__()&lt;/code> 方法实现一个非数据描述符:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">NonDataDescriptor&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__get__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">instance&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">owner&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">instance&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="bp">None&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;__get__(): Accessing y from the class&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">owner&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>
&lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;__get__(): Accessing y from the object&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">instance&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s1">&amp;#39;Y from non-data descriptor&amp;#39;&lt;/span>
&lt;span class="k">class&lt;/span> &lt;span class="nc">Bar&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">y&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">NonDataDescriptor&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">bar&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Bar&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当 &lt;code>bar.__dict__&lt;/code> 不存在键为 &lt;code>y&lt;/code> 的属性时，访问 &lt;code>bar.y&lt;/code> 和 &lt;code>foo.x&lt;/code> 的行为是一致的：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">Y&lt;/span> &lt;span class="kn">from&lt;/span> &lt;span class="nn">non&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">data&lt;/span> &lt;span class="n">descriptor&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但如果我们直接修改 &lt;code>bar&lt;/code> 对象的 &lt;code>__dict__&lt;/code>，向其中添加 &lt;code>y&lt;/code> 属性，则该对象属性将覆盖在 &lt;code>Bar&lt;/code> 类中定义的 &lt;code>y&lt;/code> 描述符，访问 &lt;code>bar.y&lt;/code> 将不再调用描述符的 &lt;code>__get__()&lt;/code> 方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">bar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__dict__&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;y&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">2&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">y&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="mi">2&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>而在上文的数据描述符示例中，即使我们修改 &lt;code>foo.__dict__&lt;/code>，对 &lt;code>x&lt;/code> 属性的访问始终都由描述符所控制：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">foo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__dict__&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="s1">&amp;#39;x&amp;#39;&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="mi">1&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">foo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="fm">__get__&lt;/span>&lt;span class="p">():&lt;/span> &lt;span class="n">Accessing&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="kn">from&lt;/span> &lt;span class="nn">the&lt;/span> &lt;span class="nn">object&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">__main__&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Foo&lt;/span> &lt;span class="nb">object&lt;/span> &lt;span class="n">at&lt;/span> &lt;span class="mh">0x102b40340&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在下文中我们会介绍这两者的差异是如何实现的。&lt;/p>
&lt;h2 id="描述符的实现">描述符的实现&lt;/h2>
&lt;p>描述符控制属性访问的关键，在于从执行 &lt;code>foo.x&lt;/code> 到 &lt;code>__get()__&lt;/code> 方法被调用这中间所发生的过程。&lt;/p>
&lt;h3 id="对象属性如何保存">对象属性如何保存&lt;/h3>
&lt;p>一般来说，对象的属性保存在 &lt;code>__dict__&lt;/code> 属性中：&lt;/p>
&lt;ul>
&lt;li>根据 Python 文档介绍，&lt;code>object.__dict__&lt;/code> 是一个字典或其他的映射类型对象，用于存储一个对象的（可写）属性。&lt;/li>
&lt;li>除了一些 Python 的内置对象以外，大部分自定义的对象都会有一个 &lt;code>__dict__&lt;/code> 属性。&lt;/li>
&lt;li>这个属性包含了所有为该对象定义的属性，&lt;code>__dict__&lt;/code> 也被称为 &lt;code>mappingproxy&lt;/code> 对象。&lt;/li>
&lt;/ul>
&lt;p>我们从之前的示例继续：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">foo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__dict__&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="s1">&amp;#39;_x&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">foo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">x&lt;/span>
&lt;span class="mi">1&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当我们访问 &lt;code>foo.x&lt;/code> ，Python 是如何判断应该调用描述符方法还是从 &lt;code>__dict__&lt;/code> 中获取对应值的呢？其中起关键作用的是 &lt;code>.&lt;/code> 这个点操作符。&lt;/p>
&lt;h3 id="对象属性如何访问">对象属性如何访问&lt;/h3>
&lt;p>点操作符的查找逻辑位于 &lt;code>object.__getattribute__()&lt;/code> 方法中，每一次向对象执行点操作符都会调用对象的该方法。CPython 中该方法由 C 实现，我们来看一下它的等价 Python 版本：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">def&lt;/span> &lt;span class="nf">object_getattribute&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="s2">&amp;#34;Emulate PyObject_GenericGetAttr() in Objects/object.c&amp;#34;&lt;/span>
&lt;span class="n">null&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">object&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="n">objtype&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">cls_var&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">getattr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">objtype&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">null&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">descr_get&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">getattr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cls_var&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s1">&amp;#39;__get__&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">null&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">descr_get&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">null&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nb">hasattr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cls_var&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s1">&amp;#39;__set__&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="ow">or&lt;/span> &lt;span class="nb">hasattr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cls_var&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s1">&amp;#39;__delete__&amp;#39;&lt;/span>&lt;span class="p">)):&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">descr_get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cls_var&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">objtype&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># data descriptor&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nb">hasattr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;__dict__&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">name&lt;/span> &lt;span class="ow">in&lt;/span> &lt;span class="nb">vars&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nb">vars&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">)[&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1"># instance variable&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">descr_get&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">null&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">descr_get&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">cls_var&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">objtype&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># non-data descriptor&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">cls_var&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">null&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">cls_var&lt;/span> &lt;span class="c1"># class variable&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">AttributeError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>理解以上代码可知，当我们访问 &lt;code>object.name&lt;/code> 时会依次执行下列过程：&lt;/p>
&lt;ol>
&lt;li>首先从 &lt;code>obj&lt;/code> 所属的类 &lt;code>objtype&lt;/code> 中查找 &lt;code>name&lt;/code> 属性，如果对应的类变量 &lt;code>cls_var&lt;/code> 存在，尝试获取 &lt;code>cls_var&lt;/code> 所属的类的 &lt;code>__get__&lt;/code> 属性。&lt;/li>
&lt;li>如果 &lt;code>__get__&lt;/code> 属性存在，即说明 &lt;code>cls_var&lt;/code> （至少）是一个非数据描述符。接下来将判断该描述符是否为数据描述符（判断有无 &lt;code>__set__&lt;/code> 或 &lt;code>__delete__&lt;/code> 属性），如果是，则调用在描述符中定义的 &lt;code>__get__&lt;/code> 方法，并传入当前对象 &lt;code>obj&lt;/code> 和当前对象所属类 &lt;code>objtype&lt;/code> 作为参数，最后返回调用结果，查找结束，数据描述符完全覆盖了对对象本身 &lt;code>__dict__&lt;/code> 的访问。&lt;/li>
&lt;li>如果 &lt;code>cls_var&lt;/code> 为非数据描述符（也可能并非描述符），此时将尝试在对象的字典 &lt;code>__dict__&lt;/code> 中查找 &lt;code>name&lt;/code> 属性，若有则返回该属性对应的值。&lt;/li>
&lt;li>如果在 obj 的 &lt;code>__dict__&lt;/code> 中未找到 &lt;code>name&lt;/code> 属性，且 &lt;code>cls_var&lt;/code> 为非数据描述符，则调用在描述符中定义的 &lt;code>__get__&lt;/code> 方法，和上文一样传入相应参数并返回调用结果。&lt;/li>
&lt;li>如果 &lt;code>cls_var&lt;/code> 不是描述符，则将其直接返回。&lt;/li>
&lt;li>如果最后还没找到，唤起 &lt;code>AttributeError&lt;/code> 异常。&lt;/li>
&lt;/ol>
&lt;p>在以上过程中，当我们从 &lt;code>obj&lt;/code> 所属的类 &lt;code>objtype&lt;/code> 中获取 &lt;code>name&lt;/code> 属性时，若 &lt;code>objtype&lt;/code> 中没找到将尝试从其所继承的父类中查找，具体的顺序取决于 &lt;code>cls.__mro__&lt;/code> 类方法的返回结果：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">Foo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__mro__&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">class&lt;/span> &lt;span class="err">&amp;#39;&lt;/span>&lt;span class="nc">__main__&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">Foo&lt;/span>&lt;span class="s1">&amp;#39;&amp;gt;, &amp;lt;class &amp;#39;&lt;/span>&lt;span class="nb">object&lt;/span>&lt;span class="s1">&amp;#39;&amp;gt;)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在我们知道，&lt;strong>描述符在 &lt;code>object.__getattribute__()&lt;/code> 方法中根据不同条件被调用，这就是描述符控制属性访问的工作机制&lt;/strong>。如果我们重载 &lt;code>object.__getattribute__()&lt;/code> 方法，甚至可以取消所有的描述符调用。&lt;/p>
&lt;h3 id="__getattr__-方法">&lt;code>__getattr__&lt;/code> 方法&lt;/h3>
&lt;p>实际上，属性查找并不会直接调用 &lt;code>object.__getattribute__()&lt;/code> ，点操作符会通过一个辅助函数来执行属性查找：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">def&lt;/span> &lt;span class="nf">getattr_hook&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="s2">&amp;#34;Emulate slot_tp_getattr_hook() in Objects/typeobject.c&amp;#34;&lt;/span>
&lt;span class="k">try&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="fm">__getattribute__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">except&lt;/span> &lt;span class="ne">AttributeError&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="nb">hasattr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="s1">&amp;#39;__getattr__&amp;#39;&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">raise&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nb">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="fm">__getattr__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">name&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="c1"># __getattr__&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>因此，如果 &lt;code>obj.__getattribute__()&lt;/code> 的结果引发异常，且存在 &lt;code>obj.__getattr__()&lt;/code>方法，该方法将被执行。如果用户直接调用 &lt;code>obj.__getattribute__()&lt;/code>，&lt;code>__getattr__()&lt;/code> 的补充查找机制就会被绕过。&lt;/p>
&lt;p>假如为 &lt;code>Foo&lt;/code> 类添加该方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">Foo&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Descriptor&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__getattr__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">item&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="s1">&amp;#39;{item} is indeed not found&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="n">foo&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Foo&lt;/span>&lt;span class="p">()&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后分别调用 &lt;code>foo.z&lt;/code> 和 &lt;code>bar.z&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">foo&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">z&lt;/span>
&lt;span class="n">z&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="n">indeed&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="n">found&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">bar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">z&lt;/span>
&lt;span class="ne">AttributeError&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s1">&amp;#39;Bar&amp;#39;&lt;/span> &lt;span class="nb">object&lt;/span> &lt;span class="n">has&lt;/span> &lt;span class="n">no&lt;/span> &lt;span class="n">attribute&lt;/span> &lt;span class="s1">&amp;#39;z&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>该行为仅在对象所属的类定义了 &lt;code>__getattr__()&lt;/code>方法时才生效，在对象中定义 &lt;code>__getattr__&lt;/code> 方法，即在 &lt;code>obj.__dict__&lt;/code> 中添加该属性是无效的，这一点同样适用于 &lt;code>__getattribute__()&lt;/code> 方法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">bar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="fm">__getattr__&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">lambda&lt;/span> &lt;span class="n">item&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="s1">&amp;#39;{item} is indeed not found&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">bar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__dict__&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="s1">&amp;#39;__getattr__&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">function&lt;/span> &lt;span class="o">&amp;lt;&lt;/span>&lt;span class="k">lambda&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">at&lt;/span> &lt;span class="mh">0x1086e1430&lt;/span>&lt;span class="o">&amp;gt;&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">bar&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">z&lt;/span>
&lt;span class="ne">AttributeError&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s1">&amp;#39;Bar&amp;#39;&lt;/span> &lt;span class="nb">object&lt;/span> &lt;span class="n">has&lt;/span> &lt;span class="n">no&lt;/span> &lt;span class="n">attribute&lt;/span> &lt;span class="s1">&amp;#39;z&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="python-内部的描述符">Python 内部的描述符&lt;/h2>
&lt;p>除了一些自定义的场景，Python 本身的语言机制中就大量使用了描述符。&lt;/p>
&lt;h3 id="property">property&lt;/h3>
&lt;p>&lt;code>property&lt;/code> 的具体效果我们不再赘述，下面是其常见的语法糖用法：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">C&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">None&lt;/span>
&lt;span class="nd">@property&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">x&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;I&amp;#39;m the &amp;#39;x&amp;#39; property.&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_x&lt;/span>
&lt;span class="nd">@x.setter&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">x&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>
&lt;span class="nd">@x.deleter&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">x&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">del&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_x&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>property&lt;/code> 本身是一个实现了描述符协议的类，它还可以通过以下等价方式使用：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">C&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">None&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">getx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_x&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">setx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">value&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">delx&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">del&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">_x&lt;/span>
&lt;span class="n">x&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">property&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">getx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">setx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">delx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;I&amp;#39;m the &amp;#39;x&amp;#39; property.&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在上面例子中 &lt;code>property(getx, setx, delx, &amp;quot;I'm the 'x' property.&amp;quot;)&lt;/code> 创建了一个描述符实例，并赋值给了 &lt;code>x&lt;/code>。&lt;code>property&lt;/code> 类的实现与下面的 Python 代码等价：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">Property&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="s2">&amp;#34;Emulate PyProperty_Type() in Objects/descrobject.c&amp;#34;&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fget&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">None&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fset&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">None&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fdel&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">None&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">doc&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">None&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fget&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fget&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fset&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fset&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fdel&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fdel&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">doc&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="bp">None&lt;/span> &lt;span class="ow">and&lt;/span> &lt;span class="n">fget&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="ow">not&lt;/span> &lt;span class="bp">None&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="n">doc&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">fget&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__doc__&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__doc__&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">doc&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__get__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">objtype&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">None&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># 描述符协议方法&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">obj&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="bp">None&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fget&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="bp">None&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">AttributeError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;unreadable attribute&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fget&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__set__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># 描述符协议方法&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fset&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="bp">None&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">AttributeError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;can&amp;#39;t set attribute&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fset&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">value&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__delete__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># 描述符协议方法&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fdel&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="bp">None&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">raise&lt;/span> &lt;span class="ne">AttributeError&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s2">&amp;#34;can&amp;#39;t delete attribute&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fdel&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">getter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fget&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># 实例化一个拥有 fget 属性的描述符对象&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nb">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="n">fget&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fdel&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__doc__&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">setter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fset&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># 实例化一个拥有 fset 属性的描述符对象&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nb">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fget&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fdel&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__doc__&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">deleter&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fdel&lt;/span>&lt;span class="p">):&lt;/span> &lt;span class="c1"># 实例化一个拥有 fdel 属性的描述符对象&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nb">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">)(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fget&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">fset&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">fdel&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__doc__&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>property&lt;/code> 在描述符实例的字典内保存读、写、删除函数，然后在协议方法被调用时判断是否存在相应函数，实现对属性的读、写与删除的控制。&lt;/p>
&lt;h3 id="函数">函数&lt;/h3>
&lt;p>没错，每一个我们定义的函数对象都是一个非数据描述符实例。&lt;/p>
&lt;p>这里使用描述符的目的，是让在类定义中所定义的&lt;strong>函数&lt;/strong>在通过对象调用时成为&lt;strong>绑定方法&lt;/strong>（bound method）。&lt;/p>
&lt;p>方法在调用时会自动传入对象实例作为第一个参数，这是方法和普通函数的唯一区别。通常我们会在定义方法时，将这个形参指定为 &lt;code>self&lt;/code>。方法对象的类定义与下面的代码等价：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">MethodType&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="s2">&amp;#34;Emulate PyMethod_Type in Objects/classobject.c&amp;#34;&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">func&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__func__&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">func&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__self__&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">obj&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__call__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">kwargs&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="n">func&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__func__&lt;/span>
&lt;span class="n">obj&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__self__&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">func&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="n">args&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">**&lt;/span>&lt;span class="n">kwargs&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它在初始化方法中接收一个函数 &lt;code>func&lt;/code> 和一个对象 &lt;code>obj&lt;/code>，并在调用时将 &lt;code>obj&lt;/code> 传入 &lt;code>func&lt;/code> 中。&lt;/p>
&lt;p>我们举一个实际的例子：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="k">class&lt;/span> &lt;span class="nc">D&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="o">...&lt;/span> &lt;span class="k">def&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="o">...&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">x&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">D&lt;/span>&lt;span class="p">()&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">D&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">None&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="mi">2&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">d&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="mi">2&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>可以看到，当通过类属性调用 &lt;code>f&lt;/code> 时，其行为就是一个正常的函数，可以将任意对象作为 &lt;code>self&lt;/code> 参数传入；当通过实例属性访问 &lt;code>f&lt;/code> 时，其效果变成了绑定方法调用，因此在调用时会自动将绑定的对象作为第一个参数。
显然在通过实例访问属性时创建一个 &lt;code>MethodType&lt;/code> 对象，这正是我们可以通过描述符实现的效果。&lt;/p>
&lt;p>函数的具体实现如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">Function&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__get__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">objtype&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">None&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="s2">&amp;#34;Simulate func_descr_get() in Objects/funcobject.c&amp;#34;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="n">obj&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="bp">None&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">MethodType&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过 &lt;code>def f()&lt;/code> 定义函数时，等价于&lt;code> f = Function()&lt;/code> ，即创建一个非数据描述符实例并赋值给 &lt;code>f&lt;/code> 变量。&lt;/p>
&lt;p>当我们通过类方法访问该属性时，调用 &lt;code>__get__()&lt;/code> 方法返回了函数对象本身：&lt;/p>
&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; D.f
&amp;lt;function D.f at 0x10f1903a0&amp;gt;
&lt;/code>&lt;/pre>&lt;p>当我们通过对象实例访问该属性时， 调用 &lt;code>__get__()&lt;/code> 方法创建一个使用以上函数和对象所初始化的 &lt;code>MethodType&lt;/code> 对象：&lt;/p>
&lt;pre>&lt;code>&amp;gt;&amp;gt;&amp;gt; d.f
&amp;lt;bound method D.f of &amp;lt;__main__.D object at 0x10eb6fb50&amp;gt;&amp;gt;
&lt;/code>&lt;/pre>&lt;p>概括地说，函数作为对象有一个 &lt;code>__get__()&lt;/code> 方法，使其成为一个非数据描述符实例，这样当它们作为属性访问时就可以转换为绑定方法。非数据描述符将通过实例调用 &lt;code>obj.f(*args)&lt;/code> 转换为 &lt;code>f(obj, *args)&lt;/code>，通过类调用 &lt;code>cls.f(*args)&lt;/code> 转换成 &lt;code>f(*args)&lt;/code>。&lt;/p>
&lt;h3 id="classmethod">classmethod&lt;/h3>
&lt;p>&lt;code>classmethod&lt;/code> 是在函数描述符基础上实现的变种，其用法如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">F&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nd">@classmethod&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">cls&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="bp">cls&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="vm">__name__&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">x&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">F&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;F&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">F&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;F&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其等价 Python 实现如下，有了上面的铺垫会很容易理解：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">ClassMethod&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="s2">&amp;#34;Emulate PyClassMethod_Type() in Objects/funcobject.c&amp;#34;&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">f&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">f&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__get__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="bp">cls&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">None&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="bp">cls&lt;/span> &lt;span class="ow">is&lt;/span> &lt;span class="bp">None&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="bp">cls&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="nb">type&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nb">hasattr&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s1">&amp;#39;__get__&amp;#39;&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="fm">__get__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">cls&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">MethodType&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="bp">cls&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>@classmethod&lt;/code> 返回一个非数据描述符，实现了将通过实例调用 &lt;code>obj.f(*args)&lt;/code> 转换为 &lt;code>f(type(obj), *args)&lt;/code>，通过类调用 &lt;code>cls.f(*args)&lt;/code> 转换成 &lt;code>f(*args)&lt;/code>。&lt;/p>
&lt;h3 id="staticmethod">staticmethod&lt;/h3>
&lt;p>&lt;code>staticmethod&lt;/code> 实现的效果是，不管我们通过实例调用还是通过类调用，最终都会调用原始的函数：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">E&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="nd">@staticmethod&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">x&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">x&lt;/span> &lt;span class="o">*&lt;/span> &lt;span class="mi">10&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">E&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="mi">30&lt;/span>
&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="n">E&lt;/span>&lt;span class="p">()&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="mi">30&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其等价 Python 实现如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">class&lt;/span> &lt;span class="nc">StaticMethod&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="s2">&amp;#34;Emulate PyStaticMethod_Type() in Objects/funcobject.c&amp;#34;&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__init__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">f&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">f&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="fm">__get__&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="bp">self&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">obj&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="n">objtype&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">None&lt;/span>&lt;span class="p">):&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="bp">self&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">f&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>调用 &lt;code>__get__()&lt;/code> 方法时返回了保存在 &lt;code>__dict__&lt;/code> 中的函数对象本身，因此不会进一步触发函数的描述符行为。&lt;/p>
&lt;p>&lt;code>@staticmethod&lt;/code> 返回一个非数据描述符，实现了将通过实例调用 &lt;code>obj.f(*args)&lt;/code> 转换为 &lt;code>f(*args)&lt;/code>，通过类调用 &lt;code>cls.f(*args)&lt;/code> 也转换成 &lt;code>f(*args)&lt;/code>。&lt;/p>
&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://docs.python.org/3/howto/descriptor.html">Descriptor HowTo Guide&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.python.org/3/reference/datamodel.html#implementing-descriptors">Python Refenrence - Data model - Implementing Descriptors&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://realpython.com/python-descriptors/">Python Descriptors: An Introduction&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://blog.peterlamut.com/2018/11/04/python-attribute-lookup-explained-in-detail/">Python attribute lookup explained in detail&lt;/a>&lt;/li>
&lt;/ul></content><category scheme="https://www.waynerv.com/categories/python/" term="Python" label="Python"/></entry><entry><title type="text">自己编译一个最新版本的 Python3</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/compiling-a-latest-python/"/><id>https://www.waynerv.com/posts/compiling-a-latest-python/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2021-04-06T10:15:32+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">最近想看看 Python 3.10 的模式匹配新特性，刚好也了解了一些编译相关的基础知识，于是尝试下在平时使用的测试机上编译一份最新的 Python。 工……</summary><content type="html">&lt;p>最近想看看 Python 3.10 的模式匹配新特性，刚好也了解了一些编译相关的基础知识，于是尝试下在平时使用的测试机上编译一份最新的 Python。&lt;/p>
&lt;h2 id="工作环境">工作环境&lt;/h2>
&lt;p>测试机的操作系统是 Ubuntu 20.10，已安装有 &lt;code>gcc&lt;/code> 、&lt;code>git&lt;/code> 等基础的开发工具。经验证以下步骤同样适用于 macOS 11。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">uname -a
Linux waynerv-woqutech 5.8.0-48-generic &lt;span class="c1">#54-Ubuntu SMP Fri Mar 19 14:25:20 UTC 2021 x86_64 x86_64 x86_64 GNU/Linux&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="下载源码">下载源码&lt;/h2>
&lt;p>从 CPython 的官方仓库 &lt;a href="https://github.com/python/cpython">https://github.com/python/cpython&lt;/a> 克隆源码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git clone https://github.com/python/cpython.git
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个仓库的文件体积很大，如果克隆时遇到网络问题，可尝试使用 Gitee 的「同步 GitHub 仓库」功能。&lt;/p>
&lt;h2 id="配置">配置&lt;/h2>
&lt;p>核心的 CPython 编译器只需要一个基本的 C 编译器就可以编译，但一些扩展模块会需要开发头文件来提供一些额外的库（如压缩功能需要的&lt;code>zlib&lt;/code>库），这也是为什么我们用操作系统提供的包管理器（如&lt;code>apt&lt;/code>）安装 Python 时会需要 &lt;code>python3-dev&lt;/code> 等等一大堆依赖。&lt;/p>
&lt;p>由于我并不打算将自行编译的 Python 用于开发或生产，因此将跳过安装依赖这一步。&lt;/p>
&lt;p>首先进入我们所克隆的仓库目录：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nb">cd&lt;/span> cpython
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后需要进行配置：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">./configure --prefix&lt;span class="o">=&lt;/span>/root/build-python
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>默认情况下，后续的 &lt;code>make install&lt;/code> 命令会将编译得到的文件安装到 &lt;code>/usr/local/bin&lt;/code> 或 &lt;code>/usr/local/lib&lt;/code>，这可能会覆盖系统已有的安装文件，为了不和系统已安装的 Python 版本产生冲突，我们通过指定 &lt;code>--prefix&lt;/code> 选项将其安装到一个自定义的目录。&lt;/p>
&lt;h2 id="编译">编译&lt;/h2>
&lt;p>配置结束后运行编译：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">make -s -j &lt;span class="m">4&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>执行编译时可通过 &lt;code>-j&lt;/code> 选项指定并行的任务数量来加快速度，通常我们将其设置为编译机器的 CPU 数量，可以结合 &lt;code>nproc&lt;/code> 命令使用：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">make -s -j &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>nproc&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>-s&lt;/code> 选项意为 &lt;code>silence&lt;/code>，即不打印编译的过程日志，也可启用。&lt;/p>
&lt;p>编译的过程可能会比较耗时，成功后的输出如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">Python build finished successfully!
The necessary bits to build these optional modules were not found:
_bz2 _curses _curses_panel
_dbm _gdbm _hashlib
_lzma _sqlite3 _ssl
_tkinter _uuid readline
To find the necessary bits, look in setup.py in detect_modules&lt;span class="o">()&lt;/span> &lt;span class="k">for&lt;/span> the module&lt;span class="err">&amp;#39;&lt;/span>s name.
The following modules found by detect_modules&lt;span class="o">()&lt;/span> in setup.py, have been
built by the Makefile instead, as configured by the Setup files:
_abc &lt;span class="nb">pwd&lt;/span> &lt;span class="nb">time&lt;/span>
Could not build the ssl module!
Python requires an OpenSSL 1.0.2 or 1.1 compatible libssl with X509_VERIFY_PARAM_set1_host&lt;span class="o">()&lt;/span>.
LibreSSL 2.6.4 and earlier &lt;span class="k">do&lt;/span> not provide the necessary APIs, https://github.com/libressl-portable/portable/issues/381
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>由于我们没有安装依赖，所以提示有部分模块未找到，但不影响使用 Python 的基本功能。&lt;/p>
&lt;h2 id="安装">安装&lt;/h2>
&lt;p>编译成功后其实已经可以运行 Python 了。上述构建过程会在当前目录（非&lt;code>--prefix&lt;/code>指定的目录）生成一个名为 &lt;code>python&lt;/code> 的二进制文件（macOS 下是 &lt;code>python.exe&lt;/code>），运行它即可启动 Python 解释器：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">./python
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>它会使用当前目录中编译生成的临时文件作为资源文件，现在我们将其安装到在配置步骤中指定的目录：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">make install
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>安装过程会进行大量的资源复制，并调用 Python 解释器将使用 Python 实现的标准库编译为字节码（&lt;code>.pyc&lt;/code>），此外默认还会安装 &lt;code>setuptools&lt;/code> 和 &lt;code>pip&lt;/code> 这两个 Python 包，因此当我们安装较新版本的 Python 版本时，基本不再需要手动安装 &lt;code>pip&lt;/code>。&lt;/p>
&lt;p>安装完成后切换到 &lt;code>/root/build-python&lt;/code> 目录下，并查看其目录结构：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="nb">cd&lt;/span> /root/build-python
tree -L &lt;span class="m">2&lt;/span> .
.
├── bin
│   ├── 2to3 -&amp;gt; 2to3-3.10
│   ├── 2to3-3.10
│   ├── idle3 -&amp;gt; idle3.10
│   ├── idle3.10
│   ├── pip3
│   ├── pip3.10
│   ├── pydoc3 -&amp;gt; pydoc3.10
│   ├── pydoc3.10
│   ├── python3 -&amp;gt; python3.10
│   ├── python3.10 &lt;span class="c1"># Python 可执行文件&lt;/span>
│   ├── python3.10-config
│   └── python3-config -&amp;gt; python3.10-config
├── include
│   └── python3.10 &lt;span class="c1"># 头文件目录&lt;/span>
├── lib
│   ├── libpython3.10.a &lt;span class="c1"># 静态库文件&lt;/span>
│   ├── pkgconfig
│   └── python3.10 &lt;span class="c1"># 标准库文件及 site-packages&lt;/span>
└── share
└── man
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在执行 &lt;code>./bin/python3&lt;/code> 即可运行我们自己编译安装好的 Python：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">Python 3.10.0a6+ &lt;span class="o">(&lt;/span>heads/master:80017752ba, Apr &lt;span class="m">6&lt;/span> 2021, 13:47:23&lt;span class="o">)&lt;/span> &lt;span class="o">[&lt;/span>GCC 10.2.0&lt;span class="o">]&lt;/span> on linux
Type &lt;span class="s2">&amp;#34;help&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;copyright&amp;#34;&lt;/span>, &lt;span class="s2">&amp;#34;credits&amp;#34;&lt;/span> or &lt;span class="s2">&amp;#34;license&amp;#34;&lt;/span> &lt;span class="k">for&lt;/span> more information.
&amp;gt;&amp;gt;&amp;gt;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>大功告成！可以看到运行的 Python 版本是 &lt;code>3.10.0a6+&lt;/code>，一个尚未发布的开发中版本。&lt;/p>
&lt;p>如果我们需要其他稳定版本的 Python，只需要在源码仓库中 &lt;code>git checkout&lt;/code> 到指定的 release 标签，然后再重新运行配置-编译-安装 3 个步骤就可以了。&lt;/p>
&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://devguide.python.org/setup/#getting-started">Python Developer’s Guide: Getting Started&lt;/a>&lt;/li>
&lt;/ul></content><category scheme="https://www.waynerv.com/categories/python/" term="Python" label="Python"/><category scheme="https://www.waynerv.com/tags/%E7%BC%96%E8%AF%91/" term="编译" label="编译"/></entry><entry><title type="text">[CSAPP] 计算机的浮点数表示</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/csapp-ieee-floating-intro/"/><id>https://www.waynerv.com/posts/csapp-ieee-floating-intro/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2021-03-29T22:48:53+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">如果你曾经使用过 Python 或者 JavaScript 进行浮点数计算，可能会遇到类似下面的情况： 1 2 &amp;gt;&amp;gt;&amp;gt; 0.1 + 0.2 0.30000000000000004 其原因是程序在运行时，所使用的浮点数类型并没有精……</summary><content type="html">&lt;p>如果你曾经使用过 Python 或者 JavaScript 进行浮点数计算，可能会遇到类似下面的情况：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span class="mf">0.1&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mf">0.2&lt;/span>
&lt;span class="mf">0.30000000000000004&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>其原因是程序在运行时，所使用的浮点数类型并没有精确地表示 &lt;code>0.1&lt;/code> 和 &lt;code>0.2&lt;/code> ，自然结果也就不等于 &lt;code>0.3&lt;/code>。借着这个问题，我们来了解一下计算机在底层是如何表示这类浮点数的。&lt;/p>
&lt;h2 id="计算机无法精确地表示所有实数">计算机无法精确地表示所有实数&lt;/h2>
&lt;p>这是一个需要明确的前提。&lt;/p>
&lt;p>我们若想精确的表示某个集合中的每个元素，必须满足一个条件：每个元素都有一种与其他元素不同的表示。计算机通过多个位的 0 和 1 来表示信息，而实数是无限的，计算机的硬件资源却是有限的，这就注定了计算机无法精确地表示所有实数。最优解是我们可以找到一种合适的表示方法，利用有限的硬件资源（尽可能短的位数），尽可能精确地表示尽可能大的数值范围。&lt;/p>
&lt;h2 id="二进制小数">二进制小数&lt;/h2>
&lt;p>那么我们如何用二进制来表示小数呢？&lt;/p>
&lt;p>首先考虑十进制是如何用小数点来表示小数的：$d_md_{m−1}...d_1d_0.d_{−1}d_{−2}...d_{−n}$，每一位的值 $d_i$ 取值范围是 0-9，上述表示所代表的数值 $d$ 为：&lt;/p>
&lt;p>$d = \displaystyle\sum_{{ i = -n}}^m 10^i × d_i$&lt;/p>
&lt;p>小数点左边第 m 位（从 0 开始）具有 $10^m$ 的加权，右边第 n 位（从 1 开始）具有 $10^{-n}$ 的加权。举例来说 $12.34_{10}$ 即代表 $1×10^1+2×10^0+3×10_{−1}+4×10_{−2}=12\frac{34}{100}$ 。&lt;/p>
&lt;p>同样地，对二进制表示：$b_mb_{m−1}...b_1b_0.b_{−1}b_{−2}...b_{−n}$，每一位的值 $b_i$ 的取值范围是 0-1，所代表的数值 $b$ 为：&lt;/p>
&lt;p>$b = \displaystyle\sum_{{ i = -n}}^m 2^i × b_i$&lt;/p>
&lt;p>小数点左边第 m 位（从 0 开始）具有 $2^m$ 的加权，右边第 n 位（从 1 开始）具有 $2^{-n}$ 的加权。举例来说 $101.11_{2}$ 即代表 $1×2^2+0×2^1+1×2^0+1×2_{−1}+1×2_{−2}=5\frac{3}{4}$ 。&lt;/p>
&lt;p>如同十进制小数点左移除以 10，右移乘以 10 的规则，二进制小数点也有左移除以 2，右移乘以 2 的规则。由于计算机只能进行有限位数的编码，因此从上述 b 的求值公式可知，这种方法只能精确的表示能够写作 $x × 2^y$ 的值。&lt;/p>
&lt;h2 id="ieee-754-浮点数">IEEE 754 浮点数&lt;/h2>
&lt;p>用 $b_mb_{m−1}...b_1b_0.b_{−1}b_{−2}...b_{−n}$ 这种方式来表示很小的数或者很大的数是非常低效的，比如表示 $5 × 2^{500}$ 就需要至少 100 位。因此我们需要一种更聪明的表示方式，既然二进制能够表示的数可以归纳为 $x × 2^y$，我们可以仅表示 $x$ 和 $y$。&lt;/p>
&lt;p>IEEE 754 浮点数标准是如今最流行和通用的浮点数表示标准。它用 $V = (−1)^s × M × 2^E$ 的形式来表示一个数字：&lt;/p>
&lt;ul>
&lt;li>符号位 $s$ 决定该数字是正数（$s=0$）还是负数（$s=1$）。数值 0 是一种特殊的情况，我们会在之后解释。&lt;/li>
&lt;li>有效数 $M$ 是一个二进制小数，它的取值范围为 1 和无限趋近于 2 之间，或者为 0 和无限趋近于 1 之间。具体处于哪个取值范围由指数部分的比特位是否全部为 0 来决定。&lt;/li>
&lt;li>指数 $E$ 可能为正数也可能为负数，通过 2 的指数幂对最终表示的浮点数进行加权。&lt;/li>
&lt;/ul>
&lt;p>&lt;img src="https://www.waynerv.com/images/2021-03-30-floating-fields.png" alt="">&lt;/p>
&lt;p>下面我们来看看 IEEE 浮点数是如何在计算机中工作的。IEEE 浮点数在计算机中最常见的实际表示分别是 32 位（单精度）和 64 位（双精度），其包含的比特位可以划分为 3 部分（如上图）：&lt;/p>
&lt;ul>
&lt;li>最左边的单个比特位 s 代表符号位 $s$ 的值。&lt;/li>
&lt;li>由 k 个比特位构成的指数部分 &lt;strong>exp&lt;/strong> $= e_{k-1}...e_1e_0$ 对指数 $E$ 进行编码。&lt;/li>
&lt;li>由 n 个比特位构成的小数部分 &lt;strong>frac&lt;/strong> $= f_{n-1}...f_1f_0$ 对有效数 $M$ 进行编码。&lt;/li>
&lt;/ul>
&lt;p>在单精度浮点数表示中，s 为 1 位，指数部分为 8 位（k=8），小数部分为 23 位（n=23），总共 32 位。&lt;/p>
&lt;p>在双精度浮点数表示中，s 为 1 位，指数部分为 11 位（k=11），小数部分为 52 位（n=52），总共 64 位。&lt;/p>
&lt;p>取决于指数部分的比特位的值，通过以上表示编码得到的值可分为下面 3 种情况。&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2021-03-30-floating-3-cases.png" alt="">&lt;/p>
&lt;h3 id="规范化的值normalized">规范化的值（Normalized）&lt;/h3>
&lt;p>规范化的值是最常见的情况，发生在当指数（exp）部分的比特位既非全部都是 0，也非全部都是 1 时，即其整数表示 $0 &amp;lt; exp &amp;lt; 255$ 时。&lt;/p>
&lt;p>这时指数部分会被解释为一个偏置形式的有符号整数 $E$，计算方式为 $E = e - Bias$，其中 $e$ 是由指数部分所有比特位 $e_{k-1}...e_1e_0$ 表示的有符号整数，而 $Bias$ 是一个取决于指数部分比特位长度 k 的常数 $2^{k-1}-1$（单精度浮点数为 127， 双精度浮点数为 1023），因此指数 $E$ 的取值范围为 -126 到 127（单精度浮点数）或者 -1022 到 1023（双精度浮点数）。&lt;/p>
&lt;p>小数部分会被解释为一个小数值 $f$，$f$ 的取值范围为 $0 &amp;lt;= f &amp;lt; 1$，其二进制表示为 $0.f_{n-1}...f_1f_0$。我们默认其小数点位于最左边，小数部分的比特位均表示小数点右边的值。而有效数 $M = 1 + f$，此时 $M$ 可看作二进制表示为 $1.f_{n-1}...f_1f_0$，其取值范围为 $1 &amp;lt;= M &amp;lt; 2$。这里的一个技巧是，我们对小数点左边的一位取固定值（0 或 1），因此不需要用比特位显式地去表示它，从而多争取到了一个比特位来表示小数部分，进一步扩大了小数部分的表示范围和精度。&lt;/p>
&lt;h3 id="非规范化的值denormalized">非规范化的值（Denormalized）&lt;/h3>
&lt;p>当 exp 部分的比特位全部都是 0 时，我们称此时浮点数表示的数值形式为非规范化的值。&lt;/p>
&lt;p>这种情况下，指数 $E = 1 - Bias$，$E$ 成为了一个常数，单精度格式下为 -126，双精度格式下为 -1022；有效数 $M = f$，即不再隐式地在最左边添加一个值为 1 的比特位，其取值范围也变为 $0 &amp;lt;= M &amp;lt; 1$。&lt;/p>
&lt;p>非规范化表示有两个目的：&lt;/p>
&lt;ul>
&lt;li>一是为了表示 0，由于规范化值中 $1 &amp;lt;= M &amp;lt; 2$，因此不管指数部分取什么值，所表示的数字 $V$ 都不可能为 0。而在非规范化值中 $0 &amp;lt;= M &amp;lt; 1$，当 M 的值为 0 时，所表示的数字 $V$ 也为 0，此时指数部分和小数部分的所有比特位均为 0。在 IEEE 标准中，取决于此时符号位 $s$ 的值，0 也有正负符号。当 $s=0$ 时，用来表示该浮点数的所有比特位全部为 0， $V = +0.0$；当 $s=1$ 时，$V = -0.0$。在 IEEE 标准中， +0.0 和 -0.0 在某些场景下是不同的。&lt;/li>
&lt;li>二是为了表示非常趋近于 0 的数。相比规范化值，非规范化表示能够表示更加接近于 0 的数字，且在表示的值非常趋近于 0 时，这些值的分布能保持相对均匀，这种能力也叫「渐进下溢」。&lt;/li>
&lt;/ul>
&lt;h3 id="特殊值special">特殊值（Special）&lt;/h3>
&lt;p>最后一种情况是当 exp 部分的比特位全部都是 1 时。&lt;/p>
&lt;p>若小数部分的比特位也全部是 0，其表示的值 $V$ 代表无限大：当 $s=0$ 时， $v = + ∞$；当 $s=1$ 时， $V = -∞$。无限大可以用来表示将会溢出的计算结果，如将两个极大的数相乘，或者除以0时。&lt;/p>
&lt;p>若小数部分的比特位不全为 0，其表示的值 $V$ 代表 &lt;code>NaN&lt;/code>（&lt;strong>N&lt;/strong>ot &lt;strong>a&lt;/strong> &lt;strong>N&lt;/strong>umber）。这种值通常用来作为某些计算结果不是真实数字或者无限大的操作的返回值，如 $\sqrt{-1}$ 或者 $∞ - ∞$。在某些应用中还会用来表示尚未初始化的数据。&lt;/p>
&lt;h3 id="示例">示例&lt;/h3>
&lt;p>我们假定一个 8 位的浮点数表示作为示例，其指数部分长度为 4，小数部分长度为 3，偏置值为 7，即 $k=4$，$n=3$，$Bias=7$。其指数（Exponent）以及小数（Fraction）等各个部分的值以及所表示的十进制值如下图：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2021-03-30-floating-examples.png" alt="">&lt;/p>
&lt;p>从中我们可以发现 IEEE 浮点数的一些规律：&lt;/p>
&lt;ol>
&lt;li>虽然使用了不同的计算方式，但非规范化值可以平滑地过渡到规范化值，如上最大的非规范化值为 $\frac{7}{512}$，而最小的规范化值为 $\frac{8}{512}$。&lt;/li>
&lt;li>随着浮点数的递增，其比特位表示所解释地无符号整数也随之递增，因此我们可以用相对简单的无符号整数的排序规则来对浮点数进行排序，这并非巧合，而是有意设计的。&lt;/li>
&lt;/ol></content><category scheme="https://www.waynerv.com/categories/%E7%AC%94%E8%AE%B0%E6%80%BB%E7%BB%93/" term="笔记总结" label="笔记总结"/><category scheme="https://www.waynerv.com/tags/csapp/" term="CSAPP" label="CSAPP"/></entry><entry><title type="text">Git cherry-pick 操作浅析</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/git-cherry-pick-intro/"/><id>https://www.waynerv.com/posts/git-cherry-pick-intro/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2021-01-26T16:49:50+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">在前面几篇讲解 Git 进阶用法的文章中，我们已经了解了 Git 的工作原理，以及 rebase，merge，checkout， reset 等多种操作的使用……</summary><content type="html">&lt;p>在前面几篇讲解 Git 进阶用法的文章中，我们已经了解了 Git 的工作原理，以及 &lt;code>rebase&lt;/code>，&lt;code>merge&lt;/code>，&lt;code>checkout&lt;/code>， &lt;code>reset&lt;/code> 等多种操作的使用场景和用法，基本上在使用 Git 时你已经可以无所畏惧了，你可以自如的修改提交历史，并保证不会丢失任何更改。今天我们来补上最后一环，了解使用场景不多但却能达到奇效的 &lt;code>cherry-pick&lt;/code> 命令。&lt;/p>
&lt;h2 id="基本用法">基本用法&lt;/h2>
&lt;p>Git 命令文档的描述不一定直观易懂，但绝对准确，文档对 &lt;code>git cherry-pick&lt;/code> 描述是： &lt;code>Apply the changes introduced by some existing commits&lt;/code>，即应用某些已有提交所引入的更改。通常我们会说 &lt;code>cherry-pick&lt;/code> 是将某个（些）提交从一个分支移动到另一个分支，这种说法更加容易理解，但后面我们会解释为何文档的描述才是最准确的。&lt;/p>
&lt;p>假设我们有如下提交：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-jsx" data-lang="jsx">&lt;span class="nx">a&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">b&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">c&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">d&lt;/span> &lt;span class="nx">master&lt;/span>
&lt;span class="o">\&lt;/span>
&lt;span class="nx">e&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">f&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">g&lt;/span> &lt;span class="nx">feature&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在我们想把 &lt;code>e&lt;/code> 和 &lt;code>f&lt;/code> 两个提交移动到 &lt;code>master&lt;/code> 分支，首先需要切换到 &lt;code>master&lt;/code> :&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git checkout master
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>cherry-pick&lt;/code> 命令的用法简单明了，对需要移动的一个或多个提交执行 &lt;code>cherry-pick&lt;/code> 即可，注意这里我们用字母指代实际的提交 &lt;code>SHA-1&lt;/code> ID：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git checkout f g
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>执行后的提交历史如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-jsx" data-lang="jsx">&lt;span class="nx">a&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">b&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">c&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">d&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">f&lt;/span>&lt;span class="s1">&amp;#39; - g&amp;#39;&lt;/span> &lt;span class="nx">master&lt;/span>
&lt;span class="o">\&lt;/span>
&lt;span class="nx">e&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">f&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="nx">g&lt;/span> &lt;span class="nx">feature&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>实际的结果是在 &lt;code>master&lt;/code> 分支创建了 &lt;code>f'&lt;/code> 和 &lt;code>g'&lt;/code> 两个新的提交，它们拥有和 &lt;code>f&lt;/code> 、&lt;code>g&lt;/code> 不同的 ID 。&lt;/p>
&lt;h2 id="使用场景">使用场景&lt;/h2>
&lt;p>从上面的命令解释来看，&lt;code>cherry-pick&lt;/code> 实现的效果比较简单，而且和 &lt;code>merge&lt;/code>、&lt;code>rebase&lt;/code> 看上去有所重合，下面我们来看看 &lt;code>cherry-pick&lt;/code> 的实际使用场景。&lt;/p>
&lt;h3 id="紧急-bug-修复">紧急 bug 修复&lt;/h3>
&lt;p>通常在一个产品的 Git 工作流中，会有至少一个发布分支和开发主分支。当发现一个 bug 时，我们需要尽快向已发布的产品提供修复补丁，同时也要将补丁整合到开发主分支中。&lt;/p>
&lt;p>举个例子，比如我们发布了一个版本并已经开始开发一些新的功能，在新功能开发过程中，又发现了一个已经存在的 bug。我们创建了一个紧急修复提交对这个错误进行修复，并在开发主分支进行集成测试。这个新的补丁提交在合入开发主分支后可以直接 &lt;code>cherry-pick&lt;/code> 到发布分支，在影响更多用户之前修复这个 bug。过程示意如下：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/Jan-26-2021-git-cherry-pick.gif" alt="Jan-26-2021-git-cherry-pick">&lt;/p>
&lt;p>在上面的动图中，我们在开发主分支 &lt;code>master&lt;/code> 添加了一些新的功能提交，修复了一些 bug 并合入了两个 &lt;code>bugfix&lt;/code> 分支，然后又将 &lt;code>bugfix&lt;/code> 分支中的所有提交 &lt;code>cherry-pick&lt;/code> 到了 &lt;code>release&lt;/code> 分支。在有些 Git 工作流中情况会有所不同，可能会基于 &lt;code>release&lt;/code> 分支创建 &lt;code>bugfix&lt;/code> 分支，并在合入 &lt;code>release&lt;/code> 后 &lt;code>cherry-pick&lt;/code> 这些提交到 &lt;code>master&lt;/code>。&lt;/p>
&lt;h3 id="从放弃的分支中挑出个别提交">从放弃的分支中挑出个别提交&lt;/h3>
&lt;p>有时因为需求的变化一个功能分支可能会过时，而不会被合并到主分支中。有时，一个 &lt;code>Pull Request&lt;/code> 可能会在没有合并的情况下被关闭。我们可以通过 &lt;code>git log&lt;/code> 和 &lt;code>git reflog&lt;/code> 等命令，从中找出一些有用的提交，并把它们 &lt;code>cherry-pick&lt;/code> 到主分支。&lt;/p>
&lt;h3 id="其他场景">其他场景&lt;/h3>
&lt;p>还有一些其他的使用场景，比如你在没有意识到的情况下在一个错误的分支上创建了一个提交，你可以使用 &lt;code>cherry-pick&lt;/code> 将其移动到正确的分支上去；或者出于某些原因你想将团队成员在另一个分支开发的某个提交拿到你自己的分支，诸如此类。&lt;/p>
&lt;p>从以上有限的场景来看，我们使用 &lt;code>rebase&lt;/code> 或者 &lt;code>merge&lt;/code> 配合 &lt;code>reset&lt;/code> 等命令也能实现同样的效果，但是 &lt;code>cherry-pick&lt;/code> 的优势在于它足够地简单直接，一条命令就能实现原本需要一系列命令来实现的操作。但我们依然需要谨慎的使用 &lt;code>cherry-pick&lt;/code> ，并意识到它的一些危险之处。&lt;/p>
&lt;h2 id="深入理解-cherry-pick">深入理解 &lt;code>cherry-pick&lt;/code>&lt;/h2>
&lt;p>假设我们有一个刚刚通过提交 A 添加了 &lt;code>main.py&lt;/code> 的代码仓库，&lt;code>main.py&lt;/code> 的文件内容如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">if&lt;/span> &lt;span class="vm">__name__&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;__main__&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Hello world&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在我们创建一个新的 &lt;code>new-feature&lt;/code> 分支进行后续的修改：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git checkout -b new-feature
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先创建一个提交 B，加入一个新的文件 &lt;code>setup.py&lt;/code> 并对 &lt;code>main.py&lt;/code> 做如下修改：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">if&lt;/span> &lt;span class="vm">__name__&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;__main__&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Hello world&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Git is easy&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接着我们又创建了一个提交 C，加入一个新的文件 &lt;code>README.md&lt;/code> 并继续对 &lt;code>main.py&lt;/code> 添加一行代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="k">if&lt;/span> &lt;span class="vm">__name__&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;__main__&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Hello world&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;Git is easy&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">print&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="s1">&amp;#39;But sometimes it can be difficult&amp;#39;&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后我们再切换回一开始的 &lt;code>master&lt;/code> ，并对 &lt;code>new-feature&lt;/code> 的最新提交 C 执行 &lt;code>cherry-pick&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git checkout master
$ git cherry-pick new-feature
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>执行过程很简单，如下示意：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/Jan-26-2021-git-cherry-pick2.gif" alt="Jan-26-2021-git-cherry-pick2">&lt;/p>
&lt;p>但现在我们来猜一猜，现在的 &lt;code>master&lt;/code> 有几个文件？ &lt;code>main.py&lt;/code> 会有几行 &lt;code>print&lt;/code> 语句？&lt;/p>
&lt;p>正确的答案是：我们会遭遇合并冲突 😝。在解决冲突后，我们会拥有一个修改过的 &lt;code>main.py&lt;/code> 文件，以及在提交 C 中新添加的 &lt;code>README.md&lt;/code> 文件。&lt;/p>
&lt;p>为什么结果会是这样？借此示例，我们来深入探究一番 &lt;code>cherry-pick&lt;/code> 实际的执行过程。&lt;/p>
&lt;h3 id="应用哪些更改">应用哪些更改&lt;/h3>
&lt;p>在 &lt;a href="https://www.waynerv.com/posts/git-undo-intro/#%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">Git 撤销操作浅析&lt;/a>中我们了解到每一个提交都是一份完整的文件快照，但从示例来看，&lt;code>cherry-pick&lt;/code> 的过程显然并没有应用目标提交中的所有文件内容（否则当前 &lt;code>master&lt;/code> 将包含在提交 B 中加入的 &lt;code>setup.py&lt;/code> 文件），而是仅仅影响了目标提交中更改过的文件（ &lt;code>README.md&lt;/code> 和 &lt;code>main.py&lt;/code> ）。由此可见，「将某个提交从一个分支移动到另一个分支」这一说法并不准确， &lt;code>cherry-pick&lt;/code> 只会应用在目标提交中引入的更改，即在该提交中更改过的文件。&lt;/p>
&lt;h3 id="如何应用">如何应用&lt;/h3>
&lt;p>在确定了 &lt;code>cherry-pick&lt;/code> 只会应用目标提交中更改过的文件后，我们来看下应用更改的具体过程。「应用」在内部其实就是像 &lt;code>merge&lt;/code> 一样执行了一次三路合并。关于 Git 的三路合并算法我们在 &lt;a href="https://www.waynerv.com/posts/git-merge-intro/#%E9%80%92%E5%BD%92%E4%B8%89%E8%B7%AF%E5%90%88%E5%B9%B6%E7%AE%97%E6%B3%95">Git 合并操作浅析&lt;/a>中已有详细介绍。这次我们换一种方式来表示三路合并中的各方，当我们执行 &lt;code>git cherry-pick &amp;lt;commit C&amp;gt;&lt;/code> 时：&lt;/p>
&lt;ol>
&lt;li>&lt;strong>LOCAL&lt;/strong>：在该提交基础上执行合并（即当前所在分支的 HEAD）。&lt;/li>
&lt;li>&lt;strong>REMOTE&lt;/strong>：你正在 &lt;code>cherry-pick&lt;/code> 的目标提交（即 &lt;code>&amp;lt;commit C&amp;gt;&lt;/code>）。&lt;/li>
&lt;li>&lt;strong>BASE&lt;/strong>：你要 &lt;code>cherry-pick&lt;/code> 的提交的父提交（即 C^，C 的上一次提交），通常为 LOCAL 和 REMOTE 的共同祖先提交（但也可能不是，比如在本示例中）。&lt;/li>
&lt;/ol>
&lt;p>执行 &lt;code>cherry-pick&lt;/code> 时，就是以 BASE 作为基础，以 LOCAL 和 REMOTE 作为要合并的内容进行三路合并，并将合并的结果作为一个新的提交添加到 LOCAL 之后（算法执行的具体过程不再赘述）。我们可以通过如下方式进行验证：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先将示例仓库 Git 的 &lt;code>merge.conflictstyle&lt;/code> 更改为 &lt;code>diff3&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git config merge.conflictstyle diff3
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>然后重新执行上面的示例步骤，并查看发生合并冲突的 &lt;code>main.py&lt;/code> 的文件内容：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="k">if&lt;/span> &lt;span class="nv">__name__&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="s1">&amp;#39;__main__&amp;#39;&lt;/span>:
print&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;Hello world&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="o">&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/span>&amp;lt; HEAD
&lt;span class="o">||||||&lt;/span>&lt;span class="p">|&lt;/span> parent of 77b3860 &lt;span class="o">(&lt;/span>C&lt;span class="o">)&lt;/span>
print&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;Git is easy&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="o">=======&lt;/span>
print&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;Git is easy&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
print&lt;span class="o">(&lt;/span>&lt;span class="s1">&amp;#39;But sometimes it can be difficult&amp;#39;&lt;/span>&lt;span class="o">)&lt;/span>
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; 77b3860 &lt;span class="o">(&lt;/span>C&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>相比常规的 &lt;code>diff&lt;/code> 展示的 LOCAL 和 REMOTE 两方对比，&lt;code>diff3&lt;/code> 会通过 &lt;code>|||||||&lt;/code> 多展示一方来自 BASE 的内容。从结果中我们可以确认，BASE 正是提交 C 的父提交（即提交 B）。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="处理冲突">处理冲突&lt;/h3>
&lt;p>&lt;code>cherry-pick&lt;/code> 出现冲突时的处理方式与 &lt;code>rebase&lt;/code> 和 &lt;code>merge&lt;/code> 一致，我们通过 &lt;code>git status&lt;/code> 查看发生冲突的文件，修改这些文件并删除其中的特殊标记，通过 &lt;code>git add&lt;/code> 将其标记为冲突已解决，最后 &lt;code>git commit&lt;/code> 提交更改。&lt;/p>
&lt;p>在解决冲突过程中，我们还可以在解决所有冲突后执行 &lt;code>git cherry-pick --continue&lt;/code> 提交所有内容，使用 &lt;code>git cherry-pick --skip&lt;/code> 在处理多个提交时跳过此提交，或使用 &lt;code>git cherry-pick --abort&lt;/code> 取消 &lt;code>cherry-pick&lt;/code> 操作，恢复到执行操作之前的状态。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>&lt;code>git cherry-pick&lt;/code> 的用途并不广泛，在一些特定场景会很有用，但由于其合并机制有引入意想不到的文件更改的风险，在使用时我们应该谨慎考虑可能发生的结果。&lt;/p>
&lt;p>&lt;code>cherry-pick&lt;/code> 还有两个容易产生的误解需要澄清：&lt;/p>
&lt;ul>
&lt;li>&lt;code>cherry-pick&lt;/code> 并不会应用提交所代表的整个文件快照，而是只会影响该在提交中新增、删除或更改的文件。&lt;/li>
&lt;li>&lt;code>cherry-pick&lt;/code> 并不是简单的应用目标提交与其父提交的 &lt;code>diff&lt;/code> 内容，而是会在内部以该父提交作为基础在当前分支指向提交和目标提交之间进行一次三路合并，因此有可能发生合并冲突。&lt;/li>
&lt;/ul>
&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://git-scm.com/docs/git-cherry-pick">git-cherry-pick-documentation&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.atlassian.com/git/tutorials/cherry-pick">Git Cherry Pick Tutorial&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://think-like-a-git.net/sections/rebase-from-the-ground-up/cherry-picking-explained.html">CHERRY-PICKING EXPLAINED&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/a/52932137/10224392">what does git cherry-pick {commit-hash} do?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/a/10058070/10224392">In a Git cherry-pick or rebase merge conflict, how are BASE (aka “the ancestor”), LOCAL, and REMOTE determined?&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://stackoverflow.com/questions/27417656/should-diff3-be-default-conflictstyle-on-git">Should diff3 be default conflictstyle on git?&lt;/a>&lt;/li>
&lt;/ul></content><category scheme="https://www.waynerv.com/categories/%E5%B7%A5%E5%85%B7/" term="工具" label="工具"/><category scheme="https://www.waynerv.com/tags/git/" term="Git" label="Git"/></entry><entry><title type="text">Git 撤销操作浅析</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/git-undo-intro/"/><id>https://www.waynerv.com/posts/git-undo-intro/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2021-01-09T12:53:49+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">「怎样撤销 Git 提交」是绝大部分程序员一定搜索过的问题，就算你可以用某个答案中的命令暂时过关，再次遇到类似问题时又可能一头雾水：为什……</summary><content type="html">&lt;p>「怎样撤销 Git 提交」是绝大部分程序员一定搜索过的问题，就算你可以用某个答案中的命令暂时过关，再次遇到类似问题时又可能一头雾水：为什么这次搜到的命令不一样？&lt;code>git checkout&lt;/code>、&lt;code>git reset&lt;/code>、&lt;code>git revert&lt;/code> 这些命令我到底该用哪个？&lt;/p>
&lt;p>之所以这样，是因为你的需求并不能简单地描述为「撤销」某次提交，而可能是：&lt;/p>
&lt;ul>
&lt;li>我在本地修改了一些文件还未提交，但我想放弃某些文件的更改。&lt;/li>
&lt;li>我不小心 &lt;code>git add&lt;/code> 了错误的文件，现在我不想把它和其他文件一起提交了。&lt;/li>
&lt;li>我刚刚执行的提交添加了不该提交的文件，我想取消这次提交，但保留（或不保留）对本地文件所作的修改。&lt;/li>
&lt;li>我不小心在一个提交中引入了 Bug 并且还推送到了远程分支，现在想回滚到原来的状态。&lt;/li>
&lt;/ul>
&lt;p>对于各种复杂的情形，Git 都提供了对应的方案来解决，但由于命令很多且同一命令还有很多选项，想要记住它们不是一件容易的事情。以 &lt;code>reset&lt;/code> 、 &lt;code>checkout&lt;/code> 为例，在添加不同选项并对不同参数执行后，就能实现 6 种不同但又很常用的效果。&lt;/p>
&lt;p>对于复杂的问题，我们应该尝试去了解其背后的本质。带着这种想法，我们来看看执行这些操作时究竟发生了什么，希望你在阅读本文后，能够对 Git 的撤销操作运用自如，解决大部分与撤销相关的实际问题（实际上本文还非系统地介绍了 Git 的内部对象和工作原理）。&lt;/p>
&lt;h2 id="git-中的撤销">Git 中的撤销&lt;/h2>
&lt;p>首先需要明确的是，Git 中并没有真正意义上传统文本处理软件都会提供的 &lt;code>undo&lt;/code> （撤销）功能，Git 本身也不是一个文本处理软件，它是一个内容寻址文件系统，你所提交的更改都会被保存到系统中。虽然不能 &lt;code>undo&lt;/code> ，但它就像时光机一样，可以将保存的文件恢复到过去的某个状态。&lt;/p>
&lt;p>然而，Git 同时管理着三颗不同的「树」的状态，当我们讨论「撤销」这个操作时，除了选择需要恢复到的时间点，还需要明确想更改哪几颗树。&lt;/p>
&lt;p>取决于你想操作的树，你需要用到 &lt;code>checkout&lt;/code> 、&lt;code>reset&lt;/code>、&lt;code>revert&lt;/code> 等不同的命令。因此在了解具体的命令之前，我们先来认识一下这三棵树。&lt;/p>
&lt;h2 id="git-的三棵树">Git 的三棵树&lt;/h2>
&lt;p>这三棵树分别是：&lt;/p>
&lt;ul>
&lt;li>工作区（Working Directory）&lt;/li>
&lt;li>暂存区（Staging Index）&lt;/li>
&lt;li>提交历史（Commit History）&lt;/li>
&lt;/ul>
&lt;p>虽然我们用树来形容它们，但需要先明确的一点是，树并不代表它们真实的数据结构。「树」在这里的实际意思是「文件的集合」，而不是指特定的数据结构。在文中我们不会去深入探究它们的底层实现，而是重点了解它们的概念及相互关系。&lt;/p>
&lt;h3 id="工作区">工作区&lt;/h3>
&lt;p>工作区即存放当前操作文件的本地文件系统目录。&lt;/p>
&lt;p>我们可以把它当成一个沙盒，在其中随意地添加或编辑文件，然后再将修改后的文件添加到暂存区并记录到提交历史中。&lt;/p>
&lt;p>Git 可以把工作区中的文件处理、压缩成一个提交对象（稍后会解释这一概念），也能将取得的提交对象解包成文件同步到工作区中。&lt;/p>
&lt;h3 id="暂存区">暂存区&lt;/h3>
&lt;p>暂存区保存着下一次执行 &lt;code>git commit&lt;/code> 时将加入到提交历史中的内容。&lt;/p>
&lt;p>Git 把它作为工作区与提交历史之间的中间区域，方便我们对提交内容进行组织：我们可能会在工作区同时更改多个完全不相干的文件，这时可以将它们分别放入暂存区，并在不同的提交中加入提交历史。此外暂存区还用于合并冲突时存放文件的不同版本。&lt;/p>
&lt;p>除非是一个刚刚初始化的 Git 仓库，否则暂存区并不是空的，它会填充最近一次提交所对应的文件快照，因此当我们基于最近一次提交在工作区做了一些修改之后，&lt;code>git status&lt;/code> 会将工作区的文件与暂存区的文件快照进行对比， 并提示我们有哪些做了修改的文件尚未加入暂存区。&lt;/p>
&lt;h4 id="index-文件">Index 文件&lt;/h4>
&lt;p>暂存区并不像工作区有可见的文件系统目录，或者像提交历史一样通过 &lt;code>.git/objects&lt;/code> 目录保存着所有提交对象，它没有实际存在的目录或文件夹，它的实体是位于 &lt;code>.git&lt;/code> 目录的 &lt;code>index&lt;/code> 文件。 &lt;code>index&lt;/code> 是一个二进制文件，包含着一个由路径名称、权限和 &lt;code>blob&lt;/code> 对象的 SHA-1 值组成的有序列表。&lt;/p>
&lt;p>我们可以通过 &lt;code>git ls-files&lt;/code> 命令查看 &lt;code>index&lt;/code> 中的内容：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git ls-files --stage
&lt;span class="m">100644&lt;/span> 30d74d258442c7c65512eafab474568dd706c430 &lt;span class="m">0&lt;/span> README.md
&lt;span class="m">100644&lt;/span> 9c1cab9a57432098de869e202ed73161af33d182 &lt;span class="m">0&lt;/span> main.py
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>index&lt;/code> 中记录了暂存区文件的路径名称和 SHA-1 ID，文件内容已经作为 &lt;code>blob&lt;/code> 对象保存到了 &lt;code>.git/objects&lt;/code> 目录中：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ tree .git/objects -L &lt;span class="m">2&lt;/span>
.git/objects
├── &lt;span class="m">30&lt;/span>
│   └── d74d258442c7c65512eafab474568dd706c430
├── 9c
│   └── 1cab9a57432098de869e202ed73161af33d182
├── info
└── pack
&lt;span class="m">4&lt;/span> directories, &lt;span class="m">2&lt;/span> files
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>blob&lt;/code> 对象是 Git 用来保存文件数据的二进制对象，我们可以通过 ID 取得对应的 &lt;code>blob&lt;/code> 对象，用 &lt;code>git cat-file&lt;/code> 命令打印其内容：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git cat-file -p 30d74d258442c7c65512eafab474568dd706c430
This is a README file.
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>当我们将一个修改过的文件加入暂存区后，如果又在工作区对文件进行了新的修改，需要重新将其加入暂存区，因为暂存区以 &lt;code>blob&lt;/code> 对象保存的只是文件加入时的内容。&lt;/p>
&lt;p>在 &lt;code>index&lt;/code> 文件中，还记录了每一个文件的创建时间和最后修改时间等元信息，它通过引用实际的数据对象包含了一份完整的文件快照，因此可以通过对比 SHA-1 校验和实现与工作区文件之间的快速比较。&lt;/p>
&lt;h3 id="提交历史">提交历史&lt;/h3>
&lt;p>提交历史是工作区文件在不同时间的文件快照（快照即文件或文件夹在特定时间点的状态，包括内容和元信息）。&lt;/p>
&lt;p>我们可以通过 &lt;code>git log&lt;/code> 命令查看当前分支的提交历史：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git log
commit ea4c48a0984880bda4031f0713229229c12793e4 &lt;span class="o">(&lt;/span>HEAD -&amp;gt; master&lt;span class="o">)&lt;/span>
Author: Waynerv &amp;lt;waynerv@notmyemail.com&amp;gt;
Date: Wed Jan &lt;span class="m">6&lt;/span> 21:05:44 &lt;span class="m">2021&lt;/span> +0800
add main file
commit b15cc74d6d85435660fcacce1305a54273880479
Author: Waynerv &amp;lt;waynerv@notmyemail.com&amp;gt;
Date: Wed Jan &lt;span class="m">6&lt;/span> 21:05:06 &lt;span class="m">2021&lt;/span> +0800
add ignore file
commit e137e9b81cc5dfc5b1c9c7d06b861553d5c42491
Author: Waynerv &amp;lt;waynerv@notmyemail.com&amp;gt;
Date: Wed Jan &lt;span class="m">6&lt;/span> 21:04:39 &lt;span class="m">2021&lt;/span> +0800
first commit
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>每一个提交都会有一个 40 位的「ID」：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">ea4c48a0984880bda4031f0713229229c12793e4
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>Git 通过「提交对象」来储存每一次提交。这个 ID 是以对象内容进行 SHA-1 计算得到的哈希值，不同的内容一定会得到不同的结果，Git 既把它作为每一个对象（不仅仅是提交对象）的唯一标识符，也用作 &lt;code>.git/objects&lt;/code> 目录中的地址（其中存储着实际的二进制文件），我们可以用 ID 找到对应的对象并打印其内容：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git cat-file -p ea4c48a0984880bda4031f0713229229c12793e4
tree 9e761342b98484aac2d8734f45fc2d0fde3e29db
parent b15cc74d6d85435660fcacce1305a54273880479
author Waynerv &amp;lt;waynerv@notmyemail.com&amp;gt; &lt;span class="m">1609938344&lt;/span> +0800
committer Waynerv &amp;lt;waynerv@notmyemail.com&amp;gt; &lt;span class="m">1609938344&lt;/span> +0800
add main application file
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这个提交对象的内容包含三部分：&lt;/p>
&lt;ul>
&lt;li>对应的 &lt;code>tree&lt;/code> 对象的 ID&lt;/li>
&lt;li>父提交对象的 ID&lt;/li>
&lt;li>作者、提交者及提交信息等元信息&lt;/li>
&lt;/ul>
&lt;p>&lt;code>tree&lt;/code> 对象主要由其他 &lt;code>tree&lt;/code> 对象和 &lt;code>blob&lt;/code> 对象的 ID 以及路径名称组成：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git ls-tree 9e761342b98484aac2d8734f45fc2d0fde3e29db
&lt;span class="m">100644&lt;/span> blob 723ef36f4e4f32c4560383aa5987c575a30c6535 .gitignore
&lt;span class="m">100644&lt;/span> blob 30d74d258442c7c65512eafab474568dd706c430 README.md
&lt;span class="m">100644&lt;/span> blob 9c1cab9a57432098de869e202ed73161af33d182 main.py
&lt;span class="m">040000&lt;/span> tree 556af47de72b597f532f63b63983be433f137e57 tests
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>就像目录递归地包含其他目录和文件一样，一个 &lt;code>tree&lt;/code> 对象即可表示整个工作区中所有已提交目录及文件的内容，也就是说提交历史中的每一个提交都包含着一份完整的某一时刻的文件快照，并通过保存上一次提交的引用形成连续的文件快照历史。&lt;/p>
&lt;h3 id="工作流程">工作流程&lt;/h3>
&lt;p>在继续前，我们需要简单了解下分支和 HEAD。&lt;/p>
&lt;p>在 Git 中我们将 SHA-1 值用做提交对象（以及 &lt;code>tree&lt;/code> 和 &lt;code>blob&lt;/code> 对象）的 ID，通过 ID 操作提交对象以及提交对象引用的文件快照。但大部分时候，记住一个 ID 是非常困难的，因此 Git 用一个文件来保存 SHA-1 值，这个文件的名字即作为「引用（refs）」来替代原始的 SHA-1 值。&lt;/p>
&lt;p>这类包含 SHA-1 值的文件保存在 &lt;code>.git/refs&lt;/code> 目录下，我们可以在 &lt;code>.git/refs/heads&lt;/code> 目录中找到代表各个分支引用的文件，尝试打印 &lt;code>master&lt;/code> 文件的内容：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ cat .git/refs/heads/master
ea4c48a0984880bda4031f0713229229c12793e4
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这基本就是 Git 分支的本质：一个指向某一系列提交之首的指针或引用。&lt;/p>
&lt;p>我们还用 HEAD 来指向最近的一次提交，HEAD 文件通常是一个符号引用（symbolic reference），指向目前所在的分支。 所谓符号引用，表示它是一个指向其他引用的引用：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ cat .git/HEAD
ref: refs/heads/master
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但在某些情况下，HEAD 文件可能会包含一个 git 对象的 SHA-1 值。 当你在检出一个标签、提交或远程分支，让你的仓库变成 「&lt;a href="https://git-scm.com/docs/git-checkout#_detached_head">分离 HEAD&lt;/a>」状态时，就会出现这种情况。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git checkout ea4c48a0984880bda4031f0713229229c12793e4
$ cat .git/HEAD
ea4c48a0984880bda4031f0713229229c12793e4
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>最后，让我们来看一下上文介绍的三棵树之间的工作流程：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/git-three-trees.png" alt="Untitled">&lt;/p>
&lt;ol>
&lt;li>假设我们进入到一个新目录，其中有一个 &lt;code>README&lt;/code> 文件。此时暂存区为空，提交历史为空，HEAD 引用指向未创建的 &lt;code>master&lt;/code> 分支。&lt;/li>
&lt;li>现在我们想提交该文件，首先需要通过 &lt;code>git add&lt;/code> 将其添加到暂存区。此时 Git 将在 &lt;code>.git/objects&lt;/code> 目录中以该文件的内容生成一个 &lt;code>blob&lt;/code> 对象，并将 &lt;code>blob&lt;/code> 对象的信息添加到 &lt;code>.git/index&lt;/code> 文件中。&lt;/li>
&lt;li>接着运行 &lt;code>git commit&lt;/code> ，它会取得暂存区中的内容生成一个 &lt;code>tree&lt;/code> 对象，该 &lt;code>tree&lt;/code> 对象即为工作区文件的永久快照，然后创建一个指向该 &lt;code>tree&lt;/code> 对象的提交对象，最后更新 &lt;code>master&lt;/code> 指向本次提交。&lt;/li>
&lt;li>假如我们在工作区编辑了文件，Git 会将其与暂存区现有文件快照进行比较，在 &lt;code>git add&lt;/code> 了更改的文件后，根据文件当前内容生成新的 &lt;code>blob&lt;/code> 对象并更新 &lt;code>.git/index&lt;/code> 文件中的引用 ID。&lt;code>git commit&lt;/code> 的过程与之前类似，但是新的提交对象会以 HEAD 引用指向的提交作为父提交，然后更新其引用的 &lt;code>master&lt;/code> 指向新创建的提交。&lt;/li>
&lt;li>当我们 &lt;code>git checkout&lt;/code> 一个分支或提交时，它会修改 HEAD 指向新的分支引用或提交，将暂存区填充为该次提交的文件快照，然后将暂存区的内容解包复制到工作区中。&lt;/li>
&lt;/ol>
&lt;h2 id="常见的撤销命令">常见的「撤销」命令&lt;/h2>
&lt;p>接下来我们将使用如下的 Git 仓库作为基准示例，介绍一些常见的「撤销」命令。假设工作区中已存在这些文件，且开始介绍每个命令时示例仓库都会回到初始状态：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git init
$ git add README.md &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> git commit -m &lt;span class="s2">&amp;#34;first commit&amp;#34;&lt;/span>
$ git add .gitignore &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> git commit -m &lt;span class="s2">&amp;#34;add ignore file&amp;#34;&lt;/span>
$ git add main.py &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> git commit -m &lt;span class="s2">&amp;#34;add main file&amp;#34;&lt;/span>
$ git log --pretty&lt;span class="o">=&lt;/span>oneline
ea4c48a &lt;span class="o">(&lt;/span>HEAD -&amp;gt; master&lt;span class="o">)&lt;/span> add main file
b15cc74 add ignore file
e137e9b first commit
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>为了方便展示我们将只取 SHA-1 ID 的前 7 位，但 Git 依然能准确的找到对应的提交。&lt;/p>
&lt;h3 id="git-checkout">git checkout&lt;/h3>
&lt;p>&lt;code>checkout&lt;/code> 有两种工作方式：在命令参数中带文件路径与不带。两种方式的具体行为有很大区别。&lt;/p>
&lt;h4 id="不带路径">不带路径&lt;/h4>
&lt;p>不带路径的&lt;code>git checkout [commit or branch]&lt;/code> 用于「检出」某个提交或分支，检出可以理解为「拿出来查看」，因此这个操作对工作区是安全的。&lt;code>git checkout [commit]&lt;/code> 会更新所有的三棵树，使其和 &lt;code>[commit]&lt;/code> 的状态保持一致，但保留工作区和暂存区所做的更改。&lt;/p>
&lt;p>假如我们在工作区新增了 &lt;code>tests/test.py&lt;/code> 文件，并加入到了暂存区中，然后 &lt;code>checkout&lt;/code> 到上一个提交：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git add tests/test.py
$ git checkout b15cc74
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>checkout&lt;/code> 命令的执行过程如以下动图所示：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/Jan-11-2021-git-checkout.gif" alt="Jan-11-2021-git-checkout">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先 HEAD 会直接指向 &lt;code>b15cc74&lt;/code> 提交，进入分离 HEAD 状态，即不再指向分支引用：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ cat .git/HEAD
b15cc74
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>然后将提取 &lt;code>b15cc74&lt;/code> 提交的文件快照依次更新到暂存区以及工作区。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若工作区与暂存区存在未提交的本地更改，&lt;code>checkout&lt;/code> 还会尝试将文件快照与本地更改做简单的合并，若合并失败，将会中止操作并恢复到 &lt;code>checkout&lt;/code> 之前的状态。因此&lt;code>checkout&lt;/code> 对工作区是安全的，它不会丢弃工作区所做的更改。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;code>git checkout [branch]&lt;/code> 的执行过程与上面类似，但是 HEAD 会指向 &lt;code>[branch]&lt;/code> 这个分支引用。&lt;/p>
&lt;h4 id="带路径">带路径&lt;/h4>
&lt;p>当 &lt;code>git checkout&lt;/code> 像下面这样在命令参数中带文件路径时：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git checkout b15cc74 README.md
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>执行过程如如以下动图所示：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/Jan-11-2021-git-checkout-file.gif" alt="Jan-11-2021-git-checkout-file">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>它会找到该提交，并在该提交的文件快照中匹配文件路径对应的文件，但并&lt;strong>不会移动&lt;/strong> HEAD：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ cat .git/HEAD
ref: refs/heads/master
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>将匹配到的文件快照覆盖到暂存区以及工作区。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>若工作区与暂存区存在对该文件的本地更改，该更改将会丢失。因此&lt;code>checkout&lt;/code> 带文件路径时对工作区是不安全的，它会丢弃工作区对该文件所做的更改。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="git-reset">git reset&lt;/h3>
&lt;p>&lt;code>git reset&lt;/code> 的主要作用是将 HEAD 重置为指定的提交。与 &lt;code>checkout&lt;/code> 的区别在于，它对提交历史的更改并不仅仅只是更新 HEAD 本身，如果 HEAD 原来指向某个分支引用，则会将分支引用也更新为指向新的提交。&lt;/p>
&lt;p>它的工作方式更多了，有 &lt;code>—soft&lt;/code>、 &lt;code>--mixed&lt;/code>、&lt;code>--hard&lt;/code> 三种主要的命令选项，分别对应更新不同数量的树：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/iShot2021-01-07-git-reset.png" alt="iShot2021-01-07 22.21.30">&lt;/p>
&lt;h4 id="--soft">&lt;code>--soft&lt;/code>&lt;/h4>
&lt;p>当命令行选项为 &lt;code>--soft&lt;/code> 时，&lt;code>git reset&lt;/code> 只会对提交历史进行重置：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git checkout master &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> cat .git/refs/heads/master
已经位于 &lt;span class="s1">&amp;#39;master&amp;#39;&lt;/span>
ea4c48a
$ git reset --soft b15cc74
$ git status
位于分支 master
要提交的变更：
（使用 &lt;span class="s2">&amp;#34;git restore --staged &amp;lt;文件&amp;gt;...&amp;#34;&lt;/span> 以取消暂存）
新文件： main.py
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>执行过程如以下动图所示：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/Jan-11-2021-git-reset-soft.gif" alt="Jan-11-2021-git-reset-soft">&lt;/p>
&lt;ol>
&lt;li>
&lt;p>首先将 HEAD 及其指向的分支引用指向 &lt;code>b15cc74&lt;/code> 提交，本示例中 HEAD 原本指向 &lt;code>master&lt;/code> ，执行操作之后依然指向 &lt;code>master&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ cat .git/HEAD
ref: refs/heads/master
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但 &lt;code>master&lt;/code> 分支引用却从原来指向 &lt;code>ea4c48a&lt;/code> 变成了指向 &lt;code>b15cc74&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ cat .git/refs/heads/master
b15cc74
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>若 HEAD 原本处于分离 HEAD 状态，则只会更新 HEAD 本身。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>reset --soft&lt;/code> 到此就已经结束了，它不会再对暂存区以及工作区进行任何更改，暂存区和工作区依然保留着原来的 &lt;code>ea4c48a&lt;/code> 提交之后的文件快照与文件，因此运行 &lt;code>git status&lt;/code> 我们将看到暂存区中有待提交的变更，工作区和暂存区中的本地更改也都会得到保留。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h4 id="--mixed">&lt;code>--mixed&lt;/code>&lt;/h4>
&lt;p>&lt;code>--mixed&lt;/code> 选项是 &lt;code>git reset&lt;/code> 命令的默认选项，&lt;code>git reset [commit]&lt;/code> 即等同于 &lt;code>git reset --mixed [commit]&lt;/code>。它除了重置提交历史，还会更新暂存区：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git checkout master &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> cat .git/refs/heads/master
已经位于 &lt;span class="s1">&amp;#39;master&amp;#39;&lt;/span>
ea4c48a
$ git reset --mixed b15cc74
$ git status
位于分支 master
未跟踪的文件:
（使用 &lt;span class="s2">&amp;#34;git add &amp;lt;文件&amp;gt;...&amp;#34;&lt;/span> 以包含要提交的内容）
main.py
提交为空，但是存在尚未跟踪的文件（使用 &lt;span class="s2">&amp;#34;git add&amp;#34;&lt;/span> 建立跟踪）
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>执行过程如以下动图所示：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/Jan-11-2021-git-reset-mixed.gif" alt="Jan-11-2021-git-reset-mixed">&lt;/p>
&lt;ol>
&lt;li>更新 HEAD 指向 &lt;code>b15cc74&lt;/code> 提交，重置提交历史的过程与 &lt;code>--soft&lt;/code> 完全相同。&lt;/li>
&lt;li>之后还会更新暂存区，将其填充为 &lt;code>b15cc74&lt;/code> 提交的文件快照，暂存区中的原有内容将会丢失。&lt;/li>
&lt;li>不会对工作区进行任何更改，工作区依然保留着原来的 &lt;code>ea4c48a&lt;/code> 提交之后的文件，因此运行 &lt;code>git status&lt;/code> 我们将看到有未跟踪的文件待加入暂存区，工作区中的本地更改也会得到保留。&lt;/li>
&lt;/ol>
&lt;h4 id="--hard">&lt;code>--hard&lt;/code>&lt;/h4>
&lt;p>&lt;code>--hard&lt;/code> 是 &lt;code>reset&lt;/code> 最&lt;strong>直接&lt;/strong>、最&lt;strong>危险&lt;/strong>以及最&lt;strong>常用&lt;/strong>的选项。 &lt;code>git reset —hard [commit]&lt;/code> 会将所有的三棵树都更新为指定提交的状态，工作区和暂存区中所有未提交的更改都会永久丢失，但被重置的提交仍有办法找回。&lt;/p>
&lt;p>我们同样执行如下操作：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git checkout master &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> cat .git/refs/heads/master
已经位于 &lt;span class="s1">&amp;#39;master&amp;#39;&lt;/span>
ea4c48a
$ git reset --hard b15cc74
HEAD 现在位于 b15cc74 add gitignore file
$ git status
位于分支 master
无文件要提交，干净的工作区
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>执行过程如以下动图所示：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/Jan-11-2021-git-reset-hard.gif" alt="Jan-11-2021-git-reset-hard">&lt;/p>
&lt;ol>
&lt;li>更新 HEAD 指向 &lt;code>b15cc74&lt;/code> 提交，重置提交历史的过程与 &lt;code>--soft&lt;/code> 及 &lt;code>--mixed&lt;/code> 选项相同。&lt;/li>
&lt;li>更新暂存区，将其填充为 &lt;code>b15cc74&lt;/code> 提交的文件快照，暂存区中的原有内容将会丢失。&lt;/li>
&lt;li>更新工作区，将其填充为 &lt;code>b15cc74&lt;/code> 提交的文件快照，工作区中的原有内容将会丢失。&lt;/li>
&lt;/ol>
&lt;p>正如上面所说，&lt;code>reset —hard&lt;/code> 会将工作区、暂存区和提交历史都重置为刚刚新增了 &lt;code>b15cc74&lt;/code> 提交时的状态，并简单粗暴地覆盖掉工作区和暂存区的原有内容。这是一个非常危险的操作，因为工作区和暂存区的未提交更改丢失后无法再通过 Git 找回。&lt;/p>
&lt;h4 id="找回提交历史">找回提交历史&lt;/h4>
&lt;p>&lt;code>reset&lt;/code> 后丢失的提交历史仍然能够恢复，因为我们只是更新了 HEAD 指向的提交，而没有对实际的提交对象做任何更改。我们可以通过 &lt;code>git reflog&lt;/code> 找到 HEAD 曾经指向过的提交：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git reflog
b15cc74 &lt;span class="o">(&lt;/span>HEAD -&amp;gt; master&lt;span class="o">)&lt;/span> HEAD@&lt;span class="o">{&lt;/span>0&lt;span class="o">}&lt;/span>: reset: moving to b15cc74
ea4c48a HEAD@&lt;span class="o">{&lt;/span>1&lt;span class="o">}&lt;/span>: checkout: moving from master to master
......
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>从中可以找到 &lt;code>master&lt;/code> 原来所指向的 &lt;code>ea4c48a&lt;/code> 提交，再执行 &lt;code>git reset --hard ea4c48a&lt;/code> 就能恢复原来的提交历史。&lt;/p>
&lt;h4 id="不要-reset-公共分支">不要 reset 公共分支&lt;/h4>
&lt;p>另一个关于 &lt;code>reset&lt;/code>的实践是，不要在公共分支上执行 &lt;code>reset&lt;/code>。公共分支是指你与其他团队成员协作开发的分支。&lt;/p>
&lt;p>当任何提交被推送到公共分支后，必须假设其他开发者已经依赖它。删除其他人已经在继续开发的提交，会给协作带来严重的问题。而且你需要强制推送才能将你 &lt;code>reset&lt;/code> 后的分支提交到远程仓库，当其他人拉取这个公共分支时，他们的提交历史会突然消失一部分。&lt;/p>
&lt;p>因此，请确保在本地的实验分支上使用 &lt;code>git reset&lt;/code>，而不要重置已经发布到公共分支的提交。如果你需要修复一个公共提交引入的问题，请看之后将介绍的专门为此目的设计的 &lt;code>git revert&lt;/code>。&lt;/p>
&lt;h4 id="取消暂存文件">取消暂存文件&lt;/h4>
&lt;p>和 &lt;code>checkout&lt;/code> 一样，&lt;code>git reset&lt;/code> 也能对文件路径执行，常用于将已加入暂存区的指定文件或文件集合取消暂存。&lt;/p>
&lt;p>假设我们在工作区新增了 &lt;code>hello.py&lt;/code> 和 &lt;code>world.py&lt;/code> 两个文件，并同时加入了暂存区：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git add .
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在我们意识到这两个文件不应该放在一个提交中，因此需要将其中一个文件取消暂存：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git reset world.py
$ git status
位于分支 master
您的分支与上游分支 &lt;span class="s1">&amp;#39;origin/master&amp;#39;&lt;/span> 一致。
要提交的变更：
（使用 &lt;span class="s2">&amp;#34;git restore --staged &amp;lt;文件&amp;gt;...&amp;#34;&lt;/span> 以取消暂存）
新文件： hello.py
未跟踪的文件:
（使用 &lt;span class="s2">&amp;#34;git add &amp;lt;文件&amp;gt;...&amp;#34;&lt;/span> 以包含要提交的内容）
world.py
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>此时暂存区中只有 &lt;code>hello.py&lt;/code> 文件了，我们可以分别提交它们：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git commit -m &lt;span class="s2">&amp;#34;add hello.py&amp;#34;&lt;/span>
&lt;span class="c1"># 在另一个提交中提交 world.py&lt;/span>
$ git add world.py
$ git commit -m &lt;span class="s2">&amp;#34;add world.py&amp;#34;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>实际上 &lt;code>reset&lt;/code> 带文件路径命令的完整形式是下面这样的：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git reset &lt;span class="o">[&lt;/span>&amp;lt;tree-ish&amp;gt;&lt;span class="o">]&lt;/span> &amp;lt;pathspec&amp;gt;…
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>该操作的实质，是从 &lt;code>&amp;lt;tree-ish&amp;gt;&lt;/code> 提取 &lt;code>&amp;lt;pathspec&amp;gt;&lt;/code> 对应的文件快照更新到暂存区，&lt;code>&amp;lt;tree-ish&amp;gt;&lt;/code>可以是提交或分支，默认值为 HEAD，因此默认会将暂存区的指定路径恢复到 HEAD 提交的状态。 &lt;code>git reset world.py&lt;/code> 命令的实际过程是：&lt;/p>
&lt;ol>
&lt;li>从 HEAD 提交中匹配 &lt;code>world.py&lt;/code> 对应的文件快照。&lt;/li>
&lt;li>将匹配到的文件快照复制到暂存区。&lt;/li>
&lt;/ol>
&lt;p>因此，当我们修改了某个文件添加到暂存区，&lt;code>reset&lt;/code> 后会被替换成原本的文件版本；新增的文件会从暂存区中移除（因为上一次提交中没有该文件），实际实现了将文件取消暂存的效果。&lt;/p>
&lt;h3 id="git-revert">git revert&lt;/h3>
&lt;p>&lt;code>git revert&lt;/code> 命令用于回滚某一个（或多个）提交引入的更改。&lt;/p>
&lt;p>其他的「撤销」命令如 &lt;code>git checkout&lt;/code> 和 &lt;code>git reset&lt;/code>，会将 HEAD 或分支引用重新指向到指定的提交，&lt;code>git revert&lt;/code> 命令也可以接受一个指定的提交，但并不会将任何引用移动到这个提交上。&lt;code>revert&lt;/code> 操作会接收指定的提交，反转该提交引入的更改，并创建一个新的「回滚提交」记录反转更改，然后更新分支引用，使其指向该提交。如以下动图所示：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/Jan-11-2021-git-revert.gif" alt="Jan-11-2021-git-revert">&lt;/p>
&lt;p>相比 &lt;code>reset&lt;/code> ，&lt;code>revert&lt;/code> 会在提交历史中增加一个新的提交，而不会对之前的提交进行任何更改。 默认情况下 &lt;code>revert&lt;/code> 会自动执行如下步骤：&lt;/p>
&lt;ul>
&lt;li>将反转指定提交的更改合并到工作区&lt;/li>
&lt;li>将更改添加到暂存区&lt;/li>
&lt;li>创建新的提交&lt;/li>
&lt;/ul>
&lt;p>因此它要求我们提供一个干净的暂存区（即和 HEAD 提交状态一致），且要求工作区的本地更改不会被合并操作覆盖，否则回滚会失败。我们可以添加 &lt;code>--no-commit&lt;/code> 命令选项来进入交互模式手动执行「创建新的提交」，此时 &lt;code>revert&lt;/code> 操作会将反转的更改应用到工作区和暂存区等待提交，且不要求暂存区与 HEAD 一致。&lt;/p>
&lt;p>我们通过示例来演示这一过程，现在我们想回滚 &lt;code>b15cc74&lt;/code> 这个提交，这个提交中加入了 &lt;code>.gitignore&lt;/code> 文件，预期的结果是会新增一个删除该文件的提交：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git revert b15cc74
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在终端执行该命令后将直接跳转到一个编辑器界面，可以修改新提交的提交信息：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">Revert &lt;span class="s2">&amp;#34;add gitignore file&amp;#34;&lt;/span>
This reverts commit b15cc74d6d85435660fcacce1305a54273880479.
&lt;span class="c1"># 请为您的变更输入提交说明。以 &amp;#39;#&amp;#39; 开始的行将被忽略，而一个空的提交&lt;/span>
&lt;span class="c1"># 说明将会终止提交。&lt;/span>
......
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>保存后 &lt;code>revert&lt;/code> 命令执行结束，并输出以下结果：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">删除 .gitignore
&lt;span class="o">[&lt;/span>master 6bb25da&lt;span class="o">]&lt;/span> Revert &lt;span class="s2">&amp;#34;add gitignore file&amp;#34;&lt;/span>
&lt;span class="m">1&lt;/span> file changed, &lt;span class="m">1&lt;/span> deletion&lt;span class="o">(&lt;/span>-&lt;span class="o">)&lt;/span>
delete mode &lt;span class="m">100644&lt;/span> .gitignore
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>结果符合预期，新增了一个删除 &lt;code>.gitignore&lt;/code> 文件的 &lt;code>6bb25da&lt;/code> 提交，并且 &lt;code>master&lt;/code> 当前指向了该提交。&lt;/p>
&lt;p>但如果我们在一开始对工作区中的文件做过更改且加入到了暂存区，执行 &lt;code>revert&lt;/code> 的结果如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git revert b15cc74
error: 您的本地修改将被还原覆盖。
提示：提交您的修改或贮藏后再继续。
fatal: 还原失败
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h4 id="revert-的优势">revert 的优势&lt;/h4>
&lt;p>虽然效果与 &lt;code>reset&lt;/code> 相似，但使用 &lt;code>revert&lt;/code> 有以下优势：&lt;/p>
&lt;ul>
&lt;li>它不会改变之前的提交历史，这使得 &lt;code>revert&lt;/code> 对于已经推送到共享仓库的提交是一个「安全」的操作，它会完整的记录某个提交被加入及回滚的过程。&lt;/li>
&lt;li>它可以回滚提交历史上任意一个（或多个）点的提交，而 &lt;code>reset&lt;/code> 只能重置从指定提交起之后的所有历史。&lt;/li>
&lt;/ul>
&lt;h3 id="使用场景">使用场景&lt;/h3>
&lt;p>我们分别介绍了 &lt;code>checkout&lt;/code> 、&lt;code>reset&lt;/code> 、&lt;code>revert&lt;/code> 三个命令的主要用法，下面的表格概括了它们的常见使用场景：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th style="text-align:left">命令&lt;/th>
&lt;th>作用对象&lt;/th>
&lt;th>常用场景&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td style="text-align:left">&lt;code>git reset&lt;/code>&lt;/td>
&lt;td>提交&lt;/td>
&lt;td>放弃私人分支上的提交或者还未提交的本地更改&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>git reset&lt;/code>&lt;/td>
&lt;td>文件&lt;/td>
&lt;td>将一个文件取消暂存&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>git checkout&lt;/code>&lt;/td>
&lt;td>提交&lt;/td>
&lt;td>切换分支或者查看一个之前的提交&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>git checkout&lt;/code>&lt;/td>
&lt;td>文件&lt;/td>
&lt;td>将文件恢复到指定提交时的状态并丢弃在工作区中对该文件的更改&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>git revert&lt;/code>&lt;/td>
&lt;td>提交&lt;/td>
&lt;td>在公共分支上撤销一个提交&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td style="text-align:left">&lt;code>git revert&lt;/code>&lt;/td>
&lt;td>文件&lt;/td>
&lt;td>无&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h2 id="其他替代命令">其他替代命令&lt;/h2>
&lt;p>我们介绍了 &lt;code>checkout&lt;/code> 、&lt;code>reset&lt;/code> 、&lt;code>revert&lt;/code> 三个命令共 7 种和撤销相关的用法，而这些命令还有许多其他的选项和用途，在使用这些命令时，即使是老手也可能需要不时地对照手册。也许是意识到了这个问题，Git 在 2.23 版本中又发布了 &lt;code>resetore&lt;/code> 和 &lt;code>switch&lt;/code> 两个新命令，新命令能替代上面的部分用法且用途更为专一。&lt;/p>
&lt;h3 id="git-restore">git restore&lt;/h3>
&lt;p>&lt;code>restore&lt;/code> 命令用于还原工作区或暂存区中的指定文件或文件集合：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git restore &lt;span class="o">[&lt;/span>--source&lt;span class="o">=&lt;/span>&amp;lt;tree&amp;gt;&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>--staged&lt;span class="o">]&lt;/span> &lt;span class="o">[&lt;/span>--worktree&lt;span class="o">]&lt;/span> &amp;lt;pathspec&amp;gt;…
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>从定义和命令行形式来理解：&lt;/p>
&lt;ul>
&lt;li>还原即恢复到过去某一状态，意味着该命令需要指定已有的某个文件快照（提交、分支等）作为数据源，通过 &lt;code>source&lt;/code> 选项设置。&lt;/li>
&lt;li>可以选择对工作区（&lt;code>--worktree&lt;/code> ）、暂存区（&lt;code>--staged&lt;/code> ）或两者同时生效，默认值为仅工作区。当指定的位置为工作区时，默认数据源为暂存区的文件快照；当指定的位置包含暂存区时，默认数据源为 HEAD。&lt;/li>
&lt;li>可以选择对指定的文件或一些文件生效，通过 &lt;code>&amp;lt;pathspec&amp;gt;&lt;/code> 参数指定。&lt;/li>
&lt;/ul>
&lt;p>我们继续使用之前的 Git 仓库作为示例，假设我们修改了 &lt;code>main.py&lt;/code> 并已经加入到了暂存区：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>我们想将 &lt;code>main.py&lt;/code> 取消暂存，即将暂存区中的 &lt;code>main.py&lt;/code> 还原为 HEAD 中的内容，此时 HEAD 是默认的 &lt;code>source&lt;/code> ，因此可执行如下命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git restore --staged main.py
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>该文件将被取消暂存。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>现在我们想放弃工作区中对该文件的更改，可以选择将其还原为暂存区中的内容，因为此时暂存区中的内容和 HEAD 相同：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git restore main.py
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>这只是最基础的用法，还可以指定 &lt;code>--source&lt;/code> 为任意提交 ID 将文件还原为该提交中的状态。&lt;/p>
&lt;p>&lt;code>git restore [--source=&amp;lt;tree-ish&amp;gt;] --staged &amp;lt;pathspec&amp;gt;...&lt;/code> 和 &lt;code>git reset [&amp;lt;tree-ish&amp;gt;] &amp;lt;pathspec&amp;gt;&lt;/code> 在使用上是等价的。较新版本的 Git 会在命令行中提示使用 &lt;code>restore&lt;/code> 命令来取消暂存或丢弃工作区的改动。&lt;/p>
&lt;h3 id="git-switch">git switch&lt;/h3>
&lt;p>&lt;code>git switch&lt;/code> 命令专门用于切换分支，可以用来替代 &lt;code>checkout&lt;/code> 的部分用途。&lt;/p>
&lt;p>创建并切换到指定分支（ &lt;code>-C&lt;/code> 大小写皆可）：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git switch -C &amp;lt;new-branch&amp;gt;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>切换到已有分支：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git switch &amp;lt;branch&amp;gt;
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>和 &lt;code>checkout&lt;/code> 一样， &lt;code>switch&lt;/code> 对工作区是安全的，它会尝试合并工作区和暂存区中的本地更改，如果无法完成合并则会中止操作，本地更改会被保留。&lt;/p>
&lt;p>&lt;code>switch&lt;/code> 的使用方式简单且专一，它无法像 &lt;code>checkout&lt;/code> 一样对指定提交使用：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ git switch ea4c48a
fatal: 期望一个分支，得到提交 &lt;span class="s1">&amp;#39;ea4c48a&amp;#39;&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="常见问题及解决方案">常见问题及解决方案&lt;/h2>
&lt;h3 id="撤销本地分支提交">撤销本地分支提交&lt;/h3>
&lt;p>使用 &lt;code>git reset&lt;/code> ，取决于你是否需要保留该提交之后的更改，添加 &lt;code>--soft&lt;/code> 、&lt;code>—hard&lt;/code> 等选项。&lt;/p>
&lt;h3 id="回滚远程主干分支上的提交">回滚远程主干分支上的提交&lt;/h3>
&lt;p>使用 &lt;code>git revert&lt;/code>。&lt;/p>
&lt;h3 id="修改上一次提交的内容">修改上一次提交的内容&lt;/h3>
&lt;p>如果该提交还未进入公共分支，最直接的方式是使用 &lt;code>git commit --amend&lt;/code>。如果该提交已经位于公共分支，应该使用 &lt;code>git revert&lt;/code>。&lt;/p>
&lt;h3 id="暂存更改后再恢复">暂存更改后再恢复&lt;/h3>
&lt;p>一个很常见的场景是，我们在当前分支修改了一些文件，但还不足以组织成提交或者包含了多个提交的内容，突然有紧急情况需要开始一项新的任务，此时我们希望可以将工作区和暂存区的本地更改暂时保存起来，以备在其他工作完成后可以从这里继续。&lt;/p>
&lt;p>我们当然可以创建一个临时的分支然后重置或合并来实现目的，但那样复杂而繁琐。而 &lt;code>git stash&lt;/code> 命令则可以很好的满足需求，它会将本地更改保存起来，并将工作区和暂存区恢复到与 HEAD 提交相匹配的状态。此时我们可以切换到其他分支或者继续在当前分支完成其他任务，之后再将暂存的内容取回。&lt;/p>
&lt;p>&lt;code>git stash&lt;/code> 的基本用法如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 保存当前更改（添加 -u 选项以包括未跟踪的新文件）&lt;/span>
$ git stash -u
&lt;span class="c1"># 完成其他任务......&lt;/span>
&lt;span class="c1"># 恢复暂存的更改&lt;/span>
$ git stash pop
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>stash&lt;/code> 的实质也是将本地更改保存为一次新的提交，然后再将该提交恢复到工作区和暂存区，但它不会影响当前的提交历史。&lt;code>stash&lt;/code> 还有更多进阶用法，比如指定暂存的文件路径、暂存多次并择一恢复等。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>在本文中我们首先了解了一些必要的 Git 内部机制：&lt;/p>
&lt;ul>
&lt;li>使用 &lt;code>blob&lt;/code> 、&lt;code>tree&lt;/code> 和提交对象等内部对象保存数据，每次提交都是一份完整的文件快照。&lt;/li>
&lt;li>SHA-1 ID、分支引用及 HEAD 的实质。&lt;/li>
&lt;li>管理三棵树的状态：工作区、暂存区、提交历史。&lt;/li>
&lt;li>创建一次提交的完整工作流程。&lt;/li>
&lt;/ul>
&lt;p>然后通过示例分别介绍了 &lt;code>checkout&lt;/code> 、&lt;code>reset&lt;/code> 和 &lt;code>revert&lt;/code> 的基本用法与区别：&lt;/p>
&lt;ul>
&lt;li>&lt;code>checkout&lt;/code>
&lt;ul>
&lt;li>不带路径：将工作区、暂存区更新为指定提交的状态，但会保留本地更改。&lt;/li>
&lt;li>带路径：将指定文件更新为指定提交的状态，不会保留本地更改&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>reset&lt;/code>
&lt;ul>
&lt;li>&lt;code>—soft&lt;/code>：仅将 HEAD 及其指向的分支引用移动到指定提交。&lt;/li>
&lt;li>&lt;code>—mixed&lt;/code>：除了更改提交历史，还将暂存区也更新为指定提交的内容。&lt;/li>
&lt;li>&lt;code>—hard&lt;/code>：除了更改提交历史和暂存区，还将工作区也更新为指定提交的内容，工作区的本地更改会永久丢失。&lt;/li>
&lt;li>对文件路径使用可以将文件取消暂存。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>&lt;code>revert&lt;/code>
&lt;ul>
&lt;li>创建一个新的提交以撤销指定提交引入的更改。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>还介绍了两个新版本引入的更专一的命令：&lt;/p>
&lt;ul>
&lt;li>&lt;code>restore&lt;/code>：将工作区或暂存区的指定文件还原为指定提交时的状态。&lt;/li>
&lt;li>&lt;code>switch&lt;/code>：切换到已有分支或者创建并切换到新的分支。&lt;/li>
&lt;/ul>
&lt;p>最后给出了一些常见问题的解决方案并介绍了 &lt;code>git stash&lt;/code> 的用法。&lt;/p>
&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E7%BD%AE%E6%8F%AD%E5%AF%86#_git_reset">Git 工具 - 重置揭密&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%92%A4%E6%B6%88%E6%93%8D%E4%BD%9C">Git 基础 - 撤消操作&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.atlassian.com/git/tutorials/undoing-changes">Undoing Commits &amp;amp; Changes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/blue-harvest-tech-blog/git-2-23-0-forget-about-checkout-and-switch-to-restore-ac2682b737b3">Git 2.23.0: Forget about checkout, and switch to restore&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%BC%95%E7%94%A8">Git 内部原理 - Git 引用&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://medium.com/hackernoon/understanding-git-index-4821a0765cf">Understanding Git — Index&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.blog/2020-12-17-commits-are-snapshots-not-diffs/">Commits are snapshots, not diffs&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://shafiul.github.io//gitbook/7_the_git_index.html">The Git Index&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mincong.io/2018/04/28/git-index/#:~:text=The%20index%20is%20a%20binary,Git%3A%20they%20are%20used%20interchangeably.">Git: Understanding the Index File&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tom.preston-werner.com/2009/05/19/the-git-parable.html">The Git Parable&lt;/a>&lt;/li>
&lt;/ul></content><category scheme="https://www.waynerv.com/categories/%E5%B7%A5%E5%85%B7/" term="工具" label="工具"/><category scheme="https://www.waynerv.com/tags/git/" term="Git" label="Git"/></entry><entry><title type="text">构建保障代码质量的自动化工作流</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/build-automatic-code-quality-workflow/"/><id>https://www.waynerv.com/posts/build-automatic-code-quality-workflow/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2021-01-04T11:28:01+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">在我看来，代码质量就是程序员的职业底线。维护底线不能全靠自觉，因此本文将介绍几种自动化的工具，并展示如何将它们集成到日常的工作流……</summary><content type="html">&lt;p>在我看来，代码质量就是程序员的职业底线。维护底线不能全靠自觉，因此本文将介绍几种自动化的工具，并展示如何将它们集成到日常的工作流中，省心省力的持续保障代码质量。&lt;/p>
&lt;h2 id="linter">Linter&lt;/h2>
&lt;p>Linter 是一类用于标记程序错误、bug、风格错误和可疑结构的静态代码分析工具，比如 Python 中的 &lt;code>Pylint&lt;/code>、 &lt;code>flake8&lt;/code>，JavaScript 中的 &lt;code>EsLint&lt;/code>，这类工具会找到你代码中的错误，并给出如何修复的提示。&lt;/p>
&lt;h3 id="为何要使用-linter">为何要使用 Linter&lt;/h3>
&lt;p>人总是会粗心和犯错，借助 Linter 我们可以发现代码中不易察觉或遗漏的错误，并进行纠正。使用 Linter 有以下好处：&lt;/p>
&lt;ul>
&lt;li>根据 &lt;a href="https://www.python.org/dev/peps/pep-0008/">PEP8&lt;/a> 等语言规范持续的提示与纠正，帮助你写出更好的代码&lt;/li>
&lt;li>减少代码中的格式错误、笔误及糟糕的风格等低级错误&lt;/li>
&lt;li>节省团队成员 review 你代码的时间，提高协作效率&lt;/li>
&lt;li>配置简单，仅需几步即可上手&lt;/li>
&lt;/ul>
&lt;h3 id="flake8-示例">&lt;code>flake8&lt;/code> 示例&lt;/h3>
&lt;p>接下来我们以 Python 中的 &lt;code>flake8&lt;/code> 为例，介绍其用法。&lt;/p>
&lt;p>首先通过 &lt;code>pip&lt;/code> 安装 &lt;code>flake8&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ pip install flake8
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>flake8&lt;/code> 的使用非常简单，直接以需要检查的文件或整个目录的路径作为 &lt;code>flake8&lt;/code> 命令的参数：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ flake8 . &lt;span class="c1"># 检查当前目录下的所有文件&lt;/span>
./__init__.py:4:1: E402 module level import not at top of file
./__init__.py:4:1: F401 &lt;span class="s1">&amp;#39;.md_toc.main&amp;#39;&lt;/span> imported but unused
./__init__.py:4:25: W292 no newline at end of file
./md_toc.py:6:18: E999 SyntaxError: non-default argument follows default argument
./md_toc.py:28:80: E501 line too long &lt;span class="o">(&lt;/span>&lt;span class="m">108&lt;/span> &amp;gt; &lt;span class="m">79&lt;/span> characters&lt;span class="o">)&lt;/span>
./md_toc.py:48:80: E501 line too long &lt;span class="o">(&lt;/span>&lt;span class="m">113&lt;/span> &amp;gt; &lt;span class="m">79&lt;/span> characters&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在运行结果中， &lt;code>flake8&lt;/code> 不仅指出了具体的错误原因，还给出了出错的文件位置及代码所在行数。&lt;/p>
&lt;p>更多其他的选项可通过以下命令获取帮助：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ flake8 --help
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>flake8&lt;/code> 的可自定义程度很高，除了在运行时添加命令选项，我们还可以通过配置文件来自定义检查规则。方法是在运行 &lt;code>flake8&lt;/code> 的项目根目录添加 &lt;code>.flake8&lt;/code> 文件，并写入如下内容：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="k">[flake8]&lt;/span>
&lt;span class="na">max-line-length&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">120 # 适当提高最大行长度&lt;/span>
&lt;span class="na">max-complexity&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">24 # 设置最大复杂度为24&lt;/span>
&lt;span class="na">ignore&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">F401, W503, E203 # 忽略这些错误类型&lt;/span>
&lt;span class="na">exclude&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s"># 忽略以下文件
&lt;/span>&lt;span class="s"> .git,
&lt;/span>&lt;span class="s"> __pycache__,
&lt;/span>&lt;span class="s"> scripts,
&lt;/span>&lt;span class="s"> logs,
&lt;/span>&lt;span class="s"> upload,
&lt;/span>&lt;span class="s"> build,
&lt;/span>&lt;span class="s"> dist,
&lt;/span>&lt;span class="s"> docs,
&lt;/span>&lt;span class="s"> migrations&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>flake8&lt;/code> 还可以添加插件实现更多更强大的功能，比如我们想强制要求编写函数 &lt;code>docstring&lt;/code>，可以安装 &lt;code>flake8-docstrings&lt;/code> :&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ pip install flake8-docstrings
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>重新运行检查后，会发现结果中多出了如下错误：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">./__init__.py:1:1: D104 Missing docstring in public package
./md_toc.py:6:1: D103 Missing docstring in public &lt;span class="k">function&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>更多其他功能和插件可查看 &lt;code>flake8&lt;/code> 的&lt;a href="https://flake8.pycqa.org/en/latest/index.html">文档&lt;/a>。&lt;/p>
&lt;p>除了 &lt;code>flake8&lt;/code> 以外，Python 还有以下 Linter 可供选择，它们的用法大同小异，但在检查范围、容忍度等方面有所区别：&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/PyCQA/pylint">Pylint&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/PyCQA/pyflakes">Pyflakes&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pypi.python.org/pypi/PyChecker">Pychecker&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pypi.python.org/pypi/pep8">Pep8&lt;/a>&lt;/li>
&lt;/ul>
&lt;h2 id="static-type-checker">Static Type Checker&lt;/h2>
&lt;p>Python 从 &lt;a href="https://www.python.org/dev/peps/pep-0484/">PEP 484&lt;/a> 引入 &lt;code>Type Hints&lt;/code> （类型提示）以来，配套的工具链生态也在逐渐成熟，出现了如 &lt;code>mypy&lt;/code>、 &lt;code>pyright&lt;/code> 等静态类型检查工具。&lt;/p>
&lt;p>它们可以根据 Python 代码中的类型提示进行静态类型检查，不需要运行程序就可以找到程序中的错误。而且如果有遗留代码不好处理，还可以在程序中混合使用动态和静态类型。&lt;/p>
&lt;p>我们以 &lt;code>mypy&lt;/code> 做简单示例，假设我们有以下代码：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="c1"># test_mypy.py&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">greeting&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">name&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">-&amp;gt;&lt;/span> &lt;span class="nb">str&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="s1">&amp;#39;Hello &amp;#39;&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">name&lt;/span>
&lt;span class="n">greeting&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>通过 &lt;code>pip&lt;/code> 安装 &lt;code>mypy&lt;/code> :&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ pip install mypy
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>对该文件运行检查：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ mypy test_mypy.py
test_mypy.py:4: error: Argument &lt;span class="m">1&lt;/span> to &lt;span class="s2">&amp;#34;greeting&amp;#34;&lt;/span> has incompatible &lt;span class="nb">type&lt;/span> &lt;span class="s2">&amp;#34;int&amp;#34;&lt;/span>&lt;span class="p">;&lt;/span> expected &lt;span class="s2">&amp;#34;str&amp;#34;&lt;/span>
Found &lt;span class="m">1&lt;/span> error in &lt;span class="m">1&lt;/span> file &lt;span class="o">(&lt;/span>checked &lt;span class="m">1&lt;/span> &lt;span class="nb">source&lt;/span> file&lt;span class="o">)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在检查结果中， &lt;code>mypy&lt;/code> 提示我们在调用 &lt;code>greeting()&lt;/code> 时传入的参数类型出错。&lt;/p>
&lt;h3 id="类型提示带来的好处">类型提示带来的好处&lt;/h3>
&lt;p>静态类型检查工具可以帮助我们像静态语言一样在运行代码之前就捕获到某些错误，但需要我们在程序中加入大量的类型提示才能完整发挥其作用。虽然稍微加大了工作量，但引入类型提示还会带来以下好处：&lt;/p>
&lt;ul>
&lt;li>相比传统的 &lt;a href="https://link.zhihu.com/?target=https%3A//realpython.com/documenting-python-code/">docstrings&lt;/a>，类型提示配合良好的命名既能作为解释文档，也能用于自动检查。&lt;/li>
&lt;li>可以使 IDE 通过类型推断提供更好的代码补全和提示功能。&lt;/li>
&lt;li>强制你去思考动态语言程序的类型可能会帮助你构建更清晰的代码架构。&lt;/li>
&lt;/ul>
&lt;h2 id="autoformatter">Autoformatter&lt;/h2>
&lt;p>Autoformatter （自动格式化器）顾名思义是可以将代码按特定规则自动格式化的一类工具。Linter 可以帮助我们发现代码中的格式错误和风格问题，但并不会自动纠正，因此我们还需要借助自动格式化器，进一步将我们从重复琐碎的手动修改中解放出来。&lt;/p>
&lt;p>Python 中有 &lt;code>black&lt;/code> 、 &lt;code>yapf&lt;/code>、 &lt;code>autopep8&lt;/code>、 &lt;code>isort&lt;/code> 等众多格式化工具，除了整体上遵循 PEP8 以外，各自都有不同的风格规范和适用范围，我们可以根据自己的喜好进行选择。&lt;/p>
&lt;p>以 &lt;code>black&lt;/code> 和下面这段代码为例：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="c1"># test_black.py&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">f&lt;/span> &lt;span class="p">(&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">[&lt;/span> &lt;span class="nb">int&lt;/span> &lt;span class="p">])&lt;/span> &lt;span class="p">:&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">37&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">42&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">u&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">y&lt;/span>&lt;span class="o">**&lt;/span>&lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">very_important_function&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">template&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="n">variables&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="nb">file&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">PathLike&lt;/span>&lt;span class="p">,&lt;/span>&lt;span class="n">debug&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nb">bool&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="bp">False&lt;/span>&lt;span class="p">,):&lt;/span>
&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;Applies `variables` to the `template` and writes to `file`.&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span class="k">with&lt;/span> &lt;span class="nb">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">file&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;w&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>首先通过 &lt;code>pip&lt;/code> 安装 &lt;code>black&lt;/code>：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ pip install black
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后对需要格式化的文件或整个目录的路径执行 &lt;code>black&lt;/code> 命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ black test_black.py
reformatted /Users/waynerv/Repos/github-markdown-toc/gfm_toc/__init__.py
reformatted /Users/waynerv/Repos/github-markdown-toc/gfm_toc/md_toc.py
All &lt;span class="k">done&lt;/span>! ✨ 🍰 ✨
&lt;span class="m">2&lt;/span> files reformatted.
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>black&lt;/code> 会首先检查出不符合其规范的文件，然后编辑文件完成修改，并输出修改的文件路径及数量。格式化后的文件内容如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="c1"># test_black.py&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">f&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="n">a&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">List&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">int&lt;/span>&lt;span class="p">]):&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="mi">37&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">a&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">42&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">u&lt;/span> &lt;span class="p">:&lt;/span> &lt;span class="n">y&lt;/span> &lt;span class="o">**&lt;/span> &lt;span class="mi">3&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="k">def&lt;/span> &lt;span class="nf">very_important_function&lt;/span>&lt;span class="p">(&lt;/span>
&lt;span class="n">template&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">str&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="o">*&lt;/span>&lt;span class="n">variables&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nb">file&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">os&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">PathLike&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="n">debug&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="nb">bool&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="bp">False&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="p">):&lt;/span>
&lt;span class="s2">&amp;#34;&amp;#34;&amp;#34;Applies `variables` to the `template` and writes to `file`.&amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;span class="k">with&lt;/span> &lt;span class="nb">open&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nb">file&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;w&amp;#34;&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="k">as&lt;/span> &lt;span class="n">f&lt;/span>&lt;span class="p">:&lt;/span>
&lt;span class="o">...&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>black&lt;/code> 号称「不妥协的代码格式化器」，其不妥协体现在基本没有可供自定义的选项，要么全盘接受它的代码风格，要么就不用它。如果你或者你的团队能够接受它的风格，使用 &lt;code>black&lt;/code> 可以节省很多花在代码风格上的精力和时间（再也不用争论某种风格孰优孰劣了）。&lt;/p>
&lt;p>实践中我们可以对最大行长度以及引号格式化选项做一些调整，方法是在执行 &lt;code>black&lt;/code> 的项目根目录添加 &lt;code>pyproject.tomal&lt;/code> 文件，并写入以下内容:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-ini" data-lang="ini">&lt;span class="k">[tool.black]&lt;/span>
&lt;span class="na">line-length&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">120&lt;/span>
&lt;span class="na">skip-string-normalization&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="s">true&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="ide-的自带工具">IDE 的自带工具&lt;/h3>
&lt;p>现代的 IDE 和编辑器基本都会自带 Linter 和格式化等功能，比如 &lt;code>PyCharm&lt;/code> 就可以通过 &lt;code>⌥ ⌘ L&lt;/code> 快捷键格式化当前文件的代码，这样的话我们还有必要手动集成这些第三方工具吗？答案当然是有必要，我们以第三方和 IDE 自带的代码工具作对比：&lt;/p>
&lt;ul>
&lt;li>自带工具对环境依赖程度很高，必须要有特定的二进制包及配置文件才能执行；而使用与项目相同语言实现的第三方工具，可以直接作为项目的开发依赖，配置也能很方便地整合到项目本身的配置文件中（如&lt;code>pyproject.toml&lt;/code>、&lt;code>tox.ini&lt;/code>等），且通常都可以很快地集成到不同 IDE 中。&lt;/li>
&lt;li>自带工具只能在 IDE 的图形界面中手动执行；而第三方工具只要有基础的代码运行环境就可以执行，因此我们可以把它们很方便的集成到 Hooks、CI 中自动化执行。&lt;/li>
&lt;li>自带工具并不一定严格遵循 PEP8 等通用规范，而且不方便在协作成员中分享配置，话说回来，假如你用 &lt;code>PyCharm&lt;/code> 但你的同事用 &lt;code>VSCode&lt;/code> 呢？&lt;/li>
&lt;/ul>
&lt;p>在接下来的 Hooks 和 Pipeline 两节内容中，你将进一步认识到集成第三方工具带来的优势。&lt;/p>
&lt;h2 id="hooks">Hooks&lt;/h2>
&lt;p>在上文中我们介绍了很多保障质量的工具，但在日常编码中，我们总不能每一次提交代码前，都把这些工具手动执行一遍吧？这看上去不是高效的做法，庆幸地是我们有现成途径解决这些问题。&lt;/p>
&lt;h3 id="git-hooks">Git Hooks&lt;/h3>
&lt;p>Git 可以在仓库中发生特定事件时自动运行自定义的脚本，这些自定义脚本即称为 &lt;code>hooks&lt;/code>。 它们让你可以在开发周期的关键点触发可定制的动作，比如每次执行提交前都执行一次 &lt;code>flake8&lt;/code> 命令。大部分其他的版本控制系统也会提供类似的功能。&lt;/p>
&lt;p>&lt;code>hooks&lt;/code> 保存在 Git 仓库的 &lt;code>.git/hooks&lt;/code> 目录中，它可以是普通的 shell 脚本，也可以是 Python、Ruby 等语言的可执行脚本，因此我们可以很方便地将常用工具集成到 &lt;code>hooks&lt;/code> 中。 &lt;code>hooks&lt;/code> 通常按客户端和服务端分为两大类，常用的客户端类有 &lt;code>pre-commit&lt;/code> 、 &lt;code>prepare-commit-msg&lt;/code>、 &lt;code>commit-msg&lt;/code>、 &lt;code>post-commit&lt;/code>、 &lt;code>pre-rebase&lt;/code> 等 &lt;code>hooks&lt;/code>，它们分别在名称所代表的事件触发时运行。&lt;/p>
&lt;p>以 &lt;code>pre-commit&lt;/code> 为例，该 &lt;code>hooks&lt;/code> 在输入提交信息前运行。 它可以检查即将提交的快照，如果该 &lt;code>hooks&lt;/code> 以非零值退出，Git 将放弃此次提交，我们可以利用它来检查提交的代码风格是否正确（运行例如 &lt;code>flake8&lt;/code>、 &lt;code>black&lt;/code> 等程序）、是否引入安全风险等等。整个流程示意如下：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2020-01-04-pre-commit-workflow.png" alt="2020-01-04-pre-commit-workflow">&lt;/p>
&lt;p>接下来我们将展示，如何将上文介绍的众多工具快速地集成到 &lt;code>pre-commit hooks&lt;/code> 中。&lt;/p>
&lt;h3 id="pre-commit">pre-commit&lt;/h3>
&lt;p>&lt;code>pre-commit&lt;/code> 是一个用于管理和维护多种语言 &lt;code>pre-commit hooks&lt;/code> 的框架，就像 Python 的包管理器 &lt;code>pip&lt;/code> 一样，我们可以通过 &lt;code>pre-commit&lt;/code> 将他人创建并分享的 &lt;code>pre-commit hooks&lt;/code> 安装到自己的项目仓库中。 &lt;code>pre-commit&lt;/code> 大大减少了我们使用 &lt;code>git hooks&lt;/code> 的难度，你只需要在配置文件中指定想要的 &lt;code>hooks&lt;/code>，它会替你安装任意语言编写的 &lt;code>hooks&lt;/code> 并解决环境依赖问题，然后在每次提交前执行。&lt;/p>
&lt;p>&lt;code>pre-commit&lt;/code> 的简单使用方法如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>通过 &lt;code>pip&lt;/code> 安装 &lt;code>pre-commit&lt;/code>:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ pip install pre-commit
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>pre-commit&lt;/code> 是面向多语言的，因此它还支持通过 &lt;code>homebrew&lt;/code> 等方式安装。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>添加配置文件。&lt;/p>
&lt;p>你需要创建一个名为 &lt;code>.pre-commit-config.yml&lt;/code> 的文件，通常放在项目根目录下，在配置文件中我们按特定格式添加需要运行的 &lt;code>hooks&lt;/code> 并指定参数，示例如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">repos&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">repo&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https://github.com/psf/black&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">rev&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">20.&lt;/span>&lt;span class="l">8b1&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">hooks&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">id&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">black&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">language_version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">python3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">exclude&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">^migrations/|^uploads/|^scripts/|^logs/|^docs/|^dist/|^build/&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">repo&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https://github.com/pycqa/flake8&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">rev&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">3.8.4&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">hooks&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">id&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">flake8&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">exclude&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">^migrations/|^uploads/|^scripts/|^logs/|^docs/|^dist/|^build/&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">repo&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">https://github.com/pre-commit/pre-commit-hooks&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">rev&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">v3.3.0&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">hooks&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">id&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">check-added-large-files&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">args&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w"> &lt;/span>--&lt;span class="l">maxkb=512 ]&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在该示例文件中，我们添加了 &lt;code>black&lt;/code> 、 &lt;code>flake8&lt;/code> 以及一个检查是否添加了大体积文件到 Git 的 &lt;code>hooks&lt;/code>，还分别指定了语言版本、跳过检查路径等选项。&lt;/p>
&lt;p>配置文件的选项含义参见 &lt;a href="https://pre-commit.com/#plugins">https://pre-commit.com/#plugins&lt;/a>，所有支持安装的 &lt;code>hooks&lt;/code> 列表参见&lt;a href="https://pre-commit.com/hooks.html">https://pre-commit.com/hooks.html&lt;/a>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安装 &lt;code>git hook&lt;/code> 脚本。在配置文件所在的根目录运行命令：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ pre-commit install
pre-commit installed at .git/hooks/pre-commit
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>这会在 &lt;code>.git/hooks&lt;/code> 文件夹中创建一个 &lt;code>pre-commit&lt;/code> 脚本文件，并在接下来你每一次提交之前运行！现在我们可以尝试提交一次代码了。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>（可选步骤）对所有文件运行 &lt;code>hooks&lt;/code>。&lt;/p>
&lt;p>通常 &lt;code>pre-commit&lt;/code> 只会在触发 &lt;code>git hooks&lt;/code> 时对发生更改的文件运行，但我们也可以手动对当前仓库的所有文件运行：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ pre-commit run --all-files
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> Initializing environment &lt;span class="k">for&lt;/span> https://github.com/psf/black.
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> Initializing environment &lt;span class="k">for&lt;/span> https://github.com/pycqa/flake8.
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> Initializing environment &lt;span class="k">for&lt;/span> https://github.com/pre-commit/pre-commit-hooks.
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> Installing environment &lt;span class="k">for&lt;/span> https://github.com/psf/black.
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> Once installed this environment will be reused.
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> This may take a few minutes...
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> Installing environment &lt;span class="k">for&lt;/span> https://github.com/pycqa/flake8.
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> Once installed this environment will be reused.
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> This may take a few minutes...
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> Installing environment &lt;span class="k">for&lt;/span> https://github.com/pre-commit/pre-commit-hooks.
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> Once installed this environment will be reused.
&lt;span class="o">[&lt;/span>INFO&lt;span class="o">]&lt;/span> This may take a few minutes...
black....................................................................Failed
- hook id: black
- files were modified by this hook
reformatted /.../setup.py
reformatted /.../test/generate_toc_test.py
All &lt;span class="k">done&lt;/span>! ✨ 🍰 ✨
&lt;span class="m">2&lt;/span> files reformatted, &lt;span class="m">2&lt;/span> files left unchanged.
flake8...................................................................Passed
Check &lt;span class="k">for&lt;/span> added large files..............................................Passed
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>结果显示我们有文件未通过 &lt;code>black&lt;/code> 检查，但 &lt;code>black&lt;/code> 同时也帮我们自动进行了格式化，因此只需要暂存并重新提交这些文件即可。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h3 id="pre-commit-hooks-的限制">&lt;code>pre-commit hooks&lt;/code> 的限制&lt;/h3>
&lt;p>使用 &lt;code>pre-commit&lt;/code> ，我们可以很方便的将丰富多样的代码工具集成到 Git 的工作流中，这很大程度上提高了我们的效率，但 &lt;code>pre-commit hooks&lt;/code> 本身存在以下限制：&lt;/p>
&lt;ul>
&lt;li>客户端 &lt;code>hooks&lt;/code> 并不会随代码库一起被复制，我们必须在本地仓库通过 &lt;code>pre-commit install&lt;/code> 执行安装之后 &lt;code>hooks&lt;/code> 才会生效。&lt;/li>
&lt;li>使用 &lt;code>git commit --no-verify&lt;/code> 即可绕过所有的 &lt;code>pre-commit hooks&lt;/code>。&lt;/li>
&lt;/ul>
&lt;p>&lt;code>pre-commit&lt;/code> 解决了在本地集成代码工具的问题，但在团队合作的场景下，我们希望有一种机制可以在服务器端对所有成员推送的代码进行检查，施加特定的约束，这时候就需要用到 Pipelines 了。&lt;/p>
&lt;h2 id="pipelines">Pipelines&lt;/h2>
&lt;p>首先我们需要了解 CI/CD 这一概念。&lt;/p>
&lt;h3 id="cicd">CI/CD&lt;/h3>
&lt;p>CI（Continuous Integration，持续集成）是一种软件实践，它要求我们频繁地向共享仓库提交代码。更频繁地提交代码可以更快地发现错误，减少我们在发现错误时需要调试的代码量，也使得团队不同成员间的变更更容易合并。CI 可以节省我们调试错误或解决合并冲突的时间，让我们有更多的时间来编写代码。&lt;/p>
&lt;p>当提交代码到共享仓库时，我们需要对每一次提交的代码进行构建和测试，以确保提交不会引入错误。这些测试既包括上文提到的 Linter，也包括安全性检查、测试覆盖率、功能测试和其他自定义检查。我们将需要一个 CI 服务器作为 Runner 以运行对提交代码的构建和检查。&lt;/p>
&lt;p>CD（Continuous Deployment，持续部署）是 CI 的下一步。我们不仅在每次推送代码到共享代码库时进行构建和测试，还会在不需要任何人工干预的情况下，自动部署代码到生产环境。此外还有Continuous Delivery （持续交付），它和持续部署的区别在于需要人工干预才会执行部署。&lt;/p>
&lt;h3 id="pipeline">Pipeline&lt;/h3>
&lt;p>Pipeline 是持续集成、交付和部署的顶层具象化组件，它由顺序执行的阶段（stage）以及每个阶段中并行的任务（job）组成。一个简单的 pipeline 如下图所示：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2020-01-04-pipelines.png" alt="2020-01-04-pipelines">&lt;/p>
&lt;p>首先并行地执行 &lt;code>build&lt;/code> 阶段的所有任务（&lt;code>build_a&lt;/code> 和 &lt;code>build_b&lt;/code>），所有任务成功后继续执行下一阶段的任务，以此类推。pipeline 还能定义成按更复杂的逻辑规则运行。&lt;/p>
&lt;p>下面我们以 GitLab CI 为例，展示如何配置一个 pipeline，并在测试阶段执行上文介绍的检查工具，解决不能对团队成员提交代码进行强制约束的问题。&lt;/p>
&lt;h3 id="gitlab-ci-示例">GitLab CI 示例&lt;/h3>
&lt;h4 id="配置-runner">配置 Runner&lt;/h4>
&lt;p>首先我们需要配置一个运行任务的服务器作为 Runner，这需要我们有可用的服务器主机（也可以使用本地的开发机器或购买 GitLab 提供的 Runner）。配置 Runner 整体分两步：&lt;/p>
&lt;ul>
&lt;li>在主机上&lt;a href="https://docs.gitlab.com/runner/install/">安装 GitLab Runner&lt;/a>，GitLab Runner 是一个用于 GitLab CI/CD 并在主机上管理、执行 pipeline 任务的应用。对于不同的操作系统与架构，具体的安装步骤也有很大区别，详情参见文档。&lt;/li>
&lt;li>为项目（或项目组）&lt;a href="https://docs.gitlab.com/runner/register/">注册 Runner&lt;/a>。这一步首先需要从 GitLab 项目主页的 &lt;strong>Settings &amp;gt; CI/CD&lt;/strong> &lt;strong>&amp;gt; Runners settings&lt;/strong> 获取项目的 URL 和注册令牌，然后在 Runner 所在的机器运行 &lt;code>register&lt;/code> 命令使用 URL 和令牌完成注册，并选择合适的 Runner 类型，详细步骤参见文档。&lt;/li>
&lt;/ul>
&lt;p>配置完成后，我们将可以在 &lt;strong>Runners settings&lt;/strong> 页面查看可用的 Runner 和状态：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2020-01-04-runner-status.png" alt="2020-01-04-runner-status">&lt;/p>
&lt;h4 id="创建-gitlabyml">创建 &lt;code>.gitlab.yml&lt;/code>&lt;/h4>
&lt;p>我们将在项目根目录创建一个配置 pipeline 的 &lt;code>.gitlab.yml&lt;/code> 文件，GitLab 将在每一次我们推送代码到共享仓库时，读取该文件中的定义和指令，创建一条不同阶段及任务组成的 pipeline，并将阶段中的任务派发给可用的 Runner 执行。我们以如下 &lt;code>.gitlab.yml&lt;/code> 文件为例：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;span class="lnt">33
&lt;/span>&lt;span class="lnt">34
&lt;/span>&lt;span class="lnt">35
&lt;/span>&lt;span class="lnt">36
&lt;/span>&lt;span class="lnt">37
&lt;/span>&lt;span class="lnt">38
&lt;/span>&lt;span class="lnt">39
&lt;/span>&lt;span class="lnt">40
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">before_script&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">python --version&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">pip install -r requirements-ci.txt&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">stages&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">Pre-commit Hooks&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">Static Analysis&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">pre-commit&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">stage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Pre-commit Hooks&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">variables&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">PRE_COMMIT_HOME&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${CI_PROJECT_DIR}/.cache/pre-commit&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">cache&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">20201116dash&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">paths&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">${PRE_COMMIT_HOME}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">pre-commit run --all-files&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">mypy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">stage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Static Analysis&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">allow_failure&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">only&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">refs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">master&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">pwd&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">ls -l&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">python -m mypy app&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">flake8&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">stage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Static Analysis&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">pwd&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">python -m flake8&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">git-lint&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">stage&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Static Analysis&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">script&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">git log -1 --pretty=%B | gitlint --contrib=CT1 --ignore=body-is-missing&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在这个文件中，我们定义了：&lt;/p>
&lt;ul>
&lt;li>Runner 应该执行的任务的结构和顺序。&lt;/li>
&lt;li>遇到特定条件时，Runner 应做出的决定。&lt;/li>
&lt;/ul>
&lt;p>上面的示例定义了如下 pipeline：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2020-01-04-pipeline-graph.png" alt="2020-01-04-pipeline-graph">&lt;/p>
&lt;ul>
&lt;li>&lt;code>before_script&lt;/code>关键字定义了在每个任务前执行的一组命令，我们通过这里设置的命令安装运行 pipeline 所需的依赖。&lt;/li>
&lt;li>&lt;code>stage&lt;/code> 关键字定义了 &lt;code>Pre-commit Hooks&lt;/code> 和 &lt;code>Static Analysis&lt;/code> 两个阶段。&lt;/li>
&lt;li>之后则定义了 &lt;code>pre-commit&lt;/code> 、 &lt;code>git-lint&lt;/code>、 &lt;code>mypy&lt;/code> 和 &lt;code>flake8&lt;/code> 等多个任务及所属阶段。&lt;/li>
&lt;li>每个任务中通过 &lt;code>script&lt;/code> 关键字定义该任务所运行的脚本命令。&lt;/li>
&lt;li>在 &lt;code>pre-commit&lt;/code> 任务中，我们成功地将上一节介绍的 &lt;code>pre-commit&lt;/code> 放在服务端运行，这能确保对任何人提交的代码都会运行原先只在本地生效的 &lt;code>pre-commit hooks&lt;/code>。我们还通过&lt;a href="https://docs.gitlab.com/ee/ci/variables/predefined_variables.html">预定义变量&lt;/a>和 &lt;code>cache&lt;/code> 关键字缓存运行任务所需的文件以加快执行速度。&lt;/li>
&lt;li>在 &lt;code>mypy&lt;/code> 任务中，我们通过 &lt;code>allow_failure&lt;/code> 关键字更改了任务成功才会进入下一阶段这一默认行为，并通过 &lt;code>only&lt;/code> 关键字限制其只对 &lt;code>master&lt;/code> 分支的提交执行。&lt;/li>
&lt;/ul>
&lt;p>关于 &lt;code>.gitlab.yml&lt;/code> 的更多说明请参阅 &lt;a href="https://docs.gitlab.com/ee/ci/yaml/README.html">GitLab CI/CD pipeline 配置参考手册&lt;/a> 以及 &lt;a href="https://docs.gitlab.com/ee/ci/examples/README.html">GitLab CI/CD 示例&lt;/a>。&lt;/p>
&lt;h4 id="查看-pipeline-的运行状态">查看 pipeline 的运行状态&lt;/h4>
&lt;p>现在当我们推送新的代码到共享仓库时，一个新的 pipeline 会被触发运行。我们可以通过以下途径在 GitLab 仓库查看 pipeline 的运行状态：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>进入 &lt;strong>CI/CD &amp;gt; Pipelines&lt;/strong>。将展示一个包含两个阶段的 pipeline（当前状态为已通过）。&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2020-01-04-pipeline-entry.png" alt="2020-01-04-pipeline-entry">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>点击 pipeline 的 ID 即可查看该 pipeline 的运行示意图：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2020-01-04-pipeline-graph.png" alt="2020-01-04-pipeline-graph">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>点击一个任务名称，可查看该任务的详细运行信息：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2020-01-04-job-detail.png" alt="2020-01-04-job-detail">&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>以上即为一个完整的 GitLab CI pipeline 示例。在该 pipeline 中，我们会在每一次提交代码后：&lt;/p>
&lt;ul>
&lt;li>对所有文件运行集成了众多 &lt;code>hooks&lt;/code> 的 &lt;code>pre-commit&lt;/code>，确保代码已在本地通过了 &lt;code>pre-commit&lt;/code> 检查。&lt;/li>
&lt;li>单独执行 &lt;code>mypy&lt;/code> 、&lt;code>git-lint&lt;/code> 等检查工具。&lt;/li>
&lt;li>还能够执行打包、运行测试、安全检查等更多更复杂的任务。&lt;/li>
&lt;/ul>
&lt;p>接下来我们将通过 GitHub Actions 为例，展示如何运行一个简单的 CD pipeline。&lt;/p>
&lt;h3 id="github-cd-示例">GitHub CD 示例&lt;/h3>
&lt;h4 id="和-gitlab-cicd-的区别">和 GitLab CI/CD 的区别&lt;/h4>
&lt;p>GitHub Actions 是 GitHub 在 2018年10月推出的持续集成服务，它和上文介绍的 GitLab CI 原理和使用方法基本相同，但存在以下区别：&lt;/p>
&lt;ul>
&lt;li>术语定义有所不同，GitHub Actions 有以下组成部分：
&lt;ol>
&lt;li>&lt;strong>workflow&lt;/strong> （工作流程）：持续集成一次运行的过程，即 GitLab 中的 pipeline。&lt;/li>
&lt;li>&lt;strong>job&lt;/strong> （任务）：一个 workflow 由一个或多个 jobs 构成，类似于 GitLab 中的 stage，但默认在不同的 Runner 并行执行，也可以设置为顺序执行。&lt;/li>
&lt;li>&lt;strong>step&lt;/strong>（步骤）：每个 job 由多个 step 构成，类似于 GitLab 中的 job，但 step 要么是一行命令，要么就是一个action，step 之间按顺序执行且能够共享数据。&lt;/li>
&lt;li>&lt;strong>action&lt;/strong> （动作）：你可以将多个脚本命令封装成一个 action，通过 GitHub 市场分享给其他人，然后在 step 中使用自建或来自社区的 action。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>GitHub 免费提供常见类型的 Runner，因此一般情况不需要再自行配置服务器及注册。&lt;/li>
&lt;li>workflow 的配置文件也是类似于 &lt;code>.gitlab.yml&lt;/code> 的 &lt;code>yaml&lt;/code> 文件，但需要添加到项目根目录的 &lt;code>.github/workflows&lt;/code> 路径中。&lt;/li>
&lt;li>可以很方便地共享或使用他人创建的脚本命令，即 action。&lt;/li>
&lt;/ul>
&lt;p>接下来我将演示如何使用 GitHub Actions 自动发布一个 Hugo 静态站点到 GitHub Pages。&lt;/p>
&lt;h4 id="使用-github-actions-自动发布静态站点">使用 GitHub Actions 自动发布静态站点&lt;/h4>
&lt;p>大致的工作流程如下：&lt;/p>
&lt;ol>
&lt;li>在本地内容仓库开发站点内容，完成后将内容推送到共享仓库。该共享仓库可能是私有的。&lt;/li>
&lt;li>共享仓库接受推送后触发 workflow，执行以下步骤：
&lt;ol>
&lt;li>在 Runner 中拉取提交的内容。&lt;/li>
&lt;li>配置环境并安装指定版本的 Hugo。&lt;/li>
&lt;li>运行 Hugo 根据提交内容生成静态站点。&lt;/li>
&lt;li>将静态文件推送到发布仓库。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>发布仓库在接收到推送内容后会自动更新 Pages 页面。&lt;/li>
&lt;/ol>
&lt;p>GitHub 上有许多这类自动化部署任务的开源 Actions 项目，我们选择了其中一个简单易用的 &lt;a href="https://github.com/peaceiris/actions-hugo#getting-started">GitHub Actions for Hugo&lt;/a>。具体的操作步骤截图和详细配置项可以查看该项目的 &lt;a href="https://github.com/peaceiris/actions-hugo#github-actions-for-hugo">README&lt;/a>。下面简单介绍下配置过程：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在本地内容仓库中添加目录和文件：&lt;code>.github/workflows/gh-pages.yml&lt;/code>，&lt;code>gh-pages.yml&lt;/code> 文件内容如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;span class="lnt">32
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-yaml" data-lang="yaml">&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">github pages&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">push&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">branches&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="l">main &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 每次推送到 main 分支都会触发部署任务&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">deploy&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu-18.04&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/checkout@v2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">submodules&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Fetch Hugo themes (true OR recursive)&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">fetch-depth&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="m">0&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Fetch all history for .GitInfo and .Lastmod&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Setup Hugo&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-hugo@v2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">hugo-version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;0.79.1&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">extended&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Build&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hugo --minify&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deploy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-gh-pages@v3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">deploy_key&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.ACTIONS_DEPLOY_KEY }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">external_repository&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">&amp;lt;USERNAME&amp;gt;/&amp;lt;USERNAME&amp;gt;.github.io &lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 发布仓库名称&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">publish_branch&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">main&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">publish_dir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./public&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>在该配置文件中，我们定义了如下的 workflow：&lt;/p>
&lt;ol>
&lt;li>workflow 名称为 &lt;code>github pages&lt;/code>。&lt;/li>
&lt;li>仅在推送提交到 &lt;code>main&lt;/code> 分支时执行。&lt;/li>
&lt;li>含有一个名为 &lt;code>deploy&lt;/code> 的任务，并需要在&lt;code>ubuntu-18.04&lt;/code>平台的 Runner 执行。&lt;/li>
&lt;li>任务中的第一个步骤使用了名为 &lt;code>actions/checkout@v2&lt;/code> 的 &lt;code>action&lt;/code>，以拉取提交的内容到 Runner。&lt;/li>
&lt;li>第二个步骤使用 &lt;code>peaceiris/actions-hugo@v2&lt;/code> action 配置 Hugo，并指定版本。&lt;/li>
&lt;li>第三个步骤直接执行 &lt;code>hugo --minify&lt;/code> 命令，生成静态站点（默认输出文件到 &lt;code>public&lt;/code> 目录）&lt;/li>
&lt;li>第四个步骤使用 &lt;code>peaceiris/actions-gh-pages@v3&lt;/code> action 将生成的静态文件推送到指定的外部仓库。&lt;/li>
&lt;/ol>
&lt;p>这个 &lt;code>workflow&lt;/code> 基于内容仓库运行，但我们需要将运行过程生成的静态文件推送到发布仓库进行发布，因此还需要在两个仓库中分别设置密钥。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在本地生成 SSH 部署密钥：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">ssh-keygen -t rsa -b &lt;span class="m">4096&lt;/span> -C &lt;span class="s2">&amp;#34;&lt;/span>&lt;span class="k">$(&lt;/span>git config user.email&lt;span class="k">)&lt;/span>&lt;span class="s2">&amp;#34;&lt;/span> -f gh-pages -N &lt;span class="s2">&amp;#34;&amp;#34;&lt;/span>
&lt;span class="c1"># 将在当前目录生成如下密钥文件:&lt;/span>
&lt;span class="c1"># gh-pages.pub (公钥)&lt;/span>
&lt;span class="c1"># gh-pages (私钥)&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>在 GitHub 分别进入内容仓库和发布仓库的 &lt;code>Settings&lt;/code> 页面：&lt;/p>
&lt;ul>
&lt;li>将公钥 &lt;code>gh-pages.pub&lt;/code> 作为 &lt;code>Secret&lt;/code> 添加到内容仓库，并设置 &lt;code>Name&lt;/code> 为 &lt;code>ACTIONS_DEPLOY_KEY&lt;/code>。&lt;/li>
&lt;li>将私钥 &lt;code>gh-pages&lt;/code> 作为 &lt;code>Deploy Key&lt;/code> 添加到发布仓库，并设置为 &lt;code>Allow write access&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>接下来我们测试一下效果。&lt;/p>
&lt;p>在本地内容仓库做一些更改，预览效果后提交并推送，然后在共享仓库的 &lt;strong>GitHub Actions&lt;/strong> 页面检查相应 &lt;code>workflow&lt;/code> 的运行状态与详细结果：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/2020-01-04-actions-page.png" alt="2020-01-04-actions-page">&lt;/p>
&lt;p>运行成功后，很快发布仓库将新增一个由该 &lt;code>workflow&lt;/code> 创建的提交，相应的 GitHub Pages 也会更新相应的内容。&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本文中，我们围绕保障代码质量这一目的：&lt;/p>
&lt;ol>
&lt;li>首先介绍了 Linter、Static Type Checker、Autoformatter 三种工具并各展示了一个代表性工具的使用方法。&lt;/li>
&lt;li>将这些工具通过 &lt;code>pre-commit&lt;/code> 集成到 &lt;code>git hooks&lt;/code> 中，在代码开发工作流中自动执行。&lt;/li>
&lt;li>介绍了CI/CD，并以 GitLab CI pipeline 为例将以上检查部署到共享仓库，在每次代码提交后自动执行。&lt;/li>
&lt;li>顺便介绍了一个通过 GitHub Actions 实现持续部署的示例，演示了 GitHub 持续集成服务的基本用法。&lt;/li>
&lt;/ol>
&lt;p>经过简单几步的一次性配置，你就可以拥有一套高度自动化的代码质量工具工作流程。但工具只是保障代码质量众多环节中最容易发力，见效快，但作用也很有限的一环。真正实现保证代码质量这一目标任重而道远，还需要我们在个人和团队这两个方面认识到代码质量的重要性，并不断践行各种代码质量设计与活动。&lt;/p>
&lt;p>&lt;em>&lt;strong>更新&lt;/strong>&lt;/em>：&lt;/p>
&lt;ul>
&lt;li>如果你觉得手动集成以上工具过于繁琐，可以尝试我制作的 Python 项目模板 &lt;a href="https://github.com/waynerv/cookiecutter-pypackage">Cookiecutter PyPackage&lt;/a>，使用方式很简单，使用了 GitHub Actions 自动执行测试、预览和发布。&lt;/li>
&lt;li>如果你想学习/提高自己的 Python 技能，我推荐一个学习网站 &lt;a href="https://jobtensor.com/Tutorial/Python/en/Introduction">https://jobtensor.com/Tutorial/Python/en/Introduction&lt;/a>，它们的内容很棒而且完全免费。&lt;/li>
&lt;/ul>
&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Lint_(software)">Linter-Wikipedia&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://flake8.pycqa.org/en/latest/">Flake8&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mypy.readthedocs.io/en/stable/">Mypy&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://realpython.com/python-type-checking">Python Type Checking (Guide)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://black.readthedocs.io/en/stable/">Black&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks">Customizing Git - Git Hooks&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://pre-commit.com/">pre-commit&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.github.com/en/free-pro-team@latest/actions/guides/about-continuous-integration">About continuous integration&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.gitlab.com/ee/ci/README.html">GitLab CI/CD&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.github.com/en/free-pro-team@latest/actions/quickstart">Quickstart for GitHub Actions&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://docs.github.com/en/free-pro-team@latest/actions/learn-github-actions/introduction-to-github-actions">Introduction to GitHub Actions&lt;/a>&lt;/li>
&lt;li>&lt;a href="http://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html">GitHub Actions 入门教程&lt;/a>&lt;/li>
&lt;/ul></content><category scheme="https://www.waynerv.com/categories/%E5%B7%A5%E5%85%B7/" term="工具" label="工具"/><category scheme="https://www.waynerv.com/tags/%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F/" term="代码质量" label="代码质量"/><category scheme="https://www.waynerv.com/tags/ci/" term="CI" label="CI"/></entry><entry><title type="text">使用 Hugo 和 GitHub Pages 部署个人博客</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/setup-blog-with-hugo-and-github-pages/"/><id>https://www.waynerv.com/posts/setup-blog-with-hugo-and-github-pages/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2020-12-24T21:47:50+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">作为一个已经入行了一年多的（老）技术人，维护一个看得过去的个人博客是很有必要的。 刚学编程的时候，还开源过一个基于 Flask 和 MongoDB 的博客项目……</summary><content type="html">&lt;p>作为一个已经入行了一年多的（老）技术人，维护一个看得过去的个人博客是很有必要的。&lt;/p>
&lt;p>刚学编程的时候，还开源过一个基于 Flask 和 MongoDB 的&lt;a href="https://github.com/waynerv/originblog">博客项目&lt;/a>，但后面就没怎么使用和维护了，除开主观上的懒，还因为：&lt;/p>
&lt;ul>
&lt;li>自建博客绕不开主机和域名，这是一笔持续的经济成本。国内的主机往往是第一年割肉第二年宰猪，国外的主机访问延迟很高。&lt;/li>
&lt;li>国内主机更麻烦的是还需要定期备案，第一个博客就是因为备案到期中断了。&lt;/li>
&lt;li>博客功能的实现技术难度不大，开始还有一些新鲜感，有了工作经验后就很难有兴趣继续维护了。&lt;/li>
&lt;/ul>
&lt;p>刚好最近有写一些文章的打算，决定找个简单、省事（最后发现并没有）且不花钱的路子把博客再搞起来，一番研究后，选择了生成静态站点发布到 GitHub Pages 的方案。&lt;/p>
&lt;h2 id="工作流">工作流&lt;/h2>
&lt;p>整个方案的流程大致如下：&lt;/p>
&lt;ol>
&lt;li>用 Markdown 格式写作文章。&lt;/li>
&lt;li>使用生成器将 markdown 文件转换成静态站点。&lt;/li>
&lt;li>将生成的站点内容推送到 GitHub 并发布。&lt;/li>
&lt;/ol>
&lt;p>写 markdown 没啥好说的，什么编辑器都可以，我一直用的是 Typora。&lt;/p>
&lt;p>静态站点生成器我选择了 Hugo，原因是最近刚好在学 Go，此外还有 Gatsby、Jekyll、Hexo等很多选项。&lt;/p>
&lt;p>接下来要做的工作是生成静态站点并通过 GitHub Pages 发布。&lt;/p>
&lt;h2 id="生成静态站点">生成静态站点&lt;/h2>
&lt;p>使用 Hugo 生成静态博客站点非常简单，具体的步骤和用法可以参考官方文档的 &lt;a href="https://gohugo.io/getting-started/quick-start/">Quick Start&lt;/a>。下面简单介绍下整个过程：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>安装 Hugo。&lt;code>macOS&lt;/code> 下可以直接使用 &lt;code>homebrew&lt;/code>安装：&lt;code>brew install hugo&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>创建一个新的站点。这会生成一个特定目录结构的项目文件夹，用来维护所有的站点内容。假设我们想把它命名为 &lt;code>hugo-blog&lt;/code>，则使用以下命令创建并切换到该目录，后续的操作和命令都会在这个根目录下执行：&lt;/p>
&lt;pre>&lt;code>hugo new site hugo-blog
cd hugo-blog
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>安装一个主题。这一步是必需的，否则会因为缺少基础模板无法生成站点。安装主题有 3 种方式，以 &lt;code>eureka&lt;/code> 主题为例：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>直接下载主题的压缩文件，将解压得到的文件夹重命名为主题名称 &lt;code>eureka&lt;/code> 放到 &lt;code>themes/&lt;/code>目录下。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过 &lt;code>git submodule&lt;/code> 安装：&lt;/p>
&lt;pre>&lt;code>git init
git submodule add https://github.com/wangchucheng/hugo-eureka.git themes/eureka
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>通过 &lt;code>Hugo Modules&lt;/code> 安装（这种方式要求本机安装有 &lt;a href="https://golang.org/dl/">Go 1.12&lt;/a> 及以上版本，且只有部分主题支持）：&lt;/p>
&lt;pre>&lt;code>hugo mod init &amp;lt;module_name&amp;gt;
&lt;/code>&lt;/pre>&lt;p>&lt;code>&amp;lt;module_name&amp;gt;&lt;/code> 并不重要，随便起个名字就行。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>安装后需要启用主题，方法是将主题名称写入到根目录下的默认配置文件 &lt;code>config.yml&lt;/code> 中：&lt;/p>
&lt;pre>&lt;code>echo 'theme = &amp;quot;eureka&amp;quot;' &amp;gt;&amp;gt; config.toml
&lt;/code>&lt;/pre>&lt;p>如果是通过 &lt;code>Hugo Modules&lt;/code> 安装，需要把主题名称替换成模块名称：&lt;/p>
&lt;pre>&lt;code>echo 'theme = &amp;quot;github.com/wangchucheng/hugo-eureka&amp;quot;' &amp;gt;&amp;gt; config.toml
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>添加一篇文章。可以直接在 &lt;code>content/posts&lt;/code> 目录下创建 markdown 文件，但需要手动写入一些元信息，因此推荐使用 Hugo 自带的命令：&lt;code>hugo new posts/my-first-post.md&lt;/code>，添加的文件会以如下元信息开头：&lt;/p>
&lt;pre>&lt;code>---
title: &amp;quot;My First Post&amp;quot;
date: 2019-03-26T08:47:11+01:00
draft: true
---
&lt;/code>&lt;/pre>&lt;p>在下方接着写入文章内容即可。注意此时该文件为草稿状态，写作完成后需要改成 &lt;code>draft: false&lt;/code> 才能部署。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>启动 Hugo 预览服务器。Hugo 可以启动一个 Web 服务器，同时构建站点内容到内存中并在检测到文件更改后重新渲染，方便我们在开发环境实时预览对站点所做的更改。&lt;/p>
&lt;pre>&lt;code>hugo server -D
&lt;/code>&lt;/pre>&lt;p>添加 &lt;code>-D&lt;/code> 选项以输出草稿状态的文章，执行成功后可以通过 &lt;code>http://localhost:1313/&lt;/code> 访问站点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>自定义主题配置。站点的配置项默认保存在根目录的 &lt;code>config.toml&lt;/code> 文件中，配置项较多时通常会用主题提供的预设配置文件来替换该文件，还可以通过&lt;code>config&lt;/code> 目录加多个文件的方式来组织配置。默认配置文件如下：&lt;/p>
&lt;pre>&lt;code>baseURL = &amp;quot;http://example.org/&amp;quot; # 发布地址，由主机名以及路径组成
languageCode = &amp;quot;en-us&amp;quot; # 语言代码，中文可以设置为&amp;quot;zh&amp;quot;
title = &amp;quot;My New Hugo Site&amp;quot; # 站点标题
&lt;/code>&lt;/pre>&lt;p>这一步应该是整个过程中最麻烦也是最容易出问题的一步，视乎你选择的主题与想要的功能不同，需要自定义的配置项也不同，数量从几个到上百个不等。有些主题会有详细的文档解释配置过程，有些则一笔带过只能自己去摸索，配置较多时相互间可能还有依赖关系，最好更改一个配置就刷新一次页面确认下结果。&lt;/p>
&lt;p>建议起步时一切从简，花大把时间搞各种花里胡哨的样式和功能，还不如多写几篇文章。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>构建静态页面。站点配置成我们理想的效果之后就可以构建静态页面了：&lt;/p>
&lt;pre>&lt;code>hugo -D
&lt;/code>&lt;/pre>&lt;p>添加 &lt;code>-D&lt;/code> 选项可以在结果中包括草稿内容，默认情况下静态页面会输出到根目录下的 &lt;code>public&lt;/code> 文件夹中。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="通过-github-pages-发布">通过 GitHub Pages 发布&lt;/h2>
&lt;p>这一步 Hugo 的官方文档同样在 &lt;a href="https://gohugo.io/hosting-and-deployment/hosting-on-github/">Host on GitHub&lt;/a> 中进行了详细的介绍，并且还很贴心的提供了自动化操作的 Shell 脚本。&lt;/p>
&lt;p>有两种方式：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>通过个人主页发布：必须创建一个 &lt;code>&amp;lt;USERNAME&amp;gt;.github.io&lt;/code> 仓库来托管生成的静态内容，发布后的域名为 &lt;code>https://&amp;lt;USERNAME&amp;gt;.github.io&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>通过项目主页发布：可以随意创建 &lt;code>&amp;lt;PROJECT_NAME&amp;gt;&lt;/code> 仓库，发布后的域名为 &lt;code>https://&amp;lt;USERNAME&amp;gt;.github.io/&amp;lt;PROJECT_NAME&amp;gt;&lt;/code>。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>视选择的发布方式不同，我们需要将 &lt;code>config.yml&lt;/code> 中的 &lt;code>baseUrl&lt;/code> 设置为不同的值。&lt;/p>
&lt;h3 id="通过个人主页发布">通过个人主页发布&lt;/h3>
&lt;p>建议非特殊情况下使用第 1 种方式，原因是许多主题都不能很好的支持第 2 种，具体来说是将 &lt;code>config.toml&lt;/code> 的 &lt;code>baseURL&lt;/code> 设置为含子路径的地址时，不能正确的处理所有资源的构建位置。我尝试了 3 个主题，均遭遇了不同的问题：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>eureka&lt;/code>: 构建失败，提示 :&lt;/p>
&lt;pre>&lt;code>Error: Error building site: POSTCSS: failed to transform &amp;quot;css/eureka.css&amp;quot; (text/css): resource &amp;quot;css/waynerv.github.io/css/eureka.css_fc3f76d7bee2760c3a903059afc3d9b2&amp;quot; not found in file cache
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>&lt;code>LoveIt&lt;/code>: 构建成功，但除主页以外的文章、分类和标签的页面均提示 404。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>MemE&lt;/code>: 构建成功，但文章中插入的图片加载 404（放在同一文件夹的&lt;code>favicon&lt;/code> 却能正常展示）。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>这个问题我在 &lt;code>eureka&lt;/code> 项目提交了 issue，开发者回复可能是 Hugo 本身的机制所导致，并已经在 Hugo 论坛中提出了此&lt;a href="https://discourse.gohugo.io/t/cached-resources-not-found-in-file-cache-when-baseurl-contains-subdirectory/30182/8">问题&lt;/a>，有兴趣的可以关注后续进展。&lt;/p>
&lt;h3 id="发布步骤">发布步骤&lt;/h3>
&lt;ol>
&lt;li>
&lt;p>在 GitHub 创建个人主页仓库，仓库名称必须设置为 &lt;code>&amp;lt;USERNAME&amp;gt;.github.io&lt;/code>，这个仓库仅存放生成的静态内容。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在 GitHub 创建一个项目仓库 &lt;code>hugo-blog&lt;/code> 并添加为我们本地项目文件夹的远程仓库。这个仓库用来维护站点配置和原始的文章内容。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>假设我们在已经通过上文的步骤在 &lt;code>public&lt;/code> 文件夹中生成了想发布的静态内容，运行：&lt;/p>
&lt;pre>&lt;code>git submodule add -b main https://github.com/&amp;lt;USERNAME&amp;gt;/&amp;lt;USERNAME&amp;gt;.github.io.git public
&lt;/code>&lt;/pre>&lt;p>在 &lt;code>public&lt;/code> 目录中创建一个 git 子模块，之后这个目录将以 &lt;code>https://github.com/&amp;lt;USERNAME&amp;gt;/&amp;lt;USERNAME&amp;gt;.github.io&lt;/code> 作为远程仓库。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>确保配置文件中的 &lt;code>baseUrl&lt;/code> 已经设置为了 &lt;code>&amp;lt;USERNAME&amp;gt;.github.io&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Hugo 为我们接下来的部署操作提供了一个自动化的 Shell 脚本：&lt;/p>
&lt;/li>
&lt;/ol>
&lt;pre>&lt;code>#!/bin/sh
# 任一步骤执行失败都会终止整个部署过程
set -e
printf &amp;quot;\033[0;32mDeploying updates to GitHub...\033[0m\n&amp;quot;
# 构建静态内容
hugo # if using a theme, replace with `hugo -t &amp;lt;YOURTHEME&amp;gt;`
# 切换到 Public 文件夹
cd public
# 添加更改到 git
git add .
# 提交更改
msg=&amp;quot;rebuilding site $(date)&amp;quot;
if [ -n &amp;quot;$*&amp;quot; ]; then
msg=&amp;quot;$*&amp;quot;
fi
git commit -m &amp;quot;$msg&amp;quot;
# 推送到远程仓库
git push origin main
&lt;/code>&lt;/pre>&lt;p>将如上内容保存到 &lt;code>deploy.sh&lt;/code> 文件中，并执行 &lt;code>chmod +x deploy.sh&lt;/code> 为其添加可执行权限。接着执行部署脚本：&lt;/p>
&lt;pre>&lt;code>./deploy.sh
&lt;/code>&lt;/pre>&lt;p>大功告成！稍等几分钟就可以在 &lt;code>https://&amp;lt;USERNAME&amp;gt;.github.io&lt;/code> 看到我们的个人博客了。&lt;/p>
&lt;h3 id="通过-github-actions-自动部署">通过 GitHub Actions 自动部署&lt;/h3>
&lt;p>目前我们的「创作-发布」流程如下：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在项目仓库编辑原始内容并进行版本管理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行自动脚本生成静态站点并推送到个人主页仓库完成发布。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>这套流程已经很流畅，但还有一些改进空间：我们可以使用 &lt;a href="https://github.com/features/actions">GitHub Actions&lt;/a>，在每次向远程的项目仓库推送原始内容更改时自动执行第 2 步进行发布。&lt;/p>
&lt;p>GitHub 上有许多这类自动化部署任务的开源 Actions 项目，我们选择了其中一个简单易用的 &lt;a href="https://github.com/peaceiris/actions-hugo#getting-started">GitHub Actions for Hugo&lt;/a>。具体的操作步骤截图和详细配置项可以查看该项目的 &lt;a href="https://github.com/peaceiris/actions-hugo#github-actions-for-hugo">README&lt;/a>。下面简单介绍下配置过程：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>在项目文件夹中添加目录和文件：&lt;code>.github/workflows/gh-pages.yml&lt;/code>，&lt;code>gh-pages.yml&lt;/code> 文件内容如下：&lt;/p>
&lt;pre>&lt;code>name: github pages
on:
push:
branches:
- main # 每次推送到 main 分支都会触发部署任务
jobs:
deploy:
runs-on: ubuntu-18.04
steps:
- uses: actions/checkout@v2
with:
submodules: true # Fetch Hugo themes (true OR recursive)
fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod
- name: Setup Hugo
uses: peaceiris/actions-hugo@v2
with:
hugo-version: '0.79.1'
extended: true
- name: Build
run: hugo --minify
- name: Deploy
uses: peaceiris/actions-gh-pages@v3
with:
deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }}
external_repository: &amp;lt;USERNAME&amp;gt;/&amp;lt;USERNAME&amp;gt;.github.io # 替换成上文所创建的个人主页仓库
publish_branch: main
publish_dir: ./public
&lt;/code>&lt;/pre>&lt;p>这个文件所定义的 &lt;code>workflow&lt;/code> 基于项目仓库运行，但我们需要将运行过程生成的静态文件推送到个人主页仓库 &lt;code>&amp;lt;USERNAME&amp;gt;.github.io&lt;/code> 完成发布，因此在 &lt;code>Deploy&lt;/code> 任务中按照文档的 &lt;a href="https://github.com/peaceiris/actions-gh-pages#%EF%B8%8F-deploy-to-external-repository-external_repository">Deploy to external repository &lt;code>external_repository&lt;/code>&lt;/a> 一节做了专门的配置。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在本地生成 SSH 部署密钥：&lt;/p>
&lt;pre>&lt;code>ssh-keygen -t rsa -b 4096 -C &amp;quot;$(git config user.email)&amp;quot; -f gh-pages -N &amp;quot;&amp;quot;
# 将在当前目录生成如下密钥文件:
# gh-pages.pub (公钥)
# gh-pages (私钥)
&lt;/code>&lt;/pre>&lt;/li>
&lt;li>
&lt;p>在 GitHub 分别进入项目仓库和个人主页仓库的 &lt;code>Settings&lt;/code> 页面：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>将公钥 &lt;code>gh-pages.pub&lt;/code> 作为 &lt;code>Secret&lt;/code> 添加到项目仓库，并设置 &lt;code>Name&lt;/code> 为 &lt;code>ACTIONS_DEPLOY_KEY&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>将私钥 &lt;code>gh-pages&lt;/code> 作为 &lt;code>Deploy Key&lt;/code> 添加到个人主页仓库，并设置为 &lt;code>Allow write access&lt;/code>。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ol>
&lt;p>接下来我们测试一下效果。&lt;/p>
&lt;p>在本地做一些更改，预览效果后提交并推送，然后在项目仓库的 GitHub Actions 页面检查相应的 &lt;code>workflow&lt;/code> 是否运行成功。不出意外的话，很快个人主页仓库将新增一个由该 &lt;code>workflow&lt;/code> 创建的提交，访问个人博客页面也会发现页面已经更新。&lt;/p>
&lt;h2 id="个人体验">个人体验&lt;/h2>
&lt;p>由于先后选择的 3 个主题均遭遇了上述发布地址不能包含子路径的问题，我在基本按照官方文档操作的前提下，依然花了超过 10 个小时才把&lt;a href="https://waynerv.github.io/">博客&lt;/a>上线，浪费了很多时间在配置主题以及寻找问题的解决方案上。本以为选择了一个简单快捷的省心方案，结果还是免不了过程的一顿踩坑和折腾。&lt;/p>
&lt;p>虽然搭建博客的流程不算省心，但我所遇到的这些问题也算是个例。一切准备就绪后，我们可以像写代码一样写博客，对文章修改提交即自动发布，也不需要考虑博客的样式、后台功能及主机维护等问题，对提升写作效率会有所帮助，可以省下来很多的时间和精力，综合来看体验还是不错的。&lt;/p></content><category scheme="https://www.waynerv.com/categories/%E4%B8%AA%E4%BA%BA/" term="个人" label="个人"/><category scheme="https://www.waynerv.com/tags/%E5%8D%9A%E5%AE%A2/" term="博客" label="博客"/></entry><entry><title type="text">Git 合并操作浅析</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/git-merge-intro/"/><id>https://www.waynerv.com/posts/git-merge-intro/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2020-11-29T07:17:23+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">合并在 Git 中是一个十分常见的操作：整合不同分支之间的更改，或者对远程分支执行 pull 及 push 操作，都需要进行合并。 但对新手来说， git merge 这一命令……</summary><content type="html">&lt;p>合并在 Git 中是一个十分常见的操作：整合不同分支之间的更改，或者对远程分支执行 &lt;code>pull&lt;/code> 及 &lt;code>push&lt;/code> 操作，都需要进行合并。&lt;/p>
&lt;p>但对新手来说， &lt;code>git merge&lt;/code> 这一命令有些令人生畏，因为在不同情况下，执行 &lt;code>merge&lt;/code> 可能会得到不同的结果。这种对于结果的不确定性，使我很长一段时间都不敢主动去使用它，而是依赖 GitHub 的 &lt;code>Pull Request&lt;/code> 或者 GitLab 的 &lt;code>Merge Request&lt;/code> 等可视化界面手动合并。&lt;/p>
&lt;p>为了今后可以放心大胆的 &lt;code>merge&lt;/code>，今天我们就来对 &lt;code>merge&lt;/code> 一探究竟。&lt;/p>
&lt;h2 id="认识合并">认识合并&lt;/h2>
&lt;p>在版本控制系统中，合并是将一组文件中所发生的不同更改进行整合的基础操作。通常来说，我们在使用 Git 时会建立不同的分支，由不同的人对同一组文件执行新增、编辑等操作，最终我们需要合并这些协作的分支，整合所有的更改形成一份文件版本。&lt;/p>
&lt;p>合并一般由 Git 根据算法自动执行，但如果发生了冲突，比如对同一文件的同一处内容执行了不同的更改，则需要我们手动合并。&lt;/p>
&lt;h3 id="递归三路合并算法">递归三路合并算法&lt;/h3>
&lt;p>Git 在自动合并时会使用「&lt;a href="https://en.wikipedia.org/wiki/Merge_(version_control)#Recursive_three-way_merge">递归三路合并&lt;/a>」算法对不同文件进行差异分析，接下来我们简单了解一下该算法。&lt;/p>
&lt;p>首先从「三路合并」算法开始，假设我们有以下提交历史：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/Dec-29-2020-merge.gif" alt="Dec-29-2020 22-40-46">&lt;/p>
&lt;p>上图中我们在 &lt;code>master&lt;/code> 合并了 &lt;code>feature&lt;/code> 分支，现在我们回溯一下合并的过程：&lt;/p>
&lt;p>此时 &lt;code>master&lt;/code> 正指向提交 C，Git 首先找到两个分支最近的唯一共同祖先提交 A，然后分别对 A、C、F 提交的文件快照进行对比，我们下文称呼它们为 A、C、F 文件。接下来 Git 将逐「行」对三个文件的内容进行比较，如果三个文件中有两个文件该行的内容一致，则丢弃 A 文件中该行的内容，保留与 A 文件中不同的内容放到结果文件中。&lt;/p>
&lt;p>具体来说，假如 A、C 内容一致，说明这是在 F 中更改的内容，需要保留该更改；A、F 内容一致同理；假如 C、F 内容一致，说明 C 和 F 都相对于 A 做了同样的更改，同样需要保留。除此之外的内容差异仅剩两种情况：如果 A、C、F 的内容都一致，说明什么都没有发生；如果该行在 A、C、F 的内容都不一致，说明发生了冲突，需要我们手动合并选择需要保留的内容。&lt;/p>
&lt;p>结束对比后 Git 会以最终的结果文件快照创建一个新的 Merge 提交并指向它。&lt;/p>
&lt;p>三路合并算法的基础是找到被合并文件的共同祖先，在一些简单的场景中这还能行的通，但在遇到&lt;a href="https://zh.wikipedia.org/wiki/%E5%90%88%E5%B9%B6_(%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6)#cite_note-2">十字交叉合并（criss-cross merge）&lt;/a>时，不存在唯一的最近共同祖先，如下图：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/20201229152228-criss-cross-merge.png" alt="20201229152228-criss-cross-merge">&lt;/p>
&lt;p>现在我们需要从 &lt;code>main&lt;/code> 分支合并 &lt;code>feature&lt;/code> 分支，即把 C7 合并到 C8，会发现 C8 和 C7 有两个共同祖先，这下怎么办呢？Git 采取的是递归三路合并（Recursive three-way merge），会先合并 C3 和 C5 这两个共同祖先创建一个虚拟的唯一最近祖先（假设为 C9），接着在 C9、C7、C8 之间执行三路合并，如果在合并 C3 和 C5 的过程中又发生没有唯一共同祖先的情况，则递归执行上述过程。&lt;/p>
&lt;p>关于递归三路合并算法我们就了解到这里。&lt;/p>
&lt;h3 id="合并冲突">合并冲突&lt;/h3>
&lt;p>如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就无法自动地合并它们，而是会暂停合并过程，等待你去手动解决冲突。&lt;/p>
&lt;p>首先我们需要找到这些需要解决冲突的文件，使用 &lt;code>git status&lt;/code> 可以查看这些因包含合并冲突而处于未合并状态的文件：&lt;/p>
&lt;pre>&lt;code>$ git status
On branch master
You have unmerged paths.
(fix conflicts and run &amp;quot;git commit&amp;quot;)
Unmerged paths:
(use &amp;quot;git add &amp;lt;file&amp;gt;...&amp;quot; to mark resolution)
both modified: main.py
no changes added to commit (use &amp;quot;git add&amp;quot; and/or &amp;quot;git commit -a&amp;quot;)
&lt;/code>&lt;/pre>&lt;p>手动解决冲突类似于二选一的过程，Git 会在有冲突的文件中加入特殊的标记，看起来像下面这样：&lt;/p>
&lt;pre>&lt;code>&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD:main.py
print(&amp;quot;Hello World&amp;quot;)
=======
print(&amp;quot;World Hello&amp;quot;)
&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; feature:main.py
&lt;/code>&lt;/pre>&lt;p>通过 &lt;code>=======&lt;/code> 进行分割，以 &lt;code>&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt; HEAD:main.py&lt;/code> 标记为上界的上半部分是当前分支 &lt;code>master&lt;/code> 所做的更改，以 &lt;code>&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; feature:main.py&lt;/code> 标记为下界的下半部分是要合并的 &lt;code>feature&lt;/code> 对同一内容所做的不同更改。我们需要编辑文件删除这些标记，仅保留我们需要的内容：&lt;/p>
&lt;pre>&lt;code>print(&amp;quot;Hello World&amp;quot;)
&lt;/code>&lt;/pre>&lt;p>当然也可以不从中选择，而是用一段全新的内容去替换它。&lt;/p>
&lt;p>在解决了所有文件里的冲突之后，需要使用 &lt;code>git add&lt;/code> 暂存这些文件来将其标记为冲突已解决。然后再执行 &lt;code>git commit&lt;/code> 来完成合并提交。 Git 会将解决的这些冲突，加入到上文提到的新增的 Merge 提交里。&lt;/p>
&lt;h3 id="快进合并">快进合并&lt;/h3>
&lt;p>也有些时候，我们在执行了合并操作后，会发现并没有增加一个新的 Merge 提交。这种情况我们称之为快进（fast-forward）合并。&lt;/p>
&lt;p>假设我们基于 &lt;code>master&lt;/code> 创建了 &lt;code>feature&lt;/code> 分支，并新增了一些提交。现在我们将 &lt;code>feature&lt;/code> 的更改合入 &lt;code>master&lt;/code> 分支：&lt;/p>
&lt;pre>&lt;code>$ git checkout master
$ git merge feature
Updating f42c576..3a0874c
Fast-forward
main.py | 2 ++
task.py | 3 ++
worker.py | 1 ++
3 file changed, 6 insertions(+)
&lt;/code>&lt;/pre>&lt;p>过程示意如下：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/Dec-29-2020-fast-forward.gif" alt="Dec-29-2020 22-50-28">&lt;/p>
&lt;p>由于我们想要合并的分支 &lt;code>feature&lt;/code> 所指向的提交 D 是 &lt;code>master&lt;/code> 的直接后继， 因此 Git 会直接将 &lt;code>HEAD&lt;/code> 指针向前移动。换句话说，如果顺着一个分支走下去一定能够到达另一个分支，那么 Git 在合并两者时只会简单的将指针向前推进（右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做快进（fast-forward）。&lt;/p>
&lt;h2 id="git-的不同合并策略">Git 的不同合并策略&lt;/h2>
&lt;p>我们在使用 Git 时，通常会基于主分支拉出若干条功能分支进行开发，开发完毕后再将功能分支合入主分支。有以下不同的分支合并策略：&lt;/p>
&lt;ul>
&lt;li>通过 &lt;code>merge&lt;/code> 显式合并&lt;/li>
&lt;li>通过 &lt;code>rebase&lt;/code> 或 &lt;code>fast-forward&lt;/code> 隐式合并&lt;/li>
&lt;li>&lt;code>squash&lt;/code> 后隐式合并&lt;/li>
&lt;/ul>
&lt;h3 id="通过-merge-显式合并">通过 &lt;code>merge&lt;/code> 显式合并&lt;/h3>
&lt;p>这是最常见和最直接的合并方式，也是 GitHub 和 GitLab 等代码托管平台的默认实现方式。&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/Dec-29-2020-merge.gif" alt="Dec-29-2020 22-40-46">&lt;/p>
&lt;p>当我们将功能分支合入主分支时，Git 会对两个分支进行递归三路合并，并以合并结果创建一个新的 Merge 提交。这个 Merge 提交和普通的提交本质上是一样的，但是它有两个父提交：&lt;/p>
&lt;pre>&lt;code>$ git cat-file -p 44ba027
tree 5a1692ba62ef346b59e65e4aa441c731bebc51ff
parent 75bf5c59c2e7e493c98e026a415f16b8f0445e4a
parent bbbe6a4c02aa709299ac891779448daf8203df53
author xx &amp;lt;xx@xx.com&amp;gt; 1609141855 +0800
committer xx &amp;lt;xx@xx.com&amp;gt; 1609141855 +0800
Merge branch 'feature' into 'master'
&lt;/code>&lt;/pre>&lt;p>我们能在提交历史中，很明了地根据 Merge 提交查看发生的合并事件。但另一方面，大量的 Merge 提交会使你的提交历史有很多分叉，甚至十分凌乱，有些开发者或者团队可能会想要一个看上去更加整洁的线性提交历史。&lt;/p>
&lt;p>需要注意的是，默认情况下 Git 不会在快进合并的情况下创建单独的 Merge 提交。假如我们想在所有情况下都创建一个 Merge 提交，需要在执行 &lt;code>git merge&lt;/code> 命令时添加 &lt;code>--no-ff&lt;/code> 选项。&lt;/p>
&lt;h3 id="通过-rebase-或-fast-forward-隐式合并">通过 &lt;code>rebase&lt;/code> 或 &lt;code>fast-forward&lt;/code> 隐式合并&lt;/h3>
&lt;p>我们可以用 &lt;code>rebase&lt;/code> 替换 &lt;code>merge&lt;/code> 进行合并，我在之前的一篇文章&lt;a href="https://waynerv.github.io/posts/git-rebase-intro/">git-rebase 浅析&lt;/a>中详细介绍过 &lt;code>rebase&lt;/code> 的原理和用法，简单来说 &lt;code>rebase&lt;/code> 操作会找到两个分支的最近的祖先提交，并基于目标分支按顺序重新应用当前分支在祖先提交之后的更改。假设我们有如下图的 &lt;code>master&lt;/code> 和 &lt;code>feature&lt;/code> 两个分支，执行下列操作：&lt;/p>
&lt;pre>&lt;code>$ git checkout feature
$ git rebase master
$ git checkout master
$ git merge feature
&lt;/code>&lt;/pre>&lt;p>过程如下图所示：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/Dec-31-2020-rebase&amp;amp;fast-forfward.gif" alt="Dec-31-2020-rebase&amp;fast-forfward">&lt;/p>
&lt;p>我们首先用 &lt;code>rebase&lt;/code> 将 &lt;code>master&lt;/code> 合并到了 &lt;code>feature&lt;/code>，即使两个分支都有不同的提交，也得到了一条完全线性的 &lt;code>feature&lt;/code> 分支，而且没有额外的 Merge 提交。&lt;/p>
&lt;p>接着又切换到 &lt;code>master&lt;/code> 分支合并了 &lt;code>feature&lt;/code>。&lt;code>rebase&lt;/code> 之后的 &lt;code>feature&lt;/code> 分支上，所有提交都是 &lt;code>master&lt;/code> 的后继提交，因此我们将直接执行快进合并。快进合并只有在 &lt;code>master&lt;/code> 分支中没有比 &lt;code>feature&lt;/code> 更新的提交时才会发生（使用 &lt;code>rebase&lt;/code> 能够确保该结果），在这种情况下，&lt;code>master&lt;/code> 的 &lt;code>HEAD&lt;/code> 可以直接右移到 &lt;code>feature&lt;/code> 分支的最新提交。这样合并也不会生成单独的 Merge 提交，它只是将分支标签快速指向了新的提交。&lt;/p>
&lt;p>通过 &lt;code>rebase&lt;/code> 或 &lt;code>fast-forward&lt;/code> 隐式的合并，我们能够得到一条整洁线性的提交历史，但同时也会丢失这些提交曾经的上下文信息。&lt;/p>
&lt;h3 id="squash-后隐式合并">&lt;code>squash&lt;/code> 后隐式合并&lt;/h3>
&lt;p>还有一种合并变更的策略是，在执行快进合并或 &lt;code>rebase&lt;/code> 之前，将所有功能分支的提交通过 &lt;code>rebase&lt;/code> 交互模式的 &lt;code>squash&lt;/code> 命令压缩成一个提交。这样可以进一步保持主分支提交历史的线性和整洁。它将一个完整的功能单独保存在一次提交中，但也失去了对整个功能分支开发过程的记录和细节。具体的操作方法可参考&lt;a href="https://waynerv.github.io/posts/git-rebase-intro/#%E9%87%8D%E5%86%99%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2">重写提交历史&lt;/a>。&lt;/p>
&lt;p>这三种策略都有明显的优缺点，我们可以根据具体的场景以及自己的需求进行选择。&lt;/p>
&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://en.wikipedia.org/wiki/Merge_(version_control)">Merge (version control)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://git-scm.com/docs/git-merge">git-merge - Join two or more development histories together&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://blog.developer.atlassian.com/pull-request-merge-strategies-the-great-debate/#:~:text=And%20the%20merge%20can%20complete,of%20an%20earlier%20feature%20branch">Pull Request Merge Strategies: The Great Debate&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6">Git 分支 - 分支的新建与合并&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://segmentfault.com/a/1190000021712743">git merge的原理（递归三路合并算法）&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></content><category scheme="https://www.waynerv.com/categories/%E5%B7%A5%E5%85%B7/" term="工具" label="工具"/><category scheme="https://www.waynerv.com/tags/git/" term="Git" label="Git"/></entry><entry><title type="text">Git Rebase 操作浅析</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/git-rebase-intro/"/><id>https://www.waynerv.com/posts/git-rebase-intro/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2020-10-23T23:45:24+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">以前我对 git rebase -i 的用法一直是一知半解，一次在需要合并多个提交时刚好用到，一顿操作差点把提交都搞丢了，幸好后面顺利找回，因此记录一下……</summary><content type="html">&lt;p>以前我对 &lt;code>git rebase -i&lt;/code> 的用法一直是一知半解，一次在需要合并多个提交时刚好用到，一顿操作差点把提交都搞丢了，幸好后面顺利找回，因此记录一下学习 &lt;code>rebase&lt;/code> 命令的过程。&lt;/p>
&lt;h2 id="理解-rebase-命令">理解 Rebase 命令&lt;/h2>
&lt;p>&lt;code>git rebase&lt;/code> 命令的文档描述是 &lt;code>Reapply commits on top of another base tip&lt;/code>，从字面上理解是「在另一个基端之上重新应用提交」，这个定义听起来有点抽象，换个角度可以理解为「将分支的基础从一个提交改成另一个提交，使其看起来就像是从另一个提交中创建了分支一样」，如下图：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/git-rebase-visual.png" alt="git-rebase.png">&lt;/p>
&lt;p>假设我们从 &lt;code>Master&lt;/code> 的提交 A 创建了 &lt;code>Feature&lt;/code> 分支进行新的功能开发，这时 A 就是 &lt;code>Feature&lt;/code> 的基端。接着 &lt;code>Matser&lt;/code> 新增了两个提交 B 和 C， &lt;code>Feature&lt;/code> 新增了两个提交 D 和 E。现在我们出于某种原因，比如新功能的开发依赖 B、C 提交，需要将 &lt;code>Master&lt;/code> 的两个新提交整合到 &lt;code>Feature&lt;/code> 分支，为了保持提交历史的整洁，我们可以切换到 &lt;code>Feature&lt;/code> 分支执行 &lt;code>rebase&lt;/code> 操作：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git rebase master
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>rebase&lt;/code> 的执行过程是首先找到这两个分支（即当前分支 &lt;code>Feature&lt;/code>、 &lt;code>rebase&lt;/code> 操作的目标基底分支 &lt;code>Master&lt;/code>） 的最近共同祖先提交 A，然后对比当前分支相对于该祖先提交的历次提交（D 和 E），提取相应的修改并存为临时文件，然后将当前分支指向目标基底 &lt;code>Master&lt;/code> 所指向的提交 C, 最后以此作为新的基端将之前另存为临时文件的修改依序应用。&lt;/p>
&lt;p>我们也可以按上文理解成将 &lt;code>Feature&lt;/code> 分支的基础从提交 A 改成了提交 C，看起来就像是从提交 C 创建了该分支，并提交了 D 和 E。但实际上这只是「看起来」，在内部 Git 复制了提交 D 和 E 的内容，创建新的提交 D' 和 E' 并将其应用到特定基础上（A→B→C）。尽管新的 &lt;code>Feature&lt;/code> 分支和之前看起来是一样的，但它是由全新的提交组成的。&lt;/p>
&lt;p>&lt;code>rebase&lt;/code> 操作的实质是丢弃一些现有的提交，然后相应地新建一些内容一样但实际上不同的提交。&lt;/p>
&lt;h2 id="主要用途">主要用途&lt;/h2>
&lt;p>&lt;code>rebase&lt;/code> 通常用于重写提交历史。下面的使用场景在大多数 Git 工作流中是十分常见的：&lt;/p>
&lt;ul>
&lt;li>我们从 &lt;code>master&lt;/code> 分支拉取了一条 &lt;code>feature&lt;/code> 分支在本地进行功能开发&lt;/li>
&lt;li>远程的 &lt;code>master&lt;/code> 分支在之后又合并了一些新的提交&lt;/li>
&lt;li>我们想在 &lt;code>feature&lt;/code> 分支集成 &lt;code>master&lt;/code> 的最新更改&lt;/li>
&lt;/ul>
&lt;h3 id="和-merge-的区别">和 &lt;code>merge&lt;/code> 的区别&lt;/h3>
&lt;p>以上场景同样可以使用 &lt;code>merge&lt;/code> 来达成目的，但使用 &lt;code>rebase&lt;/code> 可以使我们保持一个线性且更加整洁的提交历史。假设我们有如下分支：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash"> D---E feature
/
A---B---C master
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在我们将分别使用 &lt;code>merge&lt;/code> 和 &lt;code>rebase&lt;/code>，把 &lt;code>master&lt;/code> 分支的 B、C 提交集成到 &lt;code>feature&lt;/code> 分支，并在 &lt;code>feature&lt;/code> 分支新增一个提交 F，然后再将 &lt;code>feature&lt;/code> 分支合入 &lt;code>master&lt;/code> ，最后对比两种方法所形成的提交历史的区别。&lt;/p>
&lt;ul>
&lt;li>
&lt;p>使用 &lt;code>merge&lt;/code>&lt;/p>
&lt;ol>
&lt;li>切换到 &lt;code>feature&lt;/code> 分支： &lt;code>git checkout feature&lt;/code>。&lt;/li>
&lt;li>合并 &lt;code>master&lt;/code> 分支的更新： &lt;code>git merge master&lt;/code>。&lt;/li>
&lt;li>新增一个提交 F： &lt;code>git add . &amp;amp;&amp;amp; git commit -m &amp;quot;commit F&amp;quot;&lt;/code> 。&lt;/li>
&lt;li>切回 &lt;code>master&lt;/code> 分支并执行快进合并： &lt;code>git chekcout master &amp;amp;&amp;amp; git merge feature&lt;/code>。&lt;/li>
&lt;/ol>
&lt;p>执行过程如下图所示：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/Dec-30-2020-merge-example.gif" alt="Dec-30-2020-merge-example">&lt;/p>
&lt;p>我们将得到如下提交历史：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">* 6fa5484 &lt;span class="o">(&lt;/span>HEAD -&amp;gt; master, feature&lt;span class="o">)&lt;/span> commit F
* 875906b Merge branch &lt;span class="s1">&amp;#39;master&amp;#39;&lt;/span> into feature
&lt;span class="p">|&lt;/span>&lt;span class="se">\ &lt;/span>
&lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> 5b05585 commit E
&lt;span class="p">|&lt;/span> &lt;span class="p">|&lt;/span> f5b0fc0 commit D
* * d017dff commit C
* * 9df916f commit B
&lt;span class="p">|&lt;/span>/
* cb932a6 commit A
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>使用 &lt;code>rebase&lt;/code>&lt;/p>
&lt;p>步骤与使用 &lt;code>merge&lt;/code> 基本相同，唯一的区别是第 2 步的命令替换成： &lt;code>git rebase master&lt;/code>。&lt;/p>
&lt;p>执行过程如下图所示：&lt;/p>
&lt;p>&lt;img src="https://www.waynerv.com/images/Dec-30-2020-rebase-example.gif" alt="Dec-30-2020-rebase-example">&lt;/p>
&lt;p>我们将得到如下提交历史：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">* 74199ce &lt;span class="o">(&lt;/span>HEAD -&amp;gt; master, feature&lt;span class="o">)&lt;/span> commit F
* e7c7111 commit E
* d9623b0 commit D
* 73deeed commit C
* c50221f commit B
* ef13725 commit A
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ul>
&lt;p>可以看到，使用 &lt;code>rebase&lt;/code> 方法形成的提交历史是完全线性的，同时相比 &lt;code>merge&lt;/code> 方法少了一次 &lt;code>merge&lt;/code> 提交，看上去更加整洁。&lt;/p>
&lt;h3 id="为什么要保持提交历史的整洁">为什么要保持提交历史的整洁&lt;/h3>
&lt;p>一个看上更整洁的提交历史有什么好处？&lt;/p>
&lt;ol>
&lt;li>满足某些开发者的洁癖。&lt;/li>
&lt;li>当你因为某些 bug 需要回溯提交历史时，更容易定位到 bug 是从哪一个提交引入。尤其是当你需要通过 &lt;code>git bisect&lt;/code> 从几十上百个提交中排查 bug，或者有一些体量较大的功能分支需要频繁的从远程的主分支拉取更新时。&lt;/li>
&lt;/ol>
&lt;p>使用 &lt;code>rebase&lt;/code> 来将远程的变更整合到本地仓库是一种更好的选择。用 &lt;code>merge&lt;/code> 拉取远程变更的结果是，每次你想获取项目的最新进展时，都会有一个多余的 &lt;code>merge&lt;/code> 提交。而使用 &lt;code>rebase&lt;/code> 的结果更符合我们的本意：我想在其他人的已完成工作的基础上进行我的更改。&lt;/p>
&lt;h3 id="其他重写提交历史的方法">其他重写提交历史的方法&lt;/h3>
&lt;p>当我们仅仅只想修改最近的一次提交时，使用 &lt;code>git commit --amend&lt;/code> 会更加方便。&lt;/p>
&lt;p>它适用于以下场景：&lt;/p>
&lt;ul>
&lt;li>我们刚刚完成了一次提交，但还没有推送到公共的分支。&lt;/li>
&lt;li>突然发现上个提交还留了些小尾巴没有完成，比如一行忘记删除的注释或者一个很小的笔误，我们可以很快速的完成修改，但又不想再新增一个单独的提交。&lt;/li>
&lt;li>或者我们只是觉得上一次提交的提交信息写的不够好，想做一些修改。&lt;/li>
&lt;/ul>
&lt;p>这时候我们可以添加新增的修改（或跳过），使用 &lt;code>git commit --amend&lt;/code> 命令执行提交，执行后会进入一个新的编辑器窗口，可以对上一次提交的提交信息进行修改，保存后就会将所做的这些更改应用到上一次提交。&lt;/p>
&lt;p>如果我们已经将上一次提交推送到了远程的分支，现在再执行推送将会提示出错并被拒绝，在确保该分支不是一个公共分支的前提下，我们可以使用 &lt;code>git push --force&lt;/code> 强制推送。&lt;/p>
&lt;p>注意与 &lt;code>rebase&lt;/code> 一样，Git 在内部并不会真正地修改并替换上一个提交，而是创建了一个全新的提交并重新指向这个新的提交。&lt;/p>
&lt;h2 id="使用-rebase-的交互模式重写提交历史">使用 &lt;code>rebase&lt;/code> 的交互模式重写提交历史&lt;/h2>
&lt;p>&lt;code>git rebase&lt;/code> 命令有标准和交互两种模式，之前的示例我们用的都是默认的标准模式，在命令后添加 &lt;code>-i&lt;/code> 或 &lt;code>--interactive&lt;/code> 选项即可使用交互模式。&lt;/p>
&lt;h3 id="两种模式的区别">两种模式的区别&lt;/h3>
&lt;p>我们前面提到， &lt;code>rebase&lt;/code> 是「在另一个基端之上重新应用提交」，而在重新应用的过程中，这些提交会被重新创建，自然也可以进行修改。在 &lt;code>rebase&lt;/code> 的标准模式下，当前工作分支的提交会被直接应用到传入分支的顶端；而在交互模式下，则允许我们在重新应用之前通过编辑器以及特定的命令规则对这些提交进行合并、重新排序及删除等重写操作。&lt;/p>
&lt;p>两者最常见的使用场景也因此有所不同：&lt;/p>
&lt;ol>
&lt;li>标准模式常用于在当前分支中集成来自其他分支的最新修改。&lt;/li>
&lt;li>交互模式常用于对当前分支的提交历史进行编辑，如将多个小提交合并成大的提交。&lt;/li>
&lt;/ol>
&lt;h3 id="不仅仅是分支">不仅仅是分支&lt;/h3>
&lt;p>虽然我们之前的示例都是在不同的两个分支之间执行 rebase 操作，但事实上 rebase 命令传入的参数并不仅限于分支。&lt;/p>
&lt;p>任何的提交引用，都可以被视作有效的 &lt;code>rebase&lt;/code> 基底对象，包括一个提交 ID、分支名称、标签名称或 &lt;code>HEAD~1&lt;/code> 这样的相对引用。&lt;/p>
&lt;p>自然地，假如我们对当前分支的某次历史提交执行 &lt;code>rebase&lt;/code>，其结果就是会将这次提交之后的所有提交重新应用在当前分支，在交互模式下，即允许我们对这些提交进行更改。&lt;/p>
&lt;h3 id="重写提交历史">重写提交历史&lt;/h3>
&lt;p>终于进入到本文的主题，前面提到，假如我们在交互模式对当前分支的某次提交执行 &lt;code>rebase&lt;/code>，即（间接）实现了对这次提交之后的所有提交进行重写。接下来我们将通过下面的示例进行详细介绍。&lt;/p>
&lt;p>假设我们在 &lt;code>feature&lt;/code> 分支有如下提交：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">74199cebdd34d107bb67b6da5533a2e405f4c330 &lt;span class="o">(&lt;/span>HEAD -&amp;gt; feature&lt;span class="o">)&lt;/span> commit F
e7c7111d807c1d5209b97a9c75b09da5cd2810d4 commit E
d9623b0ef9d722b4a83d58a334e1ce85545ea524 commit D
73deeedaa944ef459b17d42601677c2fcc4c4703 commit C
c50221f93a39f3474ac59228d69732402556c93b commit B
ef1372522cdad136ce7e6dc3e02aab4d6ad73f79 commit A
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来我们将要执行的操作是：&lt;/p>
&lt;ul>
&lt;li>将 B、C 合并为一个新的提交 ，并仅保留原提交 C 的提交信息&lt;/li>
&lt;li>删除提交 D&lt;/li>
&lt;li>将提交 E 移动到提交 F 之后并重新命名（即修改提交信息）为提交 H&lt;/li>
&lt;li>在提交 F 中加入一个新的文件更改，并重新命名为提交 G&lt;/li>
&lt;/ul>
&lt;p>由于我们需要修改的提交是 B→C→D→E，因此我们需要将提交 A 作为新的「基端」，提交 A 之后的所有提交会被重新应用：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git rebase -i ef1372522cdad136ce7e6dc3e02aab4d6ad73f79 &lt;span class="c1"># 参数是提交 A 的 ID&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来会进入到如下的编辑器界面：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">pick c50221f commit B
pick 73deeed commit C
pick d9623b0 commit D
pick e7c7111 commit E
pick 74199ce commit F
&lt;span class="c1"># 变基 ef13725..74199ce 到 ef13725（5 个提交）&lt;/span>
&lt;span class="c1">#&lt;/span>
&lt;span class="c1"># 命令:&lt;/span>
&lt;span class="c1"># p, pick &amp;lt;提交&amp;gt; = 使用提交&lt;/span>
&lt;span class="c1"># r, reword &amp;lt;提交&amp;gt; = 使用提交，但修改提交说明&lt;/span>
&lt;span class="c1"># e, edit &amp;lt;提交&amp;gt; = 使用提交，进入 shell 以便进行提交修补&lt;/span>
&lt;span class="c1"># s, squash &amp;lt;提交&amp;gt; = 使用提交，但融合到前一个提交&lt;/span>
&lt;span class="c1"># f, fixup &amp;lt;提交&amp;gt; = 类似于 &amp;#34;squash&amp;#34;，但丢弃提交说明日志&lt;/span>
&lt;span class="c1"># x, exec &amp;lt;命令&amp;gt; = 使用 shell 运行命令（此行剩余部分）&lt;/span>
&lt;span class="c1"># b, break = 在此处停止（使用 &amp;#39;git rebase --continue&amp;#39; 继续变基）&lt;/span>
&lt;span class="c1"># d, drop &amp;lt;提交&amp;gt; = 删除提交&lt;/span>
......
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>（注意上面提交 ID 之后的提交信息只起到描述作用，在这里修改它们不会有任何效果。）&lt;/p>
&lt;p>具体的操作命令在编辑器的注释中已解释的相当详细，所以我们直接进行如下操作：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>对提交 B、C 作如下修改：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">pick c50221f commit B
f 73deeed commit C
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>由于提交 B 是这些提交中的第一个，因此我们无法对其执行 &lt;code>squash&lt;/code> 或者 &lt;code>fixup&lt;/code> 命令（没有前一个提交了），我们也不需要对提交 B 执行 &lt;code>reword&lt;/code> 命令以修改其提交信息，因为之后在将提交 C 融合到提交 B 中时，会允许我们对融合之后的提交信息进行修改。&lt;/p>
&lt;p>注意该界面提交的展示顺序是从上到下由旧到新，因此我们将提交 C 的命令改为 &lt;code>s（或 squash）&lt;/code> 或者 &lt;code>f（或 fixup）&lt;/code> 会将其融合到（上方的）前一个提交 B，两个命令的区别为是否保留 C 的提交信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>删除提交 D：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">d d9623b0 commit D
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>移动提交 E 到提交 F 之后并修改其提交信息：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">pick 74199ce commit F
r e7c7111 commit E
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>在提交 F 中加入一个新的文件更改：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">e 74199ce commit F
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>保存退出。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>接下来会按照从上到下的顺序依次执行我们对每一个提交所修改或保留的命令：&lt;/p>
&lt;ol>
&lt;li>
&lt;p>对提交 B 的 &lt;code>pick&lt;/code> 命令会自动执行，因此不需要交互。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>接着执行对提交 C 的 &lt;code>squash&lt;/code> 命令，会进入一个新的编辑器界面允许我们修改合并了B、C 之后的提交信息：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;span class="lnt">9
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 这是一个 2 个提交的组合。&lt;/span>
&lt;span class="c1"># 这是第一个提交说明：&lt;/span>
commit B
&lt;span class="c1"># 这是提交说明 #2：&lt;/span>
commit C
......
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们将 &lt;code>commit B&lt;/code> 这一行删除后保存退出，融合之后的提交将使用 &lt;code>commit C&lt;/code> 作为提交信息。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>对提交 D 的 &lt;code>drop&lt;/code> 操作也会自动执行，没有交互步骤。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>执行 &lt;code>rebase&lt;/code> 的过程中可能会发生冲突，这时候 &lt;code>rebase&lt;/code> 会暂时中止，需要我们编辑冲突的文件去手动合并冲突。解决冲突后通过 &lt;code>git add/rm &amp;lt;conflicted_files&amp;gt;&lt;/code> 将其标记为已解决，然后执行 &lt;code>git rebase --continue&lt;/code> 可以继续之后的 &lt;code>rebase&lt;/code> 步骤；或者也可以执行 &lt;code>git rebase --abort&lt;/code> 放弃 &lt;code>rebase&lt;/code> 操作并恢复到操作之前的状态。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>由于我们上移了提交 F 的位置，因此接下来将执行对 F 的 &lt;code>edit&lt;/code> 操作。这时将进入一个新的 Shell 会话：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">停止在 74199ce... commit F
您现在可以修补这个提交，使用
git commit --amend
当您对变更感到满意，执行
git rebase --continue
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>我们添加一个新的代码文件并执行 &lt;code>git commit --amend&lt;/code> 将其合并到当前的上一个提交（即 F），然后在编辑器界面中将其提交信息修改为 &lt;code>commit G&lt;/code>，最后执行 &lt;code>git rebase --continue&lt;/code> 继续 &lt;code>rebase&lt;/code> 操作。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>最后执行对提交 E 的 &lt;code>reword&lt;/code> 操作，在编辑器界面中将其提交信息修改为 &lt;code>commit H&lt;/code> 。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>大功告成！最后让我们确认一下 &lt;code>rebase&lt;/code> 之后的提交历史：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">64710dc88ef4fbe8fe7aac206ec2e3ef12e7bca9 &lt;span class="o">(&lt;/span>HEAD -&amp;gt; feature&lt;span class="o">)&lt;/span> commit H
8ab4506a672dac5c1a55db34779a185f045d7dd3 commit G
1e186f890710291aab5b508a4999134044f6f846 commit C
ef1372522cdad136ce7e6dc3e02aab4d6ad73f79 commit A
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>完全符合预期，同时也可以看到提交 A之后的所有提交 ID 都已经发生了改变，这也印证了我们之前所说的 Git 重新创建了这些提交。&lt;/p>
&lt;h2 id="rebase-的进阶用法">Rebase 的进阶用法&lt;/h2>
&lt;h3 id="合并之前执行-rebase">合并之前执行 &lt;code>rebase&lt;/code>&lt;/h3>
&lt;p>另一种使用 &lt;code>rebase&lt;/code> 的常见场景是在推送到远程进行合并之前执行 &lt;code>rebase&lt;/code>，一般这样做的目的是为了确保提交历史的整洁。&lt;/p>
&lt;p>我们首先在自己的功能分支里进行开发，当开发完成时需要先将当前功能分支 &lt;code>rebase&lt;/code> 到最新的主分支上，提前解决可能出现的冲突，然后再向远程提交修改。 这样的话，远程仓库的主分支维护者就不再需要进行整合且创建一条额外的 &lt;code>merge&lt;/code> 提交，只需要执行快进合并即可。即使是在多个分支并行开发的情况，最终也能得到一条完全线性的提交历史。&lt;/p>
&lt;h3 id="rebase-到其他分支">&lt;code>rebase&lt;/code> 到其他分支&lt;/h3>
&lt;p>我们可以通过 &lt;code>rebase&lt;/code> 对两个分支进行对比，取出相应的修改，然后应用到另一个分支上。例如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash"> F---G patch
/
D---E feature
/
A---B---C master
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>假设我们基于 &lt;code>feature&lt;/code> 分支的提交 D 创建了分支 &lt;code>patch&lt;/code>，并且新增了提交 F、G，现在我们想将 &lt;code>patch&lt;/code> 所做的更改合并到 &lt;code>master&lt;/code> 并发布，但暂时还不想合并 &lt;code>feature&lt;/code> ，这种情况下可以使用 &lt;code>rebase&lt;/code> 的 &lt;code>--onto &amp;lt;branch&amp;gt;&lt;/code> 选项：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git rebase —onto master feature patch
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>以上操作将取出 &lt;code>patch&lt;/code> 分支，对比它基于 &lt;code>feature&lt;/code> 所做的更改， 然后把这些更改在 &lt;code>master&lt;/code> 分支上重新应用，让 &lt;code>patch&lt;/code> 看起来就像直接基于 &lt;code>master&lt;/code> 进行更改一样。执行后的 &lt;code>patch&lt;/code> 如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">A---B---C---F&lt;span class="s1">&amp;#39;---G&amp;#39;&lt;/span> patch
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>然后我们可以切换到 &lt;code>master&lt;/code> 分支，并对 &lt;code>patch&lt;/code> 执行快进合并：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">git checkout master
git merge patch
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="通过-rebase-执行-git-pull">通过 &lt;code>rebase&lt;/code> 执行 &lt;code>git pull&lt;/code>&lt;/h3>
&lt;p>Git 在最近的某个版本起，直接运行 &lt;code>git pull&lt;/code> 会有如下提示消息：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">warning: 不建议在没有为偏离分支指定合并策略时执行 pull 操作。 您可以在执行下一次 pull 操作之前执行下面一条命令来抑制本消息：
git config pull.rebase &lt;span class="nb">false&lt;/span> &lt;span class="c1"># 合并（缺省策略）&lt;/span>
git config pull.rebase &lt;span class="nb">true&lt;/span> &lt;span class="c1"># 变基&lt;/span>
git config pull.ff only &lt;span class="c1"># 仅快进&lt;/span>
......
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>原来 &lt;code>git pull&lt;/code> 时也可以通过 &lt;code>rebase&lt;/code> 来进行合并，这是因为 &lt;code>git pull&lt;/code> 实际上等于 &lt;code>git fetch&lt;/code> + &lt;code>git merge&lt;/code> ，我们可以在第二步直接用 &lt;code>git rebase&lt;/code> 替换 &lt;code>git merge&lt;/code>来合并 &lt;code>fetch&lt;/code> 取得的变更，作用同样是避免额外的 &lt;code>merge&lt;/code> 提交以保持线性的提交历史。&lt;/p>
&lt;p>两者的区别在上文中已进行过对比，我们可以把对比示例中的 &lt;code>Matser&lt;/code> 分支当成远程分支，把 &lt;code>Feature&lt;/code> 分支当成本地分支，当我们在本地执行 &lt;code>git pull&lt;/code> 时，其实就是拉取 &lt;code>Master&lt;/code> 的更改然后合并到 &lt;code>Feature&lt;/code> 分支。如果两个分支都有不同的提交，默认的 &lt;code>git merge&lt;/code> 方式会生成一个单独的 merge 提交以整合这些提交；而使用 &lt;code>git rebase&lt;/code> 则相当于基于远程分支的最新提交重新创建本地分支，然后再重新应用本地所添加的提交。&lt;/p>
&lt;p>具体的使用方式有多种：&lt;/p>
&lt;ul>
&lt;li>每次执行 pull 命令时添加特定选项： &lt;code>git pull --rebase&lt;/code> 。&lt;/li>
&lt;li>为当前仓库设定配置项： &lt;code>git config pull.rebase true&lt;/code>，在 &lt;code>git config&lt;/code> 后添加 &lt;code>--global&lt;/code> 选项可以使该配置项对所有仓库生效。&lt;/li>
&lt;/ul>
&lt;h2 id="潜在弊端和反对意见">潜在弊端和反对意见&lt;/h2>
&lt;p>从以上场景来看 &lt;code>rebase&lt;/code> 功能非常强大，但我们也需要意识到它不是万能的，甚至对新手来说有些危险，稍有不慎就会发现 &lt;code>git log&lt;/code> 里的提交不见了，或者卡在 &lt;code>rebase&lt;/code> 的某个步骤不知道如何恢复。&lt;/p>
&lt;p>我们上面已经提到了 &lt;code>rebase&lt;/code> 有保持整洁的线性提交历史的优点，但也需要意识到它有以下潜在的弊端：&lt;/p>
&lt;ul>
&lt;li>如果涉及到已经推送过的提交，需要强制推送才能将本地 &lt;code>rebase&lt;/code> 后的提交推送到远程。因此绝对不要在一个公共分支（也就是说还有其他人基于这个分支进行开发）执行 &lt;code>rebase&lt;/code>，否则其他人之后执行 &lt;code>git pull&lt;/code> 会合并出一条令人困惑的本地提交历史，进一步推送回远程分支后又会将远程的提交历史打乱（详见&lt;a href="https://www.daolf.com/posts/git-series-part-2/">Rebase and the golden rule explained&lt;/a>），较严重的情况下可能会对你的人身安全带来风险。&lt;/li>
&lt;li>对新手不友好，新手很有可能在交互模式中误操作「丢失」某些提交（但其实是能够找回的）。&lt;/li>
&lt;li>假如你频繁的使用 &lt;code>rebase&lt;/code> 来集成主分支的更新，一个潜在的后果是你会遇到越来越多需要合并的冲突。尽管你可以在 &lt;code>rebase&lt;/code> 过程中处理这些冲突，但这并非长久之计，更推荐的做法是频繁的合入主分支然后创建新的功能分支，而不是使用一个长时间存在的功能分支。&lt;/li>
&lt;/ul>
&lt;p>另外有一些观点是我们应该尽量避免重写提交历史：&lt;/p>
&lt;blockquote>
&lt;p>有一种观点认为，仓库的提交历史即是 记录实际发生过什么。 它是针对历史的文档，本身就有价值，不能乱改。 从这个角度看来，改变提交历史是一种亵渎，你使用 谎言 掩盖了实际发生过的事情。 如果由合并产生的提交历史是一团糟怎么办？ 既然事实就是如此，那么这些痕迹就应该被保留下来，让后人能够查阅。&lt;/p>
&lt;/blockquote>
&lt;p>以及频繁的使用 &lt;code>rebase&lt;/code> 可能会使从历史提交中定位 bug 变得更加困难，详见 &lt;a href="https://medium.com/@fredrikmorken/why-you-should-stop-using-git-rebase-5552bee4fed1">Why you should stop using Git rebase&lt;/a>。&lt;/p>
&lt;h2 id="找回丢失的提交">找回丢失的提交&lt;/h2>
&lt;p>在交互式模式下进行 &lt;code>rebase&lt;/code> 并对提交执行 &lt;code>squash&lt;/code> 或 &lt;code>drop&lt;/code> 等命令后，会从分支的 &lt;code>git log&lt;/code> 中直接删除提交。如果你不小心操作失误，会以为这些提交已经永久消失了而吓出一身冷汗。&lt;/p>
&lt;p>但这些提交并没有真正地被删除，如上所说，Git 并不会修改（或删除）原来的提交，而是重新创建了一批新的提交，并将当前分支顶端指向了新提交。因此我们可以使用 &lt;code>git reflog&lt;/code> 找到并且重新指向原来的提交来恢复它们，这会撤销整个 &lt;code>rebase&lt;/code>。感谢 Git ，即使你执行 &lt;code>rebase&lt;/code> 或者 &lt;code>commit --amend&lt;/code> 等重写提交历史的操作，它也不会真正地丢失任何提交。&lt;/p>
&lt;h3 id="git-reflog">&lt;code>git reflog&lt;/code>&lt;/h3>
&lt;p>&lt;code>reflogs&lt;/code> 是 Git 用来记录本地仓库分支顶端的更新的一种机制，它会记录所有分支顶端曾经指向过的提交，因此 &lt;code>reflogs&lt;/code> 允许我们找到并切换到一个当前没有被任何分支或标签引用的提交。&lt;/p>
&lt;p>每当分支顶端由于任何原因被更新（通过切换分支、拉取新的变更、重写历史或者添加新的提交），一条新的记录将被添加到 &lt;code>reflogs&lt;/code> 中。如此一来，我们在本地所创建过的每一次提交都一定会被记录在 &lt;code>reflogs&lt;/code> 中。即使在重写了提交历史之后， &lt;code>reflogs&lt;/code> 也会包含关于分支的旧状态的信息，并允许我们在需要时恢复到该状态。&lt;/p>
&lt;p>注意 &lt;code>reflogs&lt;/code> 并不会永久保存，它有 90 天的过期时间。&lt;/p>
&lt;h3 id="还原提交历史">还原提交历史&lt;/h3>
&lt;p>我们从上一个例子继续，假设我们想恢复 &lt;code>feature&lt;/code> 分支在 &lt;code>rebase&lt;/code> 之前的 A→B→C→D→E→F 提交历史，但这时候的 &lt;code>git log&lt;/code> 中已经没有后面 5 个提交，所以需要从 &lt;code>reflogs&lt;/code> 中寻找，运行 &lt;code>git reflog&lt;/code> 结果如下:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">64710dc &lt;span class="o">(&lt;/span>HEAD -&amp;gt; feature&lt;span class="o">)&lt;/span> HEAD@&lt;span class="o">{&lt;/span>0&lt;span class="o">}&lt;/span>: rebase &lt;span class="o">(&lt;/span>&lt;span class="k">continue&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">(&lt;/span>finish&lt;span class="o">)&lt;/span>: returning to refs/heads/feature
64710dc &lt;span class="o">(&lt;/span>HEAD -&amp;gt; feature&lt;span class="o">)&lt;/span> HEAD@&lt;span class="o">{&lt;/span>1&lt;span class="o">}&lt;/span>: rebase &lt;span class="o">(&lt;/span>&lt;span class="k">continue&lt;/span>&lt;span class="o">)&lt;/span>: commit H
8ab4506 HEAD@&lt;span class="o">{&lt;/span>2&lt;span class="o">}&lt;/span>: rebase &lt;span class="o">(&lt;/span>&lt;span class="k">continue&lt;/span>&lt;span class="o">)&lt;/span>: commit G
1e186f8 HEAD@&lt;span class="o">{&lt;/span>3&lt;span class="o">}&lt;/span>: rebase &lt;span class="o">(&lt;/span>squash&lt;span class="o">)&lt;/span>: commit C
c50221f HEAD@&lt;span class="o">{&lt;/span>4&lt;span class="o">}&lt;/span>: rebase &lt;span class="o">(&lt;/span>start&lt;span class="o">)&lt;/span>: checkout ef1372522cdad136ce7e6dc3e02aab4d6ad73f79
74199ce HEAD@&lt;span class="o">{&lt;/span>5&lt;span class="o">}&lt;/span>: checkout: moving from master to feature
......
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;code>reflogs&lt;/code> 完整的记录了我们切换分支并进行 &lt;code>rebase&lt;/code> 的全过程，继续向下检索，我们找到了从 &lt;code>git log&lt;/code> 中消失的提交 F:&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">74199ce HEAD@&lt;span class="o">{&lt;/span>15&lt;span class="o">}&lt;/span>: commit: commit F
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>接下来我们通过 &lt;code>git reset&lt;/code> 将 &lt;code>feature&lt;/code> 分支的顶端重新指向原来的提交 F：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">&lt;span class="c1"># 我们想将工作区中的文件也一并还原，因此使用了--hard选项 &lt;/span>
$ git reset --hard 74199ce
HEAD 现在位于 74199ce commit F
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>再运行 &lt;code>git log&lt;/code> 会发现一切又回到了从前：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">74199cebdd34d107bb67b6da5533a2e405f4c330 &lt;span class="o">(&lt;/span>HEAD -&amp;gt; feature&lt;span class="o">)&lt;/span> commit F
e7c7111d807c1d5209b97a9c75b09da5cd2810d4 commit E
d9623b0ef9d722b4a83d58a334e1ce85545ea524 commit D
73deeedaa944ef459b17d42601677c2fcc4c4703 commit C
c50221f93a39f3474ac59228d69732402556c93b commit B
ef1372522cdad136ce7e6dc3e02aab4d6ad73f79 commit A
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="参考链接">参考链接&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a href="https://www.atlassian.com/git/tutorials/rewriting-history/git-rebase">git rebase | Atlassian Git Tutorial&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.atlassian.com/git/tutorials/rewriting-history">git amend | Atlassian Git Tutorial&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.atlassian.com/git/tutorials/syncing/git-pull">Git Pull | Atlassian Git Tutorial&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA">Git - 变基&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://git-scm.com/docs/git-rebase">Git - git-rebase Documentation&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://git-scm.com/docs/git-reflog">Git - git-reflog Documentation&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://medium.com/@fredrikmorken/why-you-should-stop-using-git-rebase-5552bee4fed1">Why you should stop using Git rebase&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://medium.com/@fabisiakradoslaw/understand-how-does-git-rebase-work-and-compare-with-git-merge-and-git-interactive-rebase-cce2c9775e43">Understand how does git rebase work and compare with git merge and git interactive rebase&lt;/a>&lt;/p>
&lt;/li>
&lt;/ul></content><category scheme="https://www.waynerv.com/categories/%E5%B7%A5%E5%85%B7/" term="工具" label="工具"/><category scheme="https://www.waynerv.com/tags/git/" term="Git" label="Git"/></entry><entry><title type="text">写了一份 Web API 设计规范</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/my-web-api-spcification/"/><id>https://www.waynerv.com/posts/my-web-api-spcification/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2020-10-17T11:40:09+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">基于 GitHub REST API v3 和 RFC7807，并结合自己在工作中的一些实践，编写了这份 Web API 规范。</summary><content type="html">&lt;p>基于 &lt;a href="https://developer.github.com/v3">GitHub REST API v3&lt;/a> 和 &lt;a href="https://tools.ietf.org/html/rfc7807">RFC7807&lt;/a> ，并结合自己在工作中的一些实践，编写了这份 Web API 规范。&lt;/p>
&lt;p>本规范虽然整体上遵循 RESTful 风格，但并未强制要求使用超媒体表示，严格来说不符合 REST API 的要求，因此基于此规范构建的项目应该定义为 Web API。&lt;/p>
&lt;h2 id="概览">概览&lt;/h2>
&lt;p>所有 API 应该使用统一的根域名。&lt;/p>
&lt;p>所有访问 API 的请求均基于 HTTP 协议，出于安全性考虑尽量使用 &lt;code>HTTPS&lt;/code> 。&lt;/p>
&lt;p>除文件上传下载外所有的数据均通过 &lt;code>JSON&lt;/code> 格式发送和接收，请求和响应的 &lt;code>Content Type&lt;/code> 首部均设置为 &lt;code>application/json&lt;/code>。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="n">curl&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">i&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">H&lt;/span> &lt;span class="s2">&amp;#34;Authorization: Bearer TOKEN&amp;#34;&lt;/span> &lt;span class="n">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">qcs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">woqutech&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">com&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">api&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">employees&lt;/span>
&lt;span class="n">HTTP&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mf">1.1&lt;/span> &lt;span class="mi">200&lt;/span> &lt;span class="n">OK&lt;/span>
&lt;span class="n">Server&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">nginx&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mf">1.12&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="mi">2&lt;/span>
&lt;span class="n">Date&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">Thu&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">19&lt;/span> &lt;span class="n">Sep&lt;/span> &lt;span class="mi">2019&lt;/span> &lt;span class="mi">09&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mo">07&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">27&lt;/span> &lt;span class="n">GMT&lt;/span>
&lt;span class="n">Content&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">Type&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">application&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">json&lt;/span>
&lt;span class="n">Content&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">Length&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1115&lt;/span>
&lt;span class="n">Connection&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">keep&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">alive&lt;/span>
&lt;span class="n">Access&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">Control&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">Allow&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">Origin&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="o">*&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="n">RESPONSE&lt;/span> &lt;span class="n">BODY&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>空白字段将提供为 &lt;code>null&lt;/code> 的值，而不是忽略该字段或提供 &lt;code>&amp;quot;&amp;quot;&lt;/code> 空字符串值。&lt;/p>
&lt;p>所有响应中的时间戳以 ISO 8601 格式表示：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="mi">2019&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">09&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">16&lt;/span>&lt;span class="n">T08&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">42&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="mi">47&lt;/span>&lt;span class="n">Z&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="uri命名">URI命名&lt;/h2>
&lt;h3 id="动词-or-名词">动词 or 名词?&lt;/h3>
&lt;p>基于 RESTful 的基本原则：&lt;/p>
&lt;blockquote>
&lt;p>将所有的 API 划分为逻辑的资源，并通过 HTTP 请求方法来对资源进行操作&lt;/p>
&lt;/blockquote>
&lt;p>所有的资源都应该表述为名词而不是动词，且该资源并不需要和应用程序的数据模型完全对应。&lt;/p>
&lt;h3 id="单数-or-复数">单数 or 复数?&lt;/h3>
&lt;p>为了保持简单和一致，不管是资源的单个实例还是集合，在 URI 中都将使用复数形式来表示。如 &lt;code>/tickets&lt;/code> 和 &lt;code>/tickets/12&lt;/code> 。&lt;/p>
&lt;h3 id="如何表示集合关系">如何表示集合关系?&lt;/h3>
&lt;p>当资源之间存在集合关系时（即某一资源存在于另一资源的作用域中），我们应当在请求 URI 中体现集合关系，以工单中的评论为例：&lt;/p>
&lt;ul>
&lt;li>GET /tickets/12/comments - 获取编号为12的工单的所有评论&lt;/li>
&lt;li>GET /tickets/12/comments/5 - 获取编号为12的工单中编号为5的评论&lt;/li>
&lt;/ul>
&lt;p>若想获取某一集合中的子资源，必须通过其父资源端点进行访问，在接口中也将对其上一级资源进行校验。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="n">GET&lt;/span> &lt;span class="n">https&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">serviceRoot&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">collection&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nb">id&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="n">subcollection&lt;/span>&lt;span class="p">}&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nb">id&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>但当集合层级过于复杂时，会考虑分拆集合关系以构造简单易懂的 URI，如：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="o">/&lt;/span>&lt;span class="n">api&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">tickets&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">12&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">comments&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">5&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">replies&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">likes&lt;/span>
&lt;span class="o">---&amp;gt;&lt;/span> &lt;span class="o">/&lt;/span>&lt;span class="n">api&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">replies&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">20&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">likes&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="如何表示不适用于-crud-的行为">如何表示不适用于 CRUD 的行为?&lt;/h3>
&lt;ol>
&lt;li>将该行为重新组织为资源下的某一字段，通过 PATCH 方法更新该字段执行操作。&lt;/li>
&lt;li>将其视为一种 RESTful 原则下的子资源，如 GitHub's API 通过 &lt;code>PUT /gists/:id/star&lt;/code> 来 star 某个仓库，通过 &lt;code>DELETE /gists/:id/star&lt;/code> 取消 star。&lt;/li>
&lt;li>某些动作实在无法映射到合理的 RESTful 结构， 例如对多种资源同时进行搜索，很难对应到特定资源的端点。在这种情况下，即使它不是资源也可以使用 &lt;code>/search&lt;/code> 作为端点，只需要API的使用者能够清晰地理解其意义即可。&lt;/li>
&lt;/ol>
&lt;h2 id="http-方法">HTTP 方法&lt;/h2>
&lt;p>REST 以资源为核心，HTTP 方法所操作的对象也是资源，对资源的操作即为&lt;strong>状态转移。&lt;/strong>&lt;/p>
&lt;p>数据的增删改查则是持久层的具体实现，一次状态转移可能会对应多个数据库表的增删改操作，所以 HTTP 方法和数据库 CRUD 之间也不是严格的一一对应关系。&lt;/p>
&lt;p>对资源的操作在任何时候都必须使用正确的HTTP方法，并且必须遵守操作幂等性。&lt;/p>
&lt;p>支持的HTTP方法：&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>方法&lt;/th>
&lt;th>描述&lt;/th>
&lt;th>成功状态码&lt;/th>
&lt;th>是否幂等&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>GET&lt;/td>
&lt;td>获取资源&lt;/td>
&lt;td>200 OK&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>POST&lt;/td>
&lt;td>创建资源&lt;/td>
&lt;td>201 Created&lt;/td>
&lt;td>No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PUT&lt;/td>
&lt;td>替换资源&lt;/td>
&lt;td>200 OK&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>PATCH&lt;/td>
&lt;td>对资源进行局部更新&lt;/td>
&lt;td>200 OK&lt;/td>
&lt;td>No&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>DELETE&lt;/td>
&lt;td>删除资源&lt;/td>
&lt;td>204 No Content&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>OPTIONS&lt;/td>
&lt;td>获取接受的请求方法&lt;/td>
&lt;td>200 OK&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>HEAD&lt;/td>
&lt;td>获取HTTP首部信息&lt;/td>
&lt;td>200 OK&lt;/td>
&lt;td>Yes&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;h3 id="post-方法的响应">POST 方法的响应&lt;/h3>
&lt;p>POST 请求成功时将返回 &lt;code>201 Created&lt;/code> 状态码，此外响应根据需要有两种形式：&lt;/p>
&lt;ul>
&lt;li>
&lt;p>在响应中添加 &lt;code>Location&lt;/code> 首部并指定被创建资源的位置&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="n">Location&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="n">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">qcs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">woqutech&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">com&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">api&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">employees&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="mi">123&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>在响应中返回被创建资源的数据表示&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="put-和-patch方法">PUT 和 PATCH方法&lt;/h3>
&lt;p>PUT 和 PATCH 都表示更新资源的操作，但是 PUT 是全量替换而 PATCH 是部分更新。理论上来说前者应当将未传入的字段视作为 &lt;code>null&lt;/code> 或默认值并且更新到数据库中。目前我们的实现中分别使用了 PUT 和 PATCH，但是 PUT 方法会忽略未传字段，本质上也是一种部分更新。有置空需求的业务需要显式地传入字段并设为 &lt;code>null&lt;/code>。&lt;/p>
&lt;p>注意置空或表示 &lt;code>无&lt;/code> 统一使用 &lt;code>null&lt;/code> （后端及数据库可能表示为 &lt;code>None&lt;/code> 或 &lt;code>NULL&lt;/code>），不使用空字符串 &lt;code>&amp;quot;&amp;quot;&lt;/code>。&lt;/p>
&lt;h2 id="身份认证">身份认证&lt;/h2>
&lt;p>访问需要身份认证的端点时，若请求未携带凭据或凭据无效，将返回 &lt;code>401 Unauthorized&lt;/code> 。&lt;/p>
&lt;p>进行身份认证所需的 OAuth2 令牌需要放置在请求的 &lt;code>Authorization&lt;/code> 首部中，并使用 &lt;code>Bearer&lt;/code> 认证方式：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="n">curl&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="n">H&lt;/span> &lt;span class="s2">&amp;#34;Authorization: Bearer TOKEN&amp;#34;&lt;/span> &lt;span class="n">http&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="o">//&lt;/span>&lt;span class="n">qcs&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">woqutech&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="n">com&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">api&lt;/span>&lt;span class="o">/&lt;/span>&lt;span class="n">employees&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="请求参数">请求参数&lt;/h2>
&lt;p>对于 &lt;code>GET&lt;/code> 请求，将参数作为 HTTP 查询字符串添加到 URL 中可对获取的结果进行查询和过滤。&lt;/p>
&lt;p>对于 &lt;code>POST&lt;/code>， &lt;code>PATCH&lt;/code>， &lt;code>PUT&lt;/code> 和 &lt;code>DELETE&lt;/code> 请求，仍然可以在 URL 中使用查询字符串，URL中未包含的参数应编码为 JSON 。&lt;/p>
&lt;p>请求体内的内容不应该进行包装，若发送的内容为集合，应当直接发送包含对象集合的数组类型。&lt;/p>
&lt;h2 id="响应格式">响应格式&lt;/h2>
&lt;p>所有的响应都使用 &lt;code>200 OK&lt;/code> 状态码是错误的。&lt;/p>
&lt;h3 id="包装与可见性">包装与可见性&lt;/h3>
&lt;p>在约定响应的格式时，应始终考虑可见性。API 客户端可以根据约定理解和解析响应，从消息体获取所需要的详细信息，但服务端并非直接与客户端交互，还需考虑反向代理、网关、缓存、监控中间件等 HTTP 中间处理层。HTTP 消息体是用来表述资源的，HTTP 分层系统的中间层不会解析消息体，而是根据头部信息进行相应处理（如缓存层根据状态码决定是否缓存响应内容，监控层根据状态码监控可用状态）。&lt;/p>
&lt;p>使用包装结构的响应并弃用状态码时，请求是否成功以及响应内容仅在消息体中体现，对中间层组件不可见，可能会导致其执行错误的逻辑或增加不必要的解析逻辑。&lt;/p>
&lt;p>为了确保可见性，应始终保证响应具有丰富和准确的头部信息，消息体中不应包含除资源表述之外的其他信息，除非资源的表述需要（如集合资源的分页）不进行多余的包装。&lt;/p>
&lt;h3 id="错误">错误&lt;/h3>
&lt;p>对于未成功的请求，服务端应当对请求过程中的错误或异常进行处理，并返回统一的响应对象。&lt;/p>
&lt;p>API 客户端需要（通过状态码）被告知响应的高级错误类，比如当用户无权限访问端点时，返回的 &lt;code>403 Forbidden&lt;/code> 状态码会告知 HTTP 中间组件（如客户端库、缓存和代理）响应的整体语义。&lt;/p>
&lt;p>同时，API 客户端还需要获取关于错误的详细信息，比如发生错误的具体原因以及解决方案，当这些信息以机器可读的方式包含在响应体中时，客户端还能根据错误响应触发相应操作。&lt;/p>
&lt;p>&lt;strong>对象示例：&lt;/strong>&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="err">HTTP/&lt;/span>&lt;span class="mf">1.1&lt;/span> &lt;span class="mi">422&lt;/span> &lt;span class="err">Unprocessable&lt;/span> &lt;span class="err">Entity&lt;/span>
&lt;span class="err">Content-Type:&lt;/span> &lt;span class="err">application/json&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;ValadationError&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;message&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;请求数据验证失败&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;status&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">422&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;detail&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;loc&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;msg&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;field required&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;type&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;value_error.missing&amp;#34;&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>&lt;strong>对象成员：&lt;/strong>&lt;/p>
&lt;ul>
&lt;li>
&lt;p>&lt;code>type&lt;/code> (string) &lt;em>required&lt;/em>&lt;/p>
&lt;p>由服务端定义，一个简短的、人类可读的、指示问题类型的标识。在不同服务间对于同类问题的类型标识唯一，API 客户端能够对所有的问题类型进行处理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>message&lt;/code> (string) &lt;em>required&lt;/em>&lt;/p>
&lt;p>一个人类可读的关于发生该问题的简要解释。该信息返回给客户端开发者使用。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>status&lt;/code> (number) &lt;em>optional&lt;/em>&lt;/p>
&lt;p>由源头服务器生成的关于发生该问题的 HTTP 状态码&lt;/p>
&lt;p>API 客户端可以使用该字段来确定发生该问题时使用的原始状态代码，以防它在传递时被改变（如中间设备或缓存），而消息体在没有 HTTP 信息的情况下能够维持一致。 HTTP 中间组件仍将使用响应的 HTTP 状态码。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>detail&lt;/code> (object) &lt;em>optional&lt;/em>&lt;/p>
&lt;p>关于发生该问题的详细信息，可用于帮助 API 客户端修正错误。&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>&lt;strong>注意&lt;/strong>：在必要时，可对错误响应对象的成员进行扩展。&lt;/p>
&lt;p>不要轻易去定义新的问题类型，只有当区别对待问题类型对客户端有意义时，才设计对应的问题类型。尽量将问题归类到已有的能够自解释的 HTTP 错误状态码中，仅通过 &lt;code>message&lt;/code> 字段传递必要的提示信息，同时注意不应在错误响应对象描述过多和过于详细的服务端错误细节，避免引入安全风险。&lt;/p>
&lt;h3 id="详情表示">详情表示&lt;/h3>
&lt;p>详情表示无需进行任何封装。&lt;/p>
&lt;p>获取单个独立的资源时，响应通常包括该资源的所有属性。 这种情况定义为资源的详情表示。（API 客户端的身份认证有时会影响详情表示中包含的信息量。）&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-python" data-lang="python">&lt;span class="p">{&lt;/span>
&lt;span class="s2">&amp;#34;isbn&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;9780321125217&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="s2">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Domain-Driven Design&amp;#34;&lt;/span>
&lt;span class="s2">&amp;#34;authors&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>&lt;span class="s2">&amp;#34;Matin Fowler&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="s2">&amp;#34;Levis Knuth&amp;#34;&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="集合表示">集合表示&lt;/h3>
&lt;p>获取资源列表时，响应包括该资源的属性子集，这种情况定义为资源的集合表示。（出于计算和IO性能原因，集合表示会排除资源的部分属性，可通过详情表示获取这部分属性。）&lt;/p>
&lt;p>集合资源通过标准的 JSON 数组来表示，对于集合资源，分页是一种常规需求，集合表示响应中可能会包括资源集合表示和分页信息表示两部分。为了保持简单和一致，所有的集合表示响应无论是否包含分页信息都会对结构进行包装，示例如下：&lt;/p>
&lt;ul>
&lt;li>包含分页信息&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;data&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;isbn&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;9780321125217&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Domain-Driven Design&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="err">......&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;isbn&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;9780596805821&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;REST in Practice&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;pagination&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;page&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;per_page&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">30&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;pages&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">9&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="nt">&amp;#34;total&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="mi">256&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;ul>
&lt;li>不包含分页信息&lt;/li>
&lt;/ul>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="p">{&lt;/span>
&lt;span class="nt">&amp;#34;data&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="p">[&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;isbn&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;9780321125217&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;Domain-Driven Design&amp;#34;&lt;/span>&lt;span class="p">},&lt;/span>
&lt;span class="err">......&lt;/span>
&lt;span class="p">{&lt;/span>&lt;span class="nt">&amp;#34;isbn&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;9780596805821&amp;#34;&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nt">&amp;#34;name&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="s2">&amp;#34;REST in Practice&amp;#34;&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="p">],&lt;/span>
&lt;span class="nt">&amp;#34;pagination&amp;#34;&lt;/span>&lt;span class="p">:&lt;/span> &lt;span class="kc">null&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h3 id="分页">分页&lt;/h3>
&lt;p>默认情况下，集合表示的分页行为由 API 客户端驱动，使用 &lt;code>?page&lt;/code> 参数指定要返回页面编号（服务端默认值为 1）， 使用 &lt;code>?per_page&lt;/code> 参数指定每一页包含的资源数量（服务端默认值不大于 30）。&lt;/p>
&lt;p>注意页码编号从 1 开始，省略 &lt;code>?page&lt;/code> 参数将使用服务端的默认值而不是返回集合表示的所有资源，以免返回的数据量过大造成服务端数据库阻塞以及网络阻塞。API 客户端必须能够对消费任何给定请求的分页或非分页集合表示具有弹性，并进行相应约束（如设置分页参数的默认值和最大值）。&lt;/p>
&lt;h3 id="过滤与排序">过滤与排序&lt;/h3>
&lt;p>在事先约定的情况下，可根据需要对指定的资源字段进行过滤或排序。&lt;/p>
&lt;h2 id="cors">CORS&lt;/h2>
&lt;p>API 支持指定来源的跨域资源共享（CORS）请求。示例：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-json" data-lang="json">&lt;span class="err">curl&lt;/span> &lt;span class="err">-i&lt;/span> &lt;span class="err">-H&lt;/span> &lt;span class="s2">&amp;#34;Authorization: Bearer TOKEN&amp;#34;&lt;/span> &lt;span class="err">http://qcs.woqutech.com&lt;/span> &lt;span class="err">-H&lt;/span> &lt;span class="s2">&amp;#34;Origin: http://example.com&amp;#34;&lt;/span>
&lt;span class="err">HTTP/&lt;/span>&lt;span class="mf">1.1&lt;/span> &lt;span class="mi">200&lt;/span> &lt;span class="err">OK&lt;/span>
&lt;span class="err">...&lt;/span>
&lt;span class="err">Access-Control-Allow-Origin:&lt;/span> &lt;span class="err">http://example.com&lt;/span>
&lt;span class="err">Vary:&lt;/span> &lt;span class="err">Origin&lt;/span>
&lt;span class="err">RESPONSE&lt;/span> &lt;span class="err">BODY&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;h2 id="版本化">版本化&lt;/h2>
&lt;p>本规范暂不涉及。&lt;/p>
&lt;h2 id="超媒体">超媒体&lt;/h2>
&lt;p>对资源进行操作的请求地址由 API 客户端自行构造，不使用超媒体表示。&lt;/p>
&lt;h2 id="接口文档">接口文档&lt;/h2>
&lt;p>使用 &lt;a href="https://swagger.io/specification/">OpenAPI Specification (OAS) 3.0&lt;/a> 作为 API 的交互式文档标准。&lt;/p>
&lt;p>API 客户端可访问指定地址获取拥有 UI 界面的接口文档，以及 JSON 格式的文档文本。&lt;/p>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ul>
&lt;li>&lt;a href="https://developer.github.com/v3">GitHub REST API v3&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/microsoft/api-guidelines/blob/vNext/Guidelines.md">Microsoft api guidelines&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.vinaysahni.com/best-practices-for-a-pragmatic-restful-api">Best Practices for Designing a Pragmatic RESTful API&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://tools.ietf.org/html/rfc7807">RFC7807&lt;/a>&lt;/li>
&lt;/ul></content><category scheme="https://www.waynerv.com/categories/web/" term="Web" label="Web"/><category scheme="https://www.waynerv.com/tags/restful/" term="RESTful" label="RESTful"/></entry><entry><title type="text">记录一次迁移MySQL数据文件到新硬盘的过程</title><link rel="alternate" type="text/html" href="https://www.waynerv.com/posts/migrate-mysql-to-a-new-disk/"/><id>https://www.waynerv.com/posts/migrate-mysql-to-a-new-disk/</id><updated>2021-07-20T09:08:32+00:00</updated><published>2020-09-08T12:14:24+08:00</published><author><name>Waynerv</name><uri>https://www.waynerv.com</uri><email>ampedee@gmail.com</email></author><rights>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</rights><summary type="html">迁移前的环境 MySQL Server 程序编译安装于 qmysql 用户的 /home/qmysql/qmysql/packages 目录下，文件夹结构如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 .……</summary><content type="html">&lt;h2 id="迁移前的环境">迁移前的环境&lt;/h2>
&lt;p>MySQL Server 程序编译安装于 &lt;code>qmysql&lt;/code> 用户的 &lt;code>/home/qmysql/qmysql/packages&lt;/code> 目录下，文件夹结构如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt"> 1
&lt;/span>&lt;span class="lnt"> 2
&lt;/span>&lt;span class="lnt"> 3
&lt;/span>&lt;span class="lnt"> 4
&lt;/span>&lt;span class="lnt"> 5
&lt;/span>&lt;span class="lnt"> 6
&lt;/span>&lt;span class="lnt"> 7
&lt;/span>&lt;span class="lnt"> 8
&lt;/span>&lt;span class="lnt"> 9
&lt;/span>&lt;span class="lnt">10
&lt;/span>&lt;span class="lnt">11
&lt;/span>&lt;span class="lnt">12
&lt;/span>&lt;span class="lnt">13
&lt;/span>&lt;span class="lnt">14
&lt;/span>&lt;span class="lnt">15
&lt;/span>&lt;span class="lnt">16
&lt;/span>&lt;span class="lnt">17
&lt;/span>&lt;span class="lnt">18
&lt;/span>&lt;span class="lnt">19
&lt;/span>&lt;span class="lnt">20
&lt;/span>&lt;span class="lnt">21
&lt;/span>&lt;span class="lnt">22
&lt;/span>&lt;span class="lnt">23
&lt;/span>&lt;span class="lnt">24
&lt;/span>&lt;span class="lnt">25
&lt;/span>&lt;span class="lnt">26
&lt;/span>&lt;span class="lnt">27
&lt;/span>&lt;span class="lnt">28
&lt;/span>&lt;span class="lnt">29
&lt;/span>&lt;span class="lnt">30
&lt;/span>&lt;span class="lnt">31
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">.
├── data
│   ├── auto.cnf
│   ├── binlog
│   ├── conf
│   ├── ib_buffer_pool
│   ├── ibdata1
│   ├── ib_logfile0
│   ├── ib_logfile1
│   ├── innodb_log
│   ├── innodb_ts
│   ├── log
│   ├── mydata
│   ├── qcs-server.err
│   ├── relaylog
│   ├── slowlog
│   ├── sock
│   ├── tmpdir
│   └── undo
├── mysql -&amp;gt; /home/qmysql/qmysql/packages/mysql-5.7.21-linux-glibc2.12-x86_64
└── mysql-5.7.21-linux-glibc2.12-x86_64
├── bin
├── COPYING
├── data -&amp;gt; /home/qmysql/qmysql/packages/data &lt;span class="o">[&lt;/span>recursive, not followed&lt;span class="o">]&lt;/span>
├── docs
├── include
├── lib
├── man
├── README
├── share
└── support-files
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>现在在服务器上新加了一块固态硬盘，想将原来存放在机械硬盘的数据库的所有数据文件即 &lt;code>data&lt;/code> 文件夹迁移到新硬盘中，以加快数据库的读写效率。&lt;/p>
&lt;p>通过 &lt;code>fdisk -l&lt;/code> 获取硬盘信息如下：&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">Disk /dev/sdb: 1197.8 GB, &lt;span class="m">1197759004672&lt;/span> bytes, &lt;span class="m">2339373056&lt;/span> sectors
&lt;span class="nv">Units&lt;/span> &lt;span class="o">=&lt;/span> sectors of &lt;span class="m">1&lt;/span> * &lt;span class="nv">512&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="m">512&lt;/span> bytes
Sector size &lt;span class="o">(&lt;/span>logical/physical&lt;span class="o">)&lt;/span>: &lt;span class="m">512&lt;/span> bytes / &lt;span class="m">4096&lt;/span> bytes
I/O size &lt;span class="o">(&lt;/span>minimum/optimal&lt;span class="o">)&lt;/span>: &lt;span class="m">4096&lt;/span> bytes / &lt;span class="m">4096&lt;/span> bytes
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>考虑到现在挂载的硬盘均以 &lt;code>lvm&lt;/code> 的方式进行分卷，计划从固态硬盘中创建 300G 的逻辑卷，挂载到系统根目录的 &lt;code>/data&lt;/code> 目录，然后将 &lt;code>mysql&lt;/code> 的数据文件拷贝至该位置，再&lt;strong>软链接&lt;/strong>到原来的位置，这样可以在不更改任何mysql配置的情况下完成迁移。&lt;/p>
&lt;h2 id="创建数据卷">创建数据卷&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>初始化物理卷&lt;/p>
&lt;p>将物理硬盘分区初始化为物理卷，以便LVM使用。参数为要创建的物理卷对应的设备文件名。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">pvcreate /dev/sdb
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>创建卷组&lt;/p>
&lt;p>vgcreate命令用于创建LVM卷组。卷组（Volume Group）将多个物理卷组织成一个整体，屏蔽了底层物理卷细节。在卷组上创建逻辑卷时不用考虑具体的物理卷信息。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">vgcreate data_vg /dev/sdb
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>创建逻辑卷&lt;/p>
&lt;p>创建大小300G大小的逻辑卷 ，-L 指定大小，-n指定名称，最后指定卷组名称&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">lvcreate -L 300G -n mysqldata data_vg
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>格式化逻辑卷&lt;/p>
&lt;p>对逻辑卷进行xfs格式化&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">mkfs.xfs /dev/data_vg/mysqldata
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>挂载文件目录&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">mount /dev/data_vg/mysqldata /data
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>设置开机磁盘自动挂载&lt;/p>
&lt;p>要让系统开机自动挂载磁盘，需要将挂载信息写入到/etc/fstab文件中，否则重启后需要手动挂载。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;span class="lnt">2
&lt;/span>&lt;span class="lnt">3
&lt;/span>&lt;span class="lnt">4
&lt;/span>&lt;span class="lnt">5
&lt;/span>&lt;span class="lnt">6
&lt;/span>&lt;span class="lnt">7
&lt;/span>&lt;span class="lnt">8
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">$ vim /etc/fstab
/dev/mapper/centos00-root / xfs defaults &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span>
&lt;span class="nv">UUID&lt;/span>&lt;span class="o">=&lt;/span>80f8fe62-70ab-4c9e-8d28-52c0d5e97979 /boot xfs defaults &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span>
/dev/mapper/centos00-home /home xfs defaults &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span>
/dev/mapper/centos00-swap swap swap defaults &lt;span class="m">0&lt;/span> &lt;span class="m">0&lt;/span>
/dev/centos00/backup /backup xfs defaults &lt;span class="m">0&lt;/span> &lt;span class="m">2&lt;/span>
/dev/mapper/data_vg-mysqldata /data xfs defaults &lt;span class="m">0&lt;/span> &lt;span class="m">2&lt;/span>
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;p>添加最下面一行命令后保存退出。完成。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h2 id="迁移数据文件">迁移数据文件&lt;/h2>
&lt;p>开始迁移前需要关闭 &lt;code>mysql&lt;/code> 服务，终止运行数据库。&lt;/p>
&lt;ol>
&lt;li>
&lt;p>切换用户&lt;/p>
&lt;p>为保证文件复制前后的所有者一致，避免出现文件权限问题，首先切换到当前mysql程序下文件的所有者用户 &lt;code>qmysql&lt;/code>。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>复制文件&lt;/p>
&lt;p>复制所有 &lt;code>mysql&lt;/code> 数据文件到固态硬盘的新目录，并保留所有文件目录属性。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">cp -ar /home/qmysql/qmysql/packages/data /data/
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>备份原文件&lt;/p>
&lt;p>保险起见，将原来的数据文件进行备份。&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">mv data data.bak
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;li>
&lt;p>重新链接数据文件&lt;/p>
&lt;p>将固态硬盘中的数据文件目录软链接到原来的数据文件位置&lt;/p>
&lt;div class="highlight">&lt;div class="chroma">
&lt;table class="lntable">&lt;tr>&lt;td class="lntd">
&lt;pre class="chroma">&lt;code>&lt;span class="lnt">1
&lt;/span>&lt;/code>&lt;/pre>&lt;/td>
&lt;td class="lntd">
&lt;pre class="chroma">&lt;code class="language-bash" data-lang="bash">ln -s /data/data /home/qmysql/qmysql/packages/
&lt;/code>&lt;/pre>&lt;/td>&lt;/tr>&lt;/table>
&lt;/div>
&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>重启数据库服务，大功告成！&lt;/p></content><category scheme="https://www.waynerv.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/" term="数据库" label="数据库"/><category scheme="https://www.waynerv.com/tags/mysql/" term="MySQL" label="MySQL"/></entry></feed>